# [allow (clippy :: let_and_return , clippy :: suspicious_else_formatting , clippy :: redundant_field_names , dead_code , non_camel_case_types , non_snake_case , non_upper_case_globals , redundant_semicolons , unreachable_patterns , unused_braces , unused_imports , unused_parens , unused_qualifications , unused_unsafe , unused_variables)] pub mod types { pub mod platform_version { pub mod error { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`PlatformVersionError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum platform_version_error_PlatformVersionError { UnknownVersionError (* mut std :: os :: raw :: c_char) } impl ferment :: FFIConversionFrom < platform_version :: error :: PlatformVersionError > for platform_version_error_PlatformVersionError { unsafe fn ffi_from_const (ffi : * const platform_version_error_PlatformVersionError) -> platform_version :: error :: PlatformVersionError { let ffi_ref = & * ffi ; match ffi_ref { platform_version_error_PlatformVersionError :: UnknownVersionError (o_0) => platform_version :: error :: PlatformVersionError :: UnknownVersionError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < platform_version :: error :: PlatformVersionError > for platform_version_error_PlatformVersionError { unsafe fn ffi_to_const (obj : platform_version :: error :: PlatformVersionError) -> * const platform_version_error_PlatformVersionError { ferment :: boxed (match obj { platform_version :: error :: PlatformVersionError :: UnknownVersionError (o_0) => platform_version_error_PlatformVersionError :: UnknownVersionError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for platform_version_error_PlatformVersionError { fn drop (& mut self) { unsafe { match self { platform_version_error_PlatformVersionError :: UnknownVersionError (o_0) => { ferment :: unbox_string (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod version { pub mod fee { use crate as example_platform ; pub mod data_contract_registration { use crate as example_platform ; # [doc = "FFI-representation of the [`FeeDataContractRegistrationVersion`]"] # [repr (C)] # [derive (Clone)] pub struct platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion { pub base_contract_registration_fee : u64 , pub document_type_registration_fee : u64 , pub document_type_base_non_unique_index_registration_fee : u64 , pub document_type_base_unique_index_registration_fee : u64 , pub document_type_base_contested_index_registration_fee : u64 , pub token_registration_fee : u64 , pub token_uses_perpetual_distribution_fee : u64 , pub token_uses_pre_programmed_distribution_fee : u64 , pub search_keyword_fee : u64 } impl ferment :: FFIConversionFrom < platform_version :: version :: fee :: data_contract_registration :: FeeDataContractRegistrationVersion > for platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion { unsafe fn ffi_from_const (ffi : * const platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion) -> platform_version :: version :: fee :: data_contract_registration :: FeeDataContractRegistrationVersion { let ffi_ref = & * ffi ; platform_version :: version :: fee :: data_contract_registration :: FeeDataContractRegistrationVersion { base_contract_registration_fee : ffi_ref . base_contract_registration_fee , document_type_registration_fee : ffi_ref . document_type_registration_fee , document_type_base_non_unique_index_registration_fee : ffi_ref . document_type_base_non_unique_index_registration_fee , document_type_base_unique_index_registration_fee : ffi_ref . document_type_base_unique_index_registration_fee , document_type_base_contested_index_registration_fee : ffi_ref . document_type_base_contested_index_registration_fee , token_registration_fee : ffi_ref . token_registration_fee , token_uses_perpetual_distribution_fee : ffi_ref . token_uses_perpetual_distribution_fee , token_uses_pre_programmed_distribution_fee : ffi_ref . token_uses_pre_programmed_distribution_fee , search_keyword_fee : ffi_ref . search_keyword_fee } } } impl ferment :: FFIConversionTo < platform_version :: version :: fee :: data_contract_registration :: FeeDataContractRegistrationVersion > for platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion { unsafe fn ffi_to_const (obj : platform_version :: version :: fee :: data_contract_registration :: FeeDataContractRegistrationVersion) -> * const platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion { ferment :: boxed (platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion { base_contract_registration_fee : obj . base_contract_registration_fee , document_type_registration_fee : obj . document_type_registration_fee , document_type_base_non_unique_index_registration_fee : obj . document_type_base_non_unique_index_registration_fee , document_type_base_unique_index_registration_fee : obj . document_type_base_unique_index_registration_fee , document_type_base_contested_index_registration_fee : obj . document_type_base_contested_index_registration_fee , token_registration_fee : obj . token_registration_fee , token_uses_perpetual_distribution_fee : obj . token_uses_perpetual_distribution_fee , token_uses_pre_programmed_distribution_fee : obj . token_uses_pre_programmed_distribution_fee , search_keyword_fee : obj . search_keyword_fee }) } } } pub mod data_contract_validation { use crate as example_platform ; # [doc = "FFI-representation of the [`FeeDataContractValidationVersion`]"] # [repr (C)] # [derive (Clone)] pub struct platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion { pub document_type_base_fee : u64 , pub document_type_schema_size_fee : u64 , pub document_type_per_property_fee : u64 , pub document_type_base_non_unique_index_fee : u64 , pub document_type_non_unique_index_per_property_fee : u64 , pub document_type_base_unique_index_fee : u64 , pub document_type_unique_index_per_property_fee : u64 } impl ferment :: FFIConversionFrom < platform_version :: version :: fee :: data_contract_validation :: FeeDataContractValidationVersion > for platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion { unsafe fn ffi_from_const (ffi : * const platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion) -> platform_version :: version :: fee :: data_contract_validation :: FeeDataContractValidationVersion { let ffi_ref = & * ffi ; platform_version :: version :: fee :: data_contract_validation :: FeeDataContractValidationVersion { document_type_base_fee : ffi_ref . document_type_base_fee , document_type_schema_size_fee : ffi_ref . document_type_schema_size_fee , document_type_per_property_fee : ffi_ref . document_type_per_property_fee , document_type_base_non_unique_index_fee : ffi_ref . document_type_base_non_unique_index_fee , document_type_non_unique_index_per_property_fee : ffi_ref . document_type_non_unique_index_per_property_fee , document_type_base_unique_index_fee : ffi_ref . document_type_base_unique_index_fee , document_type_unique_index_per_property_fee : ffi_ref . document_type_unique_index_per_property_fee } } } impl ferment :: FFIConversionTo < platform_version :: version :: fee :: data_contract_validation :: FeeDataContractValidationVersion > for platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion { unsafe fn ffi_to_const (obj : platform_version :: version :: fee :: data_contract_validation :: FeeDataContractValidationVersion) -> * const platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion { ferment :: boxed (platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion { document_type_base_fee : obj . document_type_base_fee , document_type_schema_size_fee : obj . document_type_schema_size_fee , document_type_per_property_fee : obj . document_type_per_property_fee , document_type_base_non_unique_index_fee : obj . document_type_base_non_unique_index_fee , document_type_non_unique_index_per_property_fee : obj . document_type_non_unique_index_per_property_fee , document_type_base_unique_index_fee : obj . document_type_base_unique_index_fee , document_type_unique_index_per_property_fee : obj . document_type_unique_index_per_property_fee }) } } } pub mod hashing { use crate as example_platform ; # [doc = "FFI-representation of the [`FeeHashingVersion`]"] # [repr (C)] # [derive (Clone)] pub struct platform_version_version_fee_hashing_FeeHashingVersion { pub blake3_base : u64 , pub blake3_per_block : u64 , pub sha256_per_block : u64 , pub sha256_ripe_md160_base : u64 , pub single_sha256_base : u64 } impl ferment :: FFIConversionFrom < platform_version :: version :: fee :: hashing :: FeeHashingVersion > for platform_version_version_fee_hashing_FeeHashingVersion { unsafe fn ffi_from_const (ffi : * const platform_version_version_fee_hashing_FeeHashingVersion) -> platform_version :: version :: fee :: hashing :: FeeHashingVersion { let ffi_ref = & * ffi ; platform_version :: version :: fee :: hashing :: FeeHashingVersion { blake3_base : ffi_ref . blake3_base , blake3_per_block : ffi_ref . blake3_per_block , sha256_per_block : ffi_ref . sha256_per_block , sha256_ripe_md160_base : ffi_ref . sha256_ripe_md160_base , single_sha256_base : ffi_ref . single_sha256_base } } } impl ferment :: FFIConversionTo < platform_version :: version :: fee :: hashing :: FeeHashingVersion > for platform_version_version_fee_hashing_FeeHashingVersion { unsafe fn ffi_to_const (obj : platform_version :: version :: fee :: hashing :: FeeHashingVersion) -> * const platform_version_version_fee_hashing_FeeHashingVersion { ferment :: boxed (platform_version_version_fee_hashing_FeeHashingVersion { blake3_base : obj . blake3_base , blake3_per_block : obj . blake3_per_block , sha256_per_block : obj . sha256_per_block , sha256_ripe_md160_base : obj . sha256_ripe_md160_base , single_sha256_base : obj . single_sha256_base }) } } } pub mod processing { use crate as example_platform ; # [doc = "FFI-representation of the [`FeeProcessingVersion`]"] # [repr (C)] # [derive (Clone)] pub struct platform_version_version_fee_processing_FeeProcessingVersion { pub fetch_identity_balance_processing_cost : u64 , pub fetch_identity_revision_processing_cost : u64 , pub fetch_identity_balance_and_revision_processing_cost : u64 , pub fetch_identity_cost_per_look_up_key_by_id : u64 , pub fetch_identity_token_balance_processing_cost : u64 , pub fetch_prefunded_specialized_balance_processing_cost : u64 , pub fetch_single_identity_key_processing_cost : u64 , pub validate_key_structure : u64 , pub perform_network_threshold_signing : u64 } impl ferment :: FFIConversionFrom < platform_version :: version :: fee :: processing :: FeeProcessingVersion > for platform_version_version_fee_processing_FeeProcessingVersion { unsafe fn ffi_from_const (ffi : * const platform_version_version_fee_processing_FeeProcessingVersion) -> platform_version :: version :: fee :: processing :: FeeProcessingVersion { let ffi_ref = & * ffi ; platform_version :: version :: fee :: processing :: FeeProcessingVersion { fetch_identity_balance_processing_cost : ffi_ref . fetch_identity_balance_processing_cost , fetch_identity_revision_processing_cost : ffi_ref . fetch_identity_revision_processing_cost , fetch_identity_balance_and_revision_processing_cost : ffi_ref . fetch_identity_balance_and_revision_processing_cost , fetch_identity_cost_per_look_up_key_by_id : ffi_ref . fetch_identity_cost_per_look_up_key_by_id , fetch_identity_token_balance_processing_cost : ffi_ref . fetch_identity_token_balance_processing_cost , fetch_prefunded_specialized_balance_processing_cost : ffi_ref . fetch_prefunded_specialized_balance_processing_cost , fetch_single_identity_key_processing_cost : ffi_ref . fetch_single_identity_key_processing_cost , validate_key_structure : ffi_ref . validate_key_structure , perform_network_threshold_signing : ffi_ref . perform_network_threshold_signing } } } impl ferment :: FFIConversionTo < platform_version :: version :: fee :: processing :: FeeProcessingVersion > for platform_version_version_fee_processing_FeeProcessingVersion { unsafe fn ffi_to_const (obj : platform_version :: version :: fee :: processing :: FeeProcessingVersion) -> * const platform_version_version_fee_processing_FeeProcessingVersion { ferment :: boxed (platform_version_version_fee_processing_FeeProcessingVersion { fetch_identity_balance_processing_cost : obj . fetch_identity_balance_processing_cost , fetch_identity_revision_processing_cost : obj . fetch_identity_revision_processing_cost , fetch_identity_balance_and_revision_processing_cost : obj . fetch_identity_balance_and_revision_processing_cost , fetch_identity_cost_per_look_up_key_by_id : obj . fetch_identity_cost_per_look_up_key_by_id , fetch_identity_token_balance_processing_cost : obj . fetch_identity_token_balance_processing_cost , fetch_prefunded_specialized_balance_processing_cost : obj . fetch_prefunded_specialized_balance_processing_cost , fetch_single_identity_key_processing_cost : obj . fetch_single_identity_key_processing_cost , validate_key_structure : obj . validate_key_structure , perform_network_threshold_signing : obj . perform_network_threshold_signing }) } } } pub mod signature { use crate as example_platform ; # [doc = "FFI-representation of the [`FeeSignatureVersion`]"] # [repr (C)] # [derive (Clone)] pub struct platform_version_version_fee_signature_FeeSignatureVersion { pub verify_signature_ecdsa_secp256k1 : u64 , pub verify_signature_bls12_381 : u64 , pub verify_signature_ecdsa_hash160 : u64 , pub verify_signature_bip13_script_hash : u64 , pub verify_signature_eddsa25519_hash160 : u64 } impl ferment :: FFIConversionFrom < platform_version :: version :: fee :: signature :: FeeSignatureVersion > for platform_version_version_fee_signature_FeeSignatureVersion { unsafe fn ffi_from_const (ffi : * const platform_version_version_fee_signature_FeeSignatureVersion) -> platform_version :: version :: fee :: signature :: FeeSignatureVersion { let ffi_ref = & * ffi ; platform_version :: version :: fee :: signature :: FeeSignatureVersion { verify_signature_ecdsa_secp256k1 : ffi_ref . verify_signature_ecdsa_secp256k1 , verify_signature_bls12_381 : ffi_ref . verify_signature_bls12_381 , verify_signature_ecdsa_hash160 : ffi_ref . verify_signature_ecdsa_hash160 , verify_signature_bip13_script_hash : ffi_ref . verify_signature_bip13_script_hash , verify_signature_eddsa25519_hash160 : ffi_ref . verify_signature_eddsa25519_hash160 } } } impl ferment :: FFIConversionTo < platform_version :: version :: fee :: signature :: FeeSignatureVersion > for platform_version_version_fee_signature_FeeSignatureVersion { unsafe fn ffi_to_const (obj : platform_version :: version :: fee :: signature :: FeeSignatureVersion) -> * const platform_version_version_fee_signature_FeeSignatureVersion { ferment :: boxed (platform_version_version_fee_signature_FeeSignatureVersion { verify_signature_ecdsa_secp256k1 : obj . verify_signature_ecdsa_secp256k1 , verify_signature_bls12_381 : obj . verify_signature_bls12_381 , verify_signature_ecdsa_hash160 : obj . verify_signature_ecdsa_hash160 , verify_signature_bip13_script_hash : obj . verify_signature_bip13_script_hash , verify_signature_eddsa25519_hash160 : obj . verify_signature_eddsa25519_hash160 }) } } } pub mod state_transition_min_fees { use crate as example_platform ; # [doc = "FFI-representation of the [`StateTransitionMinFees`]"] # [repr (C)] # [derive (Clone)] pub struct platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees { pub credit_transfer : u64 , pub credit_withdrawal : u64 , pub identity_update : u64 , pub document_batch_sub_transition : u64 , pub contract_create : u64 , pub contract_update : u64 , pub masternode_vote : u64 } impl ferment :: FFIConversionFrom < platform_version :: version :: fee :: state_transition_min_fees :: StateTransitionMinFees > for platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees { unsafe fn ffi_from_const (ffi : * const platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees) -> platform_version :: version :: fee :: state_transition_min_fees :: StateTransitionMinFees { let ffi_ref = & * ffi ; platform_version :: version :: fee :: state_transition_min_fees :: StateTransitionMinFees { credit_transfer : ffi_ref . credit_transfer , credit_withdrawal : ffi_ref . credit_withdrawal , identity_update : ffi_ref . identity_update , document_batch_sub_transition : ffi_ref . document_batch_sub_transition , contract_create : ffi_ref . contract_create , contract_update : ffi_ref . contract_update , masternode_vote : ffi_ref . masternode_vote } } } impl ferment :: FFIConversionTo < platform_version :: version :: fee :: state_transition_min_fees :: StateTransitionMinFees > for platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees { unsafe fn ffi_to_const (obj : platform_version :: version :: fee :: state_transition_min_fees :: StateTransitionMinFees) -> * const platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees { ferment :: boxed (platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees { credit_transfer : obj . credit_transfer , credit_withdrawal : obj . credit_withdrawal , identity_update : obj . identity_update , document_batch_sub_transition : obj . document_batch_sub_transition , contract_create : obj . contract_create , contract_update : obj . contract_update , masternode_vote : obj . masternode_vote }) } } } pub mod storage { use crate as example_platform ; # [doc = "FFI-representation of the [`FeeStorageVersion`]"] # [repr (C)] # [derive (Clone)] pub struct platform_version_version_fee_storage_FeeStorageVersion { pub storage_disk_usage_credit_per_byte : u64 , pub storage_processing_credit_per_byte : u64 , pub storage_load_credit_per_byte : u64 , pub non_storage_load_credit_per_byte : u64 , pub storage_seek_cost : u64 } impl ferment :: FFIConversionFrom < platform_version :: version :: fee :: storage :: FeeStorageVersion > for platform_version_version_fee_storage_FeeStorageVersion { unsafe fn ffi_from_const (ffi : * const platform_version_version_fee_storage_FeeStorageVersion) -> platform_version :: version :: fee :: storage :: FeeStorageVersion { let ffi_ref = & * ffi ; platform_version :: version :: fee :: storage :: FeeStorageVersion { storage_disk_usage_credit_per_byte : ffi_ref . storage_disk_usage_credit_per_byte , storage_processing_credit_per_byte : ffi_ref . storage_processing_credit_per_byte , storage_load_credit_per_byte : ffi_ref . storage_load_credit_per_byte , non_storage_load_credit_per_byte : ffi_ref . non_storage_load_credit_per_byte , storage_seek_cost : ffi_ref . storage_seek_cost } } } impl ferment :: FFIConversionTo < platform_version :: version :: fee :: storage :: FeeStorageVersion > for platform_version_version_fee_storage_FeeStorageVersion { unsafe fn ffi_to_const (obj : platform_version :: version :: fee :: storage :: FeeStorageVersion) -> * const platform_version_version_fee_storage_FeeStorageVersion { ferment :: boxed (platform_version_version_fee_storage_FeeStorageVersion { storage_disk_usage_credit_per_byte : obj . storage_disk_usage_credit_per_byte , storage_processing_credit_per_byte : obj . storage_processing_credit_per_byte , storage_load_credit_per_byte : obj . storage_load_credit_per_byte , non_storage_load_credit_per_byte : obj . non_storage_load_credit_per_byte , storage_seek_cost : obj . storage_seek_cost }) } } } pub mod vote_resolution_fund_fees { use crate as example_platform ; # [doc = "FFI-representation of the [`VoteResolutionFundFees`]"] # [repr (C)] # [derive (Clone)] pub struct platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees { pub contested_document_vote_resolution_fund_required_amount : u64 , pub contested_document_vote_resolution_unlock_fund_required_amount : u64 , pub contested_document_single_vote_cost : u64 } impl ferment :: FFIConversionFrom < platform_version :: version :: fee :: vote_resolution_fund_fees :: VoteResolutionFundFees > for platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees { unsafe fn ffi_from_const (ffi : * const platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees) -> platform_version :: version :: fee :: vote_resolution_fund_fees :: VoteResolutionFundFees { let ffi_ref = & * ffi ; platform_version :: version :: fee :: vote_resolution_fund_fees :: VoteResolutionFundFees { contested_document_vote_resolution_fund_required_amount : ffi_ref . contested_document_vote_resolution_fund_required_amount , contested_document_vote_resolution_unlock_fund_required_amount : ffi_ref . contested_document_vote_resolution_unlock_fund_required_amount , contested_document_single_vote_cost : ffi_ref . contested_document_single_vote_cost } } } impl ferment :: FFIConversionTo < platform_version :: version :: fee :: vote_resolution_fund_fees :: VoteResolutionFundFees > for platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees { unsafe fn ffi_to_const (obj : platform_version :: version :: fee :: vote_resolution_fund_fees :: VoteResolutionFundFees) -> * const platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees { ferment :: boxed (platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees { contested_document_vote_resolution_fund_required_amount : obj . contested_document_vote_resolution_fund_required_amount , contested_document_vote_resolution_unlock_fund_required_amount : obj . contested_document_vote_resolution_unlock_fund_required_amount , contested_document_single_vote_cost : obj . contested_document_single_vote_cost }) } } } # [doc = "FFI-representation of the [`FeeVersion`]"] # [repr (C)] # [derive (Clone)] pub struct platform_version_version_fee_FeeVersion { pub fee_version_number : * mut platform_version :: version :: fee :: FeeVersionNumber , pub uses_version_fee_multiplier_permille : * mut u64 , pub storage : * mut crate :: fermented :: types :: platform_version :: version :: fee :: storage :: platform_version_version_fee_storage_FeeStorageVersion , pub signature : * mut crate :: fermented :: types :: platform_version :: version :: fee :: signature :: platform_version_version_fee_signature_FeeSignatureVersion , pub hashing : * mut crate :: fermented :: types :: platform_version :: version :: fee :: hashing :: platform_version_version_fee_hashing_FeeHashingVersion , pub processing : * mut crate :: fermented :: types :: platform_version :: version :: fee :: processing :: platform_version_version_fee_processing_FeeProcessingVersion , pub data_contract_validation : * mut crate :: fermented :: types :: platform_version :: version :: fee :: data_contract_validation :: platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion , pub data_contract_registration : * mut crate :: fermented :: types :: platform_version :: version :: fee :: data_contract_registration :: platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion , pub state_transition_min_fees : * mut crate :: fermented :: types :: platform_version :: version :: fee :: state_transition_min_fees :: platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees , pub vote_resolution_fund_fees : * mut crate :: fermented :: types :: platform_version :: version :: fee :: vote_resolution_fund_fees :: platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees } impl ferment :: FFIConversionFrom < platform_version :: version :: fee :: FeeVersion > for platform_version_version_fee_FeeVersion { unsafe fn ffi_from_const (ffi : * const platform_version_version_fee_FeeVersion) -> platform_version :: version :: fee :: FeeVersion { let ffi_ref = & * ffi ; platform_version :: version :: fee :: FeeVersion { fee_version_number : std :: ptr :: read (ffi_ref . fee_version_number) , uses_version_fee_multiplier_permille : ferment :: from_opt_primitive (ffi_ref . uses_version_fee_multiplier_permille) , storage : < crate :: fermented :: types :: platform_version :: version :: fee :: storage :: platform_version_version_fee_storage_FeeStorageVersion as ferment :: FFIConversionFrom < platform_version :: version :: fee :: storage :: FeeStorageVersion >> :: ffi_from (ffi_ref . storage) , signature : < crate :: fermented :: types :: platform_version :: version :: fee :: signature :: platform_version_version_fee_signature_FeeSignatureVersion as ferment :: FFIConversionFrom < platform_version :: version :: fee :: signature :: FeeSignatureVersion >> :: ffi_from (ffi_ref . signature) , hashing : < crate :: fermented :: types :: platform_version :: version :: fee :: hashing :: platform_version_version_fee_hashing_FeeHashingVersion as ferment :: FFIConversionFrom < platform_version :: version :: fee :: hashing :: FeeHashingVersion >> :: ffi_from (ffi_ref . hashing) , processing : < crate :: fermented :: types :: platform_version :: version :: fee :: processing :: platform_version_version_fee_processing_FeeProcessingVersion as ferment :: FFIConversionFrom < platform_version :: version :: fee :: processing :: FeeProcessingVersion >> :: ffi_from (ffi_ref . processing) , data_contract_validation : < crate :: fermented :: types :: platform_version :: version :: fee :: data_contract_validation :: platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion as ferment :: FFIConversionFrom < platform_version :: version :: fee :: data_contract_validation :: FeeDataContractValidationVersion >> :: ffi_from (ffi_ref . data_contract_validation) , data_contract_registration : < crate :: fermented :: types :: platform_version :: version :: fee :: data_contract_registration :: platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion as ferment :: FFIConversionFrom < platform_version :: version :: fee :: data_contract_registration :: FeeDataContractRegistrationVersion >> :: ffi_from (ffi_ref . data_contract_registration) , state_transition_min_fees : < crate :: fermented :: types :: platform_version :: version :: fee :: state_transition_min_fees :: platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees as ferment :: FFIConversionFrom < platform_version :: version :: fee :: state_transition_min_fees :: StateTransitionMinFees >> :: ffi_from (ffi_ref . state_transition_min_fees) , vote_resolution_fund_fees : < crate :: fermented :: types :: platform_version :: version :: fee :: vote_resolution_fund_fees :: platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees as ferment :: FFIConversionFrom < platform_version :: version :: fee :: vote_resolution_fund_fees :: VoteResolutionFundFees >> :: ffi_from (ffi_ref . vote_resolution_fund_fees) } } } impl ferment :: FFIConversionTo < platform_version :: version :: fee :: FeeVersion > for platform_version_version_fee_FeeVersion { unsafe fn ffi_to_const (obj : platform_version :: version :: fee :: FeeVersion) -> * const platform_version_version_fee_FeeVersion { ferment :: boxed (platform_version_version_fee_FeeVersion { fee_version_number : ferment :: boxed (obj . fee_version_number) , uses_version_fee_multiplier_permille : ferment :: to_opt_primitive (obj . uses_version_fee_multiplier_permille) , storage : < crate :: fermented :: types :: platform_version :: version :: fee :: storage :: platform_version_version_fee_storage_FeeStorageVersion as ferment :: FFIConversionTo < platform_version :: version :: fee :: storage :: FeeStorageVersion >> :: ffi_to (obj . storage) , signature : < crate :: fermented :: types :: platform_version :: version :: fee :: signature :: platform_version_version_fee_signature_FeeSignatureVersion as ferment :: FFIConversionTo < platform_version :: version :: fee :: signature :: FeeSignatureVersion >> :: ffi_to (obj . signature) , hashing : < crate :: fermented :: types :: platform_version :: version :: fee :: hashing :: platform_version_version_fee_hashing_FeeHashingVersion as ferment :: FFIConversionTo < platform_version :: version :: fee :: hashing :: FeeHashingVersion >> :: ffi_to (obj . hashing) , processing : < crate :: fermented :: types :: platform_version :: version :: fee :: processing :: platform_version_version_fee_processing_FeeProcessingVersion as ferment :: FFIConversionTo < platform_version :: version :: fee :: processing :: FeeProcessingVersion >> :: ffi_to (obj . processing) , data_contract_validation : < crate :: fermented :: types :: platform_version :: version :: fee :: data_contract_validation :: platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion as ferment :: FFIConversionTo < platform_version :: version :: fee :: data_contract_validation :: FeeDataContractValidationVersion >> :: ffi_to (obj . data_contract_validation) , data_contract_registration : < crate :: fermented :: types :: platform_version :: version :: fee :: data_contract_registration :: platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion as ferment :: FFIConversionTo < platform_version :: version :: fee :: data_contract_registration :: FeeDataContractRegistrationVersion >> :: ffi_to (obj . data_contract_registration) , state_transition_min_fees : < crate :: fermented :: types :: platform_version :: version :: fee :: state_transition_min_fees :: platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees as ferment :: FFIConversionTo < platform_version :: version :: fee :: state_transition_min_fees :: StateTransitionMinFees >> :: ffi_to (obj . state_transition_min_fees) , vote_resolution_fund_fees : < crate :: fermented :: types :: platform_version :: version :: fee :: vote_resolution_fund_fees :: platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees as ferment :: FFIConversionTo < platform_version :: version :: fee :: vote_resolution_fund_fees :: VoteResolutionFundFees >> :: ffi_to (obj . vote_resolution_fund_fees) }) } } impl Drop for platform_version_version_fee_FeeVersion { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . fee_version_number) ; ferment :: unbox_any_opt (ffi_ref . uses_version_fee_multiplier_permille) ; ferment :: unbox_any (ffi_ref . storage) ; ferment :: unbox_any (ffi_ref . signature) ; ferment :: unbox_any (ffi_ref . hashing) ; ferment :: unbox_any (ffi_ref . processing) ; ferment :: unbox_any (ffi_ref . data_contract_validation) ; ferment :: unbox_any (ffi_ref . data_contract_registration) ; ferment :: unbox_any (ffi_ref . state_transition_min_fees) ; ferment :: unbox_any (ffi_ref . vote_resolution_fund_fees) ; } } } } pub mod system_data_contract_versions { use crate as example_platform ; # [doc = "FFI-representation of the [`SystemDataContractVersions`]"] # [repr (C)] # [derive (Clone)] pub struct platform_version_version_system_data_contract_versions_SystemDataContractVersions { pub withdrawals : * mut platform_version :: version :: FeatureVersion , pub dpns : * mut platform_version :: version :: FeatureVersion , pub dashpay : * mut platform_version :: version :: FeatureVersion , pub masternode_reward_shares : * mut platform_version :: version :: FeatureVersion , pub feature_flags : * mut platform_version :: version :: FeatureVersion , pub wallet : * mut platform_version :: version :: FeatureVersion , pub token_history : * mut platform_version :: version :: FeatureVersion , pub keyword_search : * mut platform_version :: version :: FeatureVersion } impl ferment :: FFIConversionFrom < platform_version :: version :: system_data_contract_versions :: SystemDataContractVersions > for platform_version_version_system_data_contract_versions_SystemDataContractVersions { unsafe fn ffi_from_const (ffi : * const platform_version_version_system_data_contract_versions_SystemDataContractVersions) -> platform_version :: version :: system_data_contract_versions :: SystemDataContractVersions { let ffi_ref = & * ffi ; platform_version :: version :: system_data_contract_versions :: SystemDataContractVersions { withdrawals : std :: ptr :: read (ffi_ref . withdrawals) , dpns : std :: ptr :: read (ffi_ref . dpns) , dashpay : std :: ptr :: read (ffi_ref . dashpay) , masternode_reward_shares : std :: ptr :: read (ffi_ref . masternode_reward_shares) , feature_flags : std :: ptr :: read (ffi_ref . feature_flags) , wallet : std :: ptr :: read (ffi_ref . wallet) , token_history : std :: ptr :: read (ffi_ref . token_history) , keyword_search : std :: ptr :: read (ffi_ref . keyword_search) } } } impl ferment :: FFIConversionTo < platform_version :: version :: system_data_contract_versions :: SystemDataContractVersions > for platform_version_version_system_data_contract_versions_SystemDataContractVersions { unsafe fn ffi_to_const (obj : platform_version :: version :: system_data_contract_versions :: SystemDataContractVersions) -> * const platform_version_version_system_data_contract_versions_SystemDataContractVersions { ferment :: boxed (platform_version_version_system_data_contract_versions_SystemDataContractVersions { withdrawals : ferment :: boxed (obj . withdrawals) , dpns : ferment :: boxed (obj . dpns) , dashpay : ferment :: boxed (obj . dashpay) , masternode_reward_shares : ferment :: boxed (obj . masternode_reward_shares) , feature_flags : ferment :: boxed (obj . feature_flags) , wallet : ferment :: boxed (obj . wallet) , token_history : ferment :: boxed (obj . token_history) , keyword_search : ferment :: boxed (obj . keyword_search) }) } } impl Drop for platform_version_version_system_data_contract_versions_SystemDataContractVersions { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . withdrawals) ; ferment :: unbox_any (ffi_ref . dpns) ; ferment :: unbox_any (ffi_ref . dashpay) ; ferment :: unbox_any (ffi_ref . masternode_reward_shares) ; ferment :: unbox_any (ffi_ref . feature_flags) ; ferment :: unbox_any (ffi_ref . wallet) ; ferment :: unbox_any (ffi_ref . token_history) ; ferment :: unbox_any (ffi_ref . keyword_search) ; } } } } pub mod system_limits { use crate as example_platform ; # [doc = "FFI-representation of the [`SystemLimits`]"] # [repr (C)] # [derive (Clone)] pub struct platform_version_version_system_limits_SystemLimits { pub estimated_contract_max_serialized_size : u16 , pub max_field_value_size : u32 , pub max_state_transition_size : u64 , pub max_transitions_in_documents_batch : u16 , pub withdrawal_transactions_per_block_limit : u16 , pub retry_signing_expired_withdrawal_documents_per_block_limit : u16 , pub max_withdrawal_amount : u64 , pub max_contract_group_size : u16 , pub max_token_redemption_cycles : u32 } impl ferment :: FFIConversionFrom < platform_version :: version :: system_limits :: SystemLimits > for platform_version_version_system_limits_SystemLimits { unsafe fn ffi_from_const (ffi : * const platform_version_version_system_limits_SystemLimits) -> platform_version :: version :: system_limits :: SystemLimits { let ffi_ref = & * ffi ; platform_version :: version :: system_limits :: SystemLimits { estimated_contract_max_serialized_size : ffi_ref . estimated_contract_max_serialized_size , max_field_value_size : ffi_ref . max_field_value_size , max_state_transition_size : ffi_ref . max_state_transition_size , max_transitions_in_documents_batch : ffi_ref . max_transitions_in_documents_batch , withdrawal_transactions_per_block_limit : ffi_ref . withdrawal_transactions_per_block_limit , retry_signing_expired_withdrawal_documents_per_block_limit : ffi_ref . retry_signing_expired_withdrawal_documents_per_block_limit , max_withdrawal_amount : ffi_ref . max_withdrawal_amount , max_contract_group_size : ffi_ref . max_contract_group_size , max_token_redemption_cycles : ffi_ref . max_token_redemption_cycles } } } impl ferment :: FFIConversionTo < platform_version :: version :: system_limits :: SystemLimits > for platform_version_version_system_limits_SystemLimits { unsafe fn ffi_to_const (obj : platform_version :: version :: system_limits :: SystemLimits) -> * const platform_version_version_system_limits_SystemLimits { ferment :: boxed (platform_version_version_system_limits_SystemLimits { estimated_contract_max_serialized_size : obj . estimated_contract_max_serialized_size , max_field_value_size : obj . max_field_value_size , max_state_transition_size : obj . max_state_transition_size , max_transitions_in_documents_batch : obj . max_transitions_in_documents_batch , withdrawal_transactions_per_block_limit : obj . withdrawal_transactions_per_block_limit , retry_signing_expired_withdrawal_documents_per_block_limit : obj . retry_signing_expired_withdrawal_documents_per_block_limit , max_withdrawal_amount : obj . max_withdrawal_amount , max_contract_group_size : obj . max_contract_group_size , max_token_redemption_cycles : obj . max_token_redemption_cycles }) } } } } } pub mod platform_value { use crate as example_platform ; pub mod error { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`Error`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum platform_value_error_Error { Unsupported (* mut std :: os :: raw :: c_char) , StructureError (* mut std :: os :: raw :: c_char) , PathError (* mut std :: os :: raw :: c_char) , IntegerSizeError , IntegerParsingError , StringDecodingError (* mut std :: os :: raw :: c_char) , KeyMustBeAString , ByteLengthNot20BytesError (* mut std :: os :: raw :: c_char) , ByteLengthNot32BytesError (* mut std :: os :: raw :: c_char) , ByteLengthNot36BytesError (* mut std :: os :: raw :: c_char) , SerdeSerializationError (* mut std :: os :: raw :: c_char) , SerdeDeserializationError (* mut std :: os :: raw :: c_char) , CborSerializationError (* mut std :: os :: raw :: c_char) } impl ferment :: FFIConversionFrom < platform_value :: error :: Error > for platform_value_error_Error { unsafe fn ffi_from_const (ffi : * const platform_value_error_Error) -> platform_value :: error :: Error { let ffi_ref = & * ffi ; match ffi_ref { platform_value_error_Error :: Unsupported (o_0) => platform_value :: error :: Error :: Unsupported (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , platform_value_error_Error :: StructureError (o_0) => platform_value :: error :: Error :: StructureError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , platform_value_error_Error :: PathError (o_0) => platform_value :: error :: Error :: PathError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , platform_value_error_Error :: IntegerSizeError => platform_value :: error :: Error :: IntegerSizeError , platform_value_error_Error :: IntegerParsingError => platform_value :: error :: Error :: IntegerParsingError , platform_value_error_Error :: StringDecodingError (o_0) => platform_value :: error :: Error :: StringDecodingError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , platform_value_error_Error :: KeyMustBeAString => platform_value :: error :: Error :: KeyMustBeAString , platform_value_error_Error :: ByteLengthNot20BytesError (o_0) => platform_value :: error :: Error :: ByteLengthNot20BytesError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , platform_value_error_Error :: ByteLengthNot32BytesError (o_0) => platform_value :: error :: Error :: ByteLengthNot32BytesError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , platform_value_error_Error :: ByteLengthNot36BytesError (o_0) => platform_value :: error :: Error :: ByteLengthNot36BytesError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , platform_value_error_Error :: SerdeSerializationError (o_0) => platform_value :: error :: Error :: SerdeSerializationError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , platform_value_error_Error :: SerdeDeserializationError (o_0) => platform_value :: error :: Error :: SerdeDeserializationError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , platform_value_error_Error :: CborSerializationError (o_0) => platform_value :: error :: Error :: CborSerializationError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < platform_value :: error :: Error > for platform_value_error_Error { unsafe fn ffi_to_const (obj : platform_value :: error :: Error) -> * const platform_value_error_Error { ferment :: boxed (match obj { platform_value :: error :: Error :: Unsupported (o_0) => platform_value_error_Error :: Unsupported (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , platform_value :: error :: Error :: StructureError (o_0) => platform_value_error_Error :: StructureError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , platform_value :: error :: Error :: PathError (o_0) => platform_value_error_Error :: PathError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , platform_value :: error :: Error :: IntegerSizeError => platform_value_error_Error :: IntegerSizeError , platform_value :: error :: Error :: IntegerParsingError => platform_value_error_Error :: IntegerParsingError , platform_value :: error :: Error :: StringDecodingError (o_0) => platform_value_error_Error :: StringDecodingError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , platform_value :: error :: Error :: KeyMustBeAString => platform_value_error_Error :: KeyMustBeAString , platform_value :: error :: Error :: ByteLengthNot20BytesError (o_0) => platform_value_error_Error :: ByteLengthNot20BytesError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , platform_value :: error :: Error :: ByteLengthNot32BytesError (o_0) => platform_value_error_Error :: ByteLengthNot32BytesError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , platform_value :: error :: Error :: ByteLengthNot36BytesError (o_0) => platform_value_error_Error :: ByteLengthNot36BytesError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , platform_value :: error :: Error :: SerdeSerializationError (o_0) => platform_value_error_Error :: SerdeSerializationError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , platform_value :: error :: Error :: SerdeDeserializationError (o_0) => platform_value_error_Error :: SerdeDeserializationError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , platform_value :: error :: Error :: CborSerializationError (o_0) => platform_value_error_Error :: CborSerializationError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for platform_value_error_Error { fn drop (& mut self) { unsafe { match self { platform_value_error_Error :: Unsupported (o_0) => { ferment :: unbox_string (* o_0) ; } , platform_value_error_Error :: StructureError (o_0) => { ferment :: unbox_string (* o_0) ; } , platform_value_error_Error :: PathError (o_0) => { ferment :: unbox_string (* o_0) ; } , platform_value_error_Error :: IntegerSizeError => { } , platform_value_error_Error :: IntegerParsingError => { } , platform_value_error_Error :: StringDecodingError (o_0) => { ferment :: unbox_string (* o_0) ; } , platform_value_error_Error :: KeyMustBeAString => { } , platform_value_error_Error :: ByteLengthNot20BytesError (o_0) => { ferment :: unbox_string (* o_0) ; } , platform_value_error_Error :: ByteLengthNot32BytesError (o_0) => { ferment :: unbox_string (* o_0) ; } , platform_value_error_Error :: ByteLengthNot36BytesError (o_0) => { ferment :: unbox_string (* o_0) ; } , platform_value_error_Error :: SerdeSerializationError (o_0) => { ferment :: unbox_string (* o_0) ; } , platform_value_error_Error :: SerdeDeserializationError (o_0) => { ferment :: unbox_string (* o_0) ; } , platform_value_error_Error :: CborSerializationError (o_0) => { ferment :: unbox_string (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod types { pub mod binary_data { use crate as example_platform ; # [doc = "FFI-representation of the [`BinaryData`]"] # [repr (C)] # [derive (Clone)] pub struct platform_value_types_binary_data_BinaryData (* mut crate :: fermented :: generics :: Vec_u8) ; impl ferment :: FFIConversionFrom < platform_value :: types :: binary_data :: BinaryData > for platform_value_types_binary_data_BinaryData { unsafe fn ffi_from_const (ffi : * const platform_value_types_binary_data_BinaryData) -> platform_value :: types :: binary_data :: BinaryData { let ffi_ref = & * ffi ; platform_value :: types :: binary_data :: BinaryData (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . 0)) } } impl ferment :: FFIConversionTo < platform_value :: types :: binary_data :: BinaryData > for platform_value_types_binary_data_BinaryData { unsafe fn ffi_to_const (obj : platform_value :: types :: binary_data :: BinaryData) -> * const platform_value_types_binary_data_BinaryData { ferment :: boxed (platform_value_types_binary_data_BinaryData (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . 0))) } } impl Drop for platform_value_types_binary_data_BinaryData { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } } pub mod bytes_20 { use crate as example_platform ; # [doc = "FFI-representation of the [`Bytes20`]"] # [repr (C)] # [derive (Clone)] pub struct platform_value_types_bytes_20_Bytes20 (* mut crate :: fermented :: generics :: Arr_u8_20) ; impl ferment :: FFIConversionFrom < platform_value :: types :: bytes_20 :: Bytes20 > for platform_value_types_bytes_20_Bytes20 { unsafe fn ffi_from_const (ffi : * const platform_value_types_bytes_20_Bytes20) -> platform_value :: types :: bytes_20 :: Bytes20 { let ffi_ref = & * ffi ; platform_value :: types :: bytes_20 :: Bytes20 (< crate :: fermented :: generics :: Arr_u8_20 as ferment :: FFIConversionFrom < [u8 ; 20] >> :: ffi_from (ffi_ref . 0)) } } impl ferment :: FFIConversionTo < platform_value :: types :: bytes_20 :: Bytes20 > for platform_value_types_bytes_20_Bytes20 { unsafe fn ffi_to_const (obj : platform_value :: types :: bytes_20 :: Bytes20) -> * const platform_value_types_bytes_20_Bytes20 { ferment :: boxed (platform_value_types_bytes_20_Bytes20 (< crate :: fermented :: generics :: Arr_u8_20 as ferment :: FFIConversionTo < [u8 ; 20] >> :: ffi_to (obj . 0))) } } impl Drop for platform_value_types_bytes_20_Bytes20 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } } pub mod bytes_32 { use crate as example_platform ; # [doc = "FFI-representation of the [`Bytes32`]"] # [repr (C)] # [derive (Clone)] pub struct platform_value_types_bytes_32_Bytes32 (* mut crate :: fermented :: generics :: Arr_u8_32) ; impl ferment :: FFIConversionFrom < platform_value :: types :: bytes_32 :: Bytes32 > for platform_value_types_bytes_32_Bytes32 { unsafe fn ffi_from_const (ffi : * const platform_value_types_bytes_32_Bytes32) -> platform_value :: types :: bytes_32 :: Bytes32 { let ffi_ref = & * ffi ; platform_value :: types :: bytes_32 :: Bytes32 (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (ffi_ref . 0)) } } impl ferment :: FFIConversionTo < platform_value :: types :: bytes_32 :: Bytes32 > for platform_value_types_bytes_32_Bytes32 { unsafe fn ffi_to_const (obj : platform_value :: types :: bytes_32 :: Bytes32) -> * const platform_value_types_bytes_32_Bytes32 { ferment :: boxed (platform_value_types_bytes_32_Bytes32 (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (obj . 0))) } } impl Drop for platform_value_types_bytes_32_Bytes32 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } } pub mod identifier { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentifierBytes32`]"] # [repr (C)] # [derive (Clone)] pub struct platform_value_types_identifier_IdentifierBytes32 (* mut crate :: fermented :: generics :: Arr_u8_32) ; impl ferment :: FFIConversionFrom < platform_value :: types :: identifier :: IdentifierBytes32 > for platform_value_types_identifier_IdentifierBytes32 { unsafe fn ffi_from_const (ffi : * const platform_value_types_identifier_IdentifierBytes32) -> platform_value :: types :: identifier :: IdentifierBytes32 { let ffi_ref = & * ffi ; platform_value :: types :: identifier :: IdentifierBytes32 (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (ffi_ref . 0)) } } impl ferment :: FFIConversionTo < platform_value :: types :: identifier :: IdentifierBytes32 > for platform_value_types_identifier_IdentifierBytes32 { unsafe fn ffi_to_const (obj : platform_value :: types :: identifier :: IdentifierBytes32) -> * const platform_value_types_identifier_IdentifierBytes32 { ferment :: boxed (platform_value_types_identifier_IdentifierBytes32 (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (obj . 0))) } } impl Drop for platform_value_types_identifier_IdentifierBytes32 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [doc = "FFI-representation of the [`Identifier`]"] # [repr (C)] # [derive (Clone)] pub struct platform_value_types_identifier_Identifier (* mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_IdentifierBytes32) ; impl ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier > for platform_value_types_identifier_Identifier { unsafe fn ffi_from_const (ffi : * const platform_value_types_identifier_Identifier) -> platform_value :: types :: identifier :: Identifier { let ffi_ref = & * ffi ; platform_value :: types :: identifier :: Identifier (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_IdentifierBytes32 as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: IdentifierBytes32 >> :: ffi_from (ffi_ref . 0)) } } impl ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier > for platform_value_types_identifier_Identifier { unsafe fn ffi_to_const (obj : platform_value :: types :: identifier :: Identifier) -> * const platform_value_types_identifier_Identifier { ferment :: boxed (platform_value_types_identifier_Identifier (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_IdentifierBytes32 as ferment :: FFIConversionTo < platform_value :: types :: identifier :: IdentifierBytes32 >> :: ffi_to (obj . 0))) } } impl Drop for platform_value_types_identifier_Identifier { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } } } pub mod value_map { use crate as example_platform ; # [doc = "FFI-representation of the [`ValueMap`]"] # [repr (C)] # [derive (Clone)] pub struct platform_value_value_map_ValueMap (* mut crate :: fermented :: generics :: Vec_Tuple_platform_value_Value_platform_value_Value) ; impl ferment :: FFIConversionFrom < platform_value :: value_map :: ValueMap > for platform_value_value_map_ValueMap { unsafe fn ffi_from_const (ffi : * const platform_value_value_map_ValueMap) -> platform_value :: value_map :: ValueMap { let ffi_ref = & * ffi ; < crate :: fermented :: generics :: Vec_Tuple_platform_value_Value_platform_value_Value as ferment :: FFIConversionFrom < Vec < (platform_value :: Value , platform_value :: Value) > >> :: ffi_from (ffi_ref . 0) } } impl ferment :: FFIConversionTo < platform_value :: value_map :: ValueMap > for platform_value_value_map_ValueMap { unsafe fn ffi_to_const (obj : platform_value :: value_map :: ValueMap) -> * const platform_value_value_map_ValueMap { ferment :: boxed (platform_value_value_map_ValueMap (< crate :: fermented :: generics :: Vec_Tuple_platform_value_Value_platform_value_Value as ferment :: FFIConversionTo < Vec < (platform_value :: Value , platform_value :: Value) > >> :: ffi_to (obj))) } } impl Drop for platform_value_value_map_ValueMap { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } } # [doc = "FFI-representation of the [`Hash256`]"] # [repr (C)] # [derive (Clone)] pub struct platform_value_Hash256 (* mut crate :: fermented :: generics :: Arr_u8_32) ; impl ferment :: FFIConversionFrom < platform_value :: Hash256 > for platform_value_Hash256 { unsafe fn ffi_from_const (ffi : * const platform_value_Hash256) -> platform_value :: Hash256 { let ffi_ref = & * ffi ; < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (ffi_ref . 0) } } impl ferment :: FFIConversionTo < platform_value :: Hash256 > for platform_value_Hash256 { unsafe fn ffi_to_const (obj : platform_value :: Hash256) -> * const platform_value_Hash256 { ferment :: boxed (platform_value_Hash256 (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (obj))) } } impl Drop for platform_value_Hash256 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`Value`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum platform_value_Value { U128 (* mut [u8 ; 16]) , I128 (* mut [u8 ; 16]) , U64 (u64) , I64 (i64) , U32 (u32) , I32 (i32) , U16 (u16) , I16 (i16) , U8 (u8) , I8 (i8) , Bytes (* mut crate :: fermented :: generics :: Vec_u8) , Bytes20 (* mut crate :: fermented :: generics :: Arr_u8_20) , Bytes32 (* mut crate :: fermented :: generics :: Arr_u8_32) , Bytes36 (* mut crate :: fermented :: generics :: Arr_u8_36) , EnumU8 (* mut crate :: fermented :: generics :: Vec_u8) , EnumString (* mut crate :: fermented :: generics :: Vec_String) , Identifier (* mut crate :: fermented :: types :: platform_value :: platform_value_Hash256) , Float (f64) , Text (* mut std :: os :: raw :: c_char) , Bool (bool) , Null , Array (* mut crate :: fermented :: generics :: Vec_platform_value_Value) , Map (* mut crate :: fermented :: types :: platform_value :: value_map :: platform_value_value_map_ValueMap) } impl ferment :: FFIConversionFrom < platform_value :: Value > for platform_value_Value { unsafe fn ffi_from_const (ffi : * const platform_value_Value) -> platform_value :: Value { let ffi_ref = & * ffi ; match ffi_ref { platform_value_Value :: U128 (o_0) => platform_value :: Value :: U128 (< [u8 ; 16] as ferment :: FFIConversionFrom < u128 >> :: ffi_from (* o_0)) , platform_value_Value :: I128 (o_0) => platform_value :: Value :: I128 (< [u8 ; 16] as ferment :: FFIConversionFrom < i128 >> :: ffi_from (* o_0)) , platform_value_Value :: U64 (o_0) => platform_value :: Value :: U64 (* o_0) , platform_value_Value :: I64 (o_0) => platform_value :: Value :: I64 (* o_0) , platform_value_Value :: U32 (o_0) => platform_value :: Value :: U32 (* o_0) , platform_value_Value :: I32 (o_0) => platform_value :: Value :: I32 (* o_0) , platform_value_Value :: U16 (o_0) => platform_value :: Value :: U16 (* o_0) , platform_value_Value :: I16 (o_0) => platform_value :: Value :: I16 (* o_0) , platform_value_Value :: U8 (o_0) => platform_value :: Value :: U8 (* o_0) , platform_value_Value :: I8 (o_0) => platform_value :: Value :: I8 (* o_0) , platform_value_Value :: Bytes (o_0) => platform_value :: Value :: Bytes (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (* o_0)) , platform_value_Value :: Bytes20 (o_0) => platform_value :: Value :: Bytes20 (< crate :: fermented :: generics :: Arr_u8_20 as ferment :: FFIConversionFrom < [u8 ; 20] >> :: ffi_from (* o_0)) , platform_value_Value :: Bytes32 (o_0) => platform_value :: Value :: Bytes32 (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (* o_0)) , platform_value_Value :: Bytes36 (o_0) => platform_value :: Value :: Bytes36 (< crate :: fermented :: generics :: Arr_u8_36 as ferment :: FFIConversionFrom < [u8 ; 36] >> :: ffi_from (* o_0)) , platform_value_Value :: EnumU8 (o_0) => platform_value :: Value :: EnumU8 (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (* o_0)) , platform_value_Value :: EnumString (o_0) => platform_value :: Value :: EnumString (< crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionFrom < Vec < String > >> :: ffi_from (* o_0)) , platform_value_Value :: Identifier (o_0) => platform_value :: Value :: Identifier (< crate :: fermented :: types :: platform_value :: platform_value_Hash256 as ferment :: FFIConversionFrom < platform_value :: Hash256 >> :: ffi_from (* o_0)) , platform_value_Value :: Float (o_0) => platform_value :: Value :: Float (* o_0) , platform_value_Value :: Text (o_0) => platform_value :: Value :: Text (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , platform_value_Value :: Bool (o_0) => platform_value :: Value :: Bool (* o_0) , platform_value_Value :: Null => platform_value :: Value :: Null , platform_value_Value :: Array (o_0) => platform_value :: Value :: Array (< crate :: fermented :: generics :: Vec_platform_value_Value as ferment :: FFIConversionFrom < Vec < platform_value :: Value > >> :: ffi_from (* o_0)) , platform_value_Value :: Map (o_0) => platform_value :: Value :: Map (< crate :: fermented :: types :: platform_value :: value_map :: platform_value_value_map_ValueMap as ferment :: FFIConversionFrom < platform_value :: value_map :: ValueMap >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < platform_value :: Value > for platform_value_Value { unsafe fn ffi_to_const (obj : platform_value :: Value) -> * const platform_value_Value { ferment :: boxed (match obj { platform_value :: Value :: U128 (o_0) => platform_value_Value :: U128 (< [u8 ; 16] as ferment :: FFIConversionTo < u128 >> :: ffi_to (o_0)) , platform_value :: Value :: I128 (o_0) => platform_value_Value :: I128 (< [u8 ; 16] as ferment :: FFIConversionTo < i128 >> :: ffi_to (o_0)) , platform_value :: Value :: U64 (o_0) => platform_value_Value :: U64 (o_0) , platform_value :: Value :: I64 (o_0) => platform_value_Value :: I64 (o_0) , platform_value :: Value :: U32 (o_0) => platform_value_Value :: U32 (o_0) , platform_value :: Value :: I32 (o_0) => platform_value_Value :: I32 (o_0) , platform_value :: Value :: U16 (o_0) => platform_value_Value :: U16 (o_0) , platform_value :: Value :: I16 (o_0) => platform_value_Value :: I16 (o_0) , platform_value :: Value :: U8 (o_0) => platform_value_Value :: U8 (o_0) , platform_value :: Value :: I8 (o_0) => platform_value_Value :: I8 (o_0) , platform_value :: Value :: Bytes (o_0) => platform_value_Value :: Bytes (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (o_0)) , platform_value :: Value :: Bytes20 (o_0) => platform_value_Value :: Bytes20 (< crate :: fermented :: generics :: Arr_u8_20 as ferment :: FFIConversionTo < [u8 ; 20] >> :: ffi_to (o_0)) , platform_value :: Value :: Bytes32 (o_0) => platform_value_Value :: Bytes32 (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_0)) , platform_value :: Value :: Bytes36 (o_0) => platform_value_Value :: Bytes36 (< crate :: fermented :: generics :: Arr_u8_36 as ferment :: FFIConversionTo < [u8 ; 36] >> :: ffi_to (o_0)) , platform_value :: Value :: EnumU8 (o_0) => platform_value_Value :: EnumU8 (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (o_0)) , platform_value :: Value :: EnumString (o_0) => platform_value_Value :: EnumString (< crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionTo < Vec < String > >> :: ffi_to (o_0)) , platform_value :: Value :: Identifier (o_0) => platform_value_Value :: Identifier (< crate :: fermented :: types :: platform_value :: platform_value_Hash256 as ferment :: FFIConversionTo < platform_value :: Hash256 >> :: ffi_to (o_0)) , platform_value :: Value :: Float (o_0) => platform_value_Value :: Float (o_0) , platform_value :: Value :: Text (o_0) => platform_value_Value :: Text (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , platform_value :: Value :: Bool (o_0) => platform_value_Value :: Bool (o_0) , platform_value :: Value :: Null => platform_value_Value :: Null , platform_value :: Value :: Array (o_0) => platform_value_Value :: Array (< crate :: fermented :: generics :: Vec_platform_value_Value as ferment :: FFIConversionTo < Vec < platform_value :: Value > >> :: ffi_to (o_0)) , platform_value :: Value :: Map (o_0) => platform_value_Value :: Map (< crate :: fermented :: types :: platform_value :: value_map :: platform_value_value_map_ValueMap as ferment :: FFIConversionTo < platform_value :: value_map :: ValueMap >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for platform_value_Value { fn drop (& mut self) { unsafe { match self { platform_value_Value :: U128 (o_0) => { ferment :: unbox_any_opt (* o_0) ; } , platform_value_Value :: I128 (o_0) => { ferment :: unbox_any_opt (* o_0) ; } , platform_value_Value :: U64 (o_0) => { ; } , platform_value_Value :: I64 (o_0) => { ; } , platform_value_Value :: U32 (o_0) => { ; } , platform_value_Value :: I32 (o_0) => { ; } , platform_value_Value :: U16 (o_0) => { ; } , platform_value_Value :: I16 (o_0) => { ; } , platform_value_Value :: U8 (o_0) => { ; } , platform_value_Value :: I8 (o_0) => { ; } , platform_value_Value :: Bytes (o_0) => { ferment :: unbox_any (* o_0) ; } , platform_value_Value :: Bytes20 (o_0) => { ferment :: unbox_any (* o_0) ; } , platform_value_Value :: Bytes32 (o_0) => { ferment :: unbox_any (* o_0) ; } , platform_value_Value :: Bytes36 (o_0) => { ferment :: unbox_any (* o_0) ; } , platform_value_Value :: EnumU8 (o_0) => { ferment :: unbox_any (* o_0) ; } , platform_value_Value :: EnumString (o_0) => { ferment :: unbox_any (* o_0) ; } , platform_value_Value :: Identifier (o_0) => { ferment :: unbox_any (* o_0) ; } , platform_value_Value :: Float (o_0) => { ; } , platform_value_Value :: Text (o_0) => { ferment :: unbox_string (* o_0) ; } , platform_value_Value :: Bool (o_0) => { ; } , platform_value_Value :: Null => { } , platform_value_Value :: Array (o_0) => { ferment :: unbox_any (* o_0) ; } , platform_value_Value :: Map (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod dashcore { pub mod network { # [cfg (feature = "std")] pub mod message_qrinfo { use crate as example_platform ; # [doc = "FFI-representation of the [`QuorumSnapshot`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_network_message_qrinfo_QuorumSnapshot { pub skip_list_mode : * mut crate :: fermented :: types :: dashcore :: network :: message_qrinfo :: dashcore_network_message_qrinfo_MNSkipListMode , pub active_quorum_members : * mut crate :: fermented :: generics :: Vec_bool , pub skip_list : * mut crate :: fermented :: generics :: Vec_i32 } impl ferment :: FFIConversionFrom < dashcore :: network :: message_qrinfo :: QuorumSnapshot > for dashcore_network_message_qrinfo_QuorumSnapshot { unsafe fn ffi_from_const (ffi : * const dashcore_network_message_qrinfo_QuorumSnapshot) -> dashcore :: network :: message_qrinfo :: QuorumSnapshot { let ffi_ref = & * ffi ; dashcore :: network :: message_qrinfo :: QuorumSnapshot { skip_list_mode : < crate :: fermented :: types :: dashcore :: network :: message_qrinfo :: dashcore_network_message_qrinfo_MNSkipListMode as ferment :: FFIConversionFrom < dashcore :: network :: message_qrinfo :: MNSkipListMode >> :: ffi_from (ffi_ref . skip_list_mode) , active_quorum_members : < crate :: fermented :: generics :: Vec_bool as ferment :: FFIConversionFrom < Vec < bool > >> :: ffi_from (ffi_ref . active_quorum_members) , skip_list : < crate :: fermented :: generics :: Vec_i32 as ferment :: FFIConversionFrom < Vec < i32 > >> :: ffi_from (ffi_ref . skip_list) } } } impl ferment :: FFIConversionTo < dashcore :: network :: message_qrinfo :: QuorumSnapshot > for dashcore_network_message_qrinfo_QuorumSnapshot { unsafe fn ffi_to_const (obj : dashcore :: network :: message_qrinfo :: QuorumSnapshot) -> * const dashcore_network_message_qrinfo_QuorumSnapshot { ferment :: boxed (dashcore_network_message_qrinfo_QuorumSnapshot { skip_list_mode : < crate :: fermented :: types :: dashcore :: network :: message_qrinfo :: dashcore_network_message_qrinfo_MNSkipListMode as ferment :: FFIConversionTo < dashcore :: network :: message_qrinfo :: MNSkipListMode >> :: ffi_to (obj . skip_list_mode) , active_quorum_members : < crate :: fermented :: generics :: Vec_bool as ferment :: FFIConversionTo < Vec < bool > >> :: ffi_to (obj . active_quorum_members) , skip_list : < crate :: fermented :: generics :: Vec_i32 as ferment :: FFIConversionTo < Vec < i32 > >> :: ffi_to (obj . skip_list) }) } } impl Drop for dashcore_network_message_qrinfo_QuorumSnapshot { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . skip_list_mode) ; ferment :: unbox_any (ffi_ref . active_quorum_members) ; ferment :: unbox_any (ffi_ref . skip_list) ; } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`MNSkipListMode`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dashcore_network_message_qrinfo_MNSkipListMode { NoSkipping = 0 , SkipFirst = 1 , SkipExcept = 2 , SkipAll = 3 } impl ferment :: FFIConversionFrom < dashcore :: network :: message_qrinfo :: MNSkipListMode > for dashcore_network_message_qrinfo_MNSkipListMode { unsafe fn ffi_from_const (ffi : * const dashcore_network_message_qrinfo_MNSkipListMode) -> dashcore :: network :: message_qrinfo :: MNSkipListMode { let ffi_ref = & * ffi ; match ffi_ref { dashcore_network_message_qrinfo_MNSkipListMode :: NoSkipping => dashcore :: network :: message_qrinfo :: MNSkipListMode :: NoSkipping , dashcore_network_message_qrinfo_MNSkipListMode :: SkipFirst => dashcore :: network :: message_qrinfo :: MNSkipListMode :: SkipFirst , dashcore_network_message_qrinfo_MNSkipListMode :: SkipExcept => dashcore :: network :: message_qrinfo :: MNSkipListMode :: SkipExcept , dashcore_network_message_qrinfo_MNSkipListMode :: SkipAll => dashcore :: network :: message_qrinfo :: MNSkipListMode :: SkipAll } } } impl ferment :: FFIConversionTo < dashcore :: network :: message_qrinfo :: MNSkipListMode > for dashcore_network_message_qrinfo_MNSkipListMode { unsafe fn ffi_to_const (obj : dashcore :: network :: message_qrinfo :: MNSkipListMode) -> * const dashcore_network_message_qrinfo_MNSkipListMode { ferment :: boxed (match obj { dashcore :: network :: message_qrinfo :: MNSkipListMode :: NoSkipping => dashcore_network_message_qrinfo_MNSkipListMode :: NoSkipping , dashcore :: network :: message_qrinfo :: MNSkipListMode :: SkipFirst => dashcore_network_message_qrinfo_MNSkipListMode :: SkipFirst , dashcore :: network :: message_qrinfo :: MNSkipListMode :: SkipExcept => dashcore_network_message_qrinfo_MNSkipListMode :: SkipExcept , dashcore :: network :: message_qrinfo :: MNSkipListMode :: SkipAll => dashcore_network_message_qrinfo_MNSkipListMode :: SkipAll , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dashcore_network_message_qrinfo_MNSkipListMode { fn drop (& mut self) { unsafe { match self { dashcore_network_message_qrinfo_MNSkipListMode :: NoSkipping => { } , dashcore_network_message_qrinfo_MNSkipListMode :: SkipFirst => { } , dashcore_network_message_qrinfo_MNSkipListMode :: SkipExcept => { } , dashcore_network_message_qrinfo_MNSkipListMode :: SkipAll => { } , _ => unreachable ! ("This is unreachable") } ; } } } } } pub mod blockdata { pub mod script { pub mod owned { use crate as example_platform ; # [doc = "FFI-representation of the [`ScriptBuf`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_script_owned_ScriptBuf (* mut crate :: fermented :: generics :: Vec_u8) ; impl ferment :: FFIConversionFrom < dashcore :: blockdata :: script :: owned :: ScriptBuf > for dashcore_blockdata_script_owned_ScriptBuf { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_script_owned_ScriptBuf) -> dashcore :: blockdata :: script :: owned :: ScriptBuf { let ffi_ref = & * ffi ; dashcore :: blockdata :: script :: owned :: ScriptBuf (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . 0)) } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: script :: owned :: ScriptBuf > for dashcore_blockdata_script_owned_ScriptBuf { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: script :: owned :: ScriptBuf) -> * const dashcore_blockdata_script_owned_ScriptBuf { ferment :: boxed (dashcore_blockdata_script_owned_ScriptBuf (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . 0))) } } impl Drop for dashcore_blockdata_script_owned_ScriptBuf { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } } } pub mod transaction { use crate as example_platform ; pub mod outpoint { use crate as example_platform ; # [doc = "FFI-representation of the [`OutPoint`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_outpoint_OutPoint { pub txid : * mut dashcore :: hash_types :: Txid , pub vout : u32 } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: outpoint :: OutPoint > for dashcore_blockdata_transaction_outpoint_OutPoint { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_outpoint_OutPoint) -> dashcore :: blockdata :: transaction :: outpoint :: OutPoint { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: outpoint :: OutPoint { txid : std :: ptr :: read (ffi_ref . txid) , vout : ffi_ref . vout } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: outpoint :: OutPoint > for dashcore_blockdata_transaction_outpoint_OutPoint { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: outpoint :: OutPoint) -> * const dashcore_blockdata_transaction_outpoint_OutPoint { ferment :: boxed (dashcore_blockdata_transaction_outpoint_OutPoint { txid : ferment :: boxed (obj . txid) , vout : obj . vout }) } } impl Drop for dashcore_blockdata_transaction_outpoint_OutPoint { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . txid) ; ; } } } # [doc = "FFI-representation of the [`dashcore::blockdata::transaction::outpoint::OutPoint::new`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_outpoint_OutPoint_new (txid : * mut dashcore :: hash_types :: Txid , vout : u32) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint { let obj = dashcore :: blockdata :: transaction :: outpoint :: OutPoint :: new (std :: ptr :: read (txid) , vout) ; < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: outpoint :: OutPoint >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`dashcore::blockdata::transaction::outpoint::OutPoint::null`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_outpoint_OutPoint_null () -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint { let obj = dashcore :: blockdata :: transaction :: outpoint :: OutPoint :: null () ; < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: outpoint :: OutPoint >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`dashcore::blockdata::transaction::outpoint::OutPoint::is_null`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_outpoint_OutPoint_is_null (self_ : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint) -> bool { let obj = dashcore :: blockdata :: transaction :: outpoint :: OutPoint :: is_null (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: outpoint :: OutPoint >> :: ffi_from (self_)))) ; obj } } pub mod special_transaction { use crate as example_platform ; pub mod asset_lock { use crate as example_platform ; # [doc = "FFI-representation of the [`AssetLockPayload`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload { pub version : u8 , pub credit_outputs : * mut crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txout_TxOut } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: AssetLockPayload > for dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload) -> dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: AssetLockPayload { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: AssetLockPayload { version : ffi_ref . version , credit_outputs : < crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txout_TxOut as ferment :: FFIConversionFrom < Vec < dashcore :: blockdata :: transaction :: txout :: TxOut > >> :: ffi_from (ffi_ref . credit_outputs) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: AssetLockPayload > for dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: AssetLockPayload) -> * const dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload { version : obj . version , credit_outputs : < crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txout_TxOut as ferment :: FFIConversionTo < Vec < dashcore :: blockdata :: transaction :: txout :: TxOut > >> :: ffi_to (obj . credit_outputs) }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . credit_outputs) ; } } } # [doc = "FFI-representation of the [`dashcore::blockdata::transaction::special_transaction::asset_lock::AssetLockPayload::size`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload_size (self_ : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload) -> usize { let obj = dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: AssetLockPayload :: size (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: AssetLockPayload >> :: ffi_from (self_)))) ; obj } } pub mod asset_unlock { pub mod qualified_asset_unlock { use crate as example_platform ; # [doc = "FFI-representation of the [`AssetUnlockPayload`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload { pub base : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload , pub request_info : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo , pub quorum_sig : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: qualified_asset_unlock :: AssetUnlockPayload > for dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload) -> dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: qualified_asset_unlock :: AssetUnlockPayload { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: qualified_asset_unlock :: AssetUnlockPayload { base : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: AssetUnlockBasePayload >> :: ffi_from (ffi_ref . base) , request_info : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: AssetUnlockRequestInfo >> :: ffi_from (ffi_ref . request_info) , quorum_sig : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_from (ffi_ref . quorum_sig) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: qualified_asset_unlock :: AssetUnlockPayload > for dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: qualified_asset_unlock :: AssetUnlockPayload) -> * const dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload { base : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: AssetUnlockBasePayload >> :: ffi_to (obj . base) , request_info : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: AssetUnlockRequestInfo >> :: ffi_to (obj . request_info) , quorum_sig : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_to (obj . quorum_sig) }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . request_info) ; ferment :: unbox_any (ffi_ref . quorum_sig) ; } } } } pub mod request_info { use crate as example_platform ; # [doc = "FFI-representation of the [`AssetUnlockRequestInfo`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo { pub request_height : u32 , pub quorum_hash : * mut dashcore :: hash_types :: QuorumHash } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: AssetUnlockRequestInfo > for dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo) -> dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: AssetUnlockRequestInfo { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: AssetUnlockRequestInfo { request_height : ffi_ref . request_height , quorum_hash : std :: ptr :: read (ffi_ref . quorum_hash) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: AssetUnlockRequestInfo > for dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: AssetUnlockRequestInfo) -> * const dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo { request_height : obj . request_height , quorum_hash : ferment :: boxed (obj . quorum_hash) }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . quorum_hash) ; } } } } pub mod unqualified_asset_unlock { use crate as example_platform ; # [doc = "FFI-representation of the [`AssetUnlockBasePayload`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload { pub version : u8 , pub index : u64 , pub fee : u32 } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: AssetUnlockBasePayload > for dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload) -> dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: AssetUnlockBasePayload { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: AssetUnlockBasePayload { version : ffi_ref . version , index : ffi_ref . index , fee : ffi_ref . fee } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: AssetUnlockBasePayload > for dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: AssetUnlockBasePayload) -> * const dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload { version : obj . version , index : obj . index , fee : obj . fee }) } } } } pub mod coinbase { use crate as example_platform ; # [doc = "FFI-representation of the [`CoinbasePayload`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload { pub version : u16 , pub height : u32 , pub merkle_root_masternode_list : * mut dashcore :: hash_types :: MerkleRootMasternodeList , pub merkle_root_quorums : * mut dashcore :: hash_types :: MerkleRootQuorums , pub best_cl_height : * mut u32 , pub best_cl_signature : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature , pub asset_locked_amount : * mut u64 } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: CoinbasePayload > for dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload) -> dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: CoinbasePayload { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: CoinbasePayload { version : ffi_ref . version , height : ffi_ref . height , merkle_root_masternode_list : std :: ptr :: read (ffi_ref . merkle_root_masternode_list) , merkle_root_quorums : std :: ptr :: read (ffi_ref . merkle_root_quorums) , best_cl_height : ferment :: from_opt_primitive (ffi_ref . best_cl_height) , best_cl_signature : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_from_opt (ffi_ref . best_cl_signature) , asset_locked_amount : ferment :: from_opt_primitive (ffi_ref . asset_locked_amount) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: CoinbasePayload > for dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: CoinbasePayload) -> * const dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload { version : obj . version , height : obj . height , merkle_root_masternode_list : ferment :: boxed (obj . merkle_root_masternode_list) , merkle_root_quorums : ferment :: boxed (obj . merkle_root_quorums) , best_cl_height : ferment :: to_opt_primitive (obj . best_cl_height) , best_cl_signature : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_to_opt (obj . best_cl_signature) , asset_locked_amount : ferment :: to_opt_primitive (obj . asset_locked_amount) }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ferment :: unbox_any (ffi_ref . merkle_root_masternode_list) ; ferment :: unbox_any (ffi_ref . merkle_root_quorums) ; ferment :: unbox_any_opt (ffi_ref . best_cl_height) ; ferment :: unbox_any_opt (ffi_ref . best_cl_signature) ; ferment :: unbox_any_opt (ffi_ref . asset_locked_amount) ; } } } # [doc = "FFI-representation of the [`dashcore::blockdata::transaction::special_transaction::coinbase::CoinbasePayload::size`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_size (self_ : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload) -> usize { let obj = dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: CoinbasePayload :: size (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: CoinbasePayload >> :: ffi_from (self_)))) ; obj } } pub mod mnhf_signal { use crate as example_platform ; # [doc = "FFI-representation of the [`MnhfSignalPayload`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_mnhf_signal_MnhfSignalPayload { pub version : u8 , pub version_bit : u8 , pub quorum_hash : * mut dashcore :: hash_types :: QuorumHash , pub sig : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: mnhf_signal :: MnhfSignalPayload > for dashcore_blockdata_transaction_special_transaction_mnhf_signal_MnhfSignalPayload { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_mnhf_signal_MnhfSignalPayload) -> dashcore :: blockdata :: transaction :: special_transaction :: mnhf_signal :: MnhfSignalPayload { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: mnhf_signal :: MnhfSignalPayload { version : ffi_ref . version , version_bit : ffi_ref . version_bit , quorum_hash : std :: ptr :: read (ffi_ref . quorum_hash) , sig : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_from (ffi_ref . sig) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: mnhf_signal :: MnhfSignalPayload > for dashcore_blockdata_transaction_special_transaction_mnhf_signal_MnhfSignalPayload { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: mnhf_signal :: MnhfSignalPayload) -> * const dashcore_blockdata_transaction_special_transaction_mnhf_signal_MnhfSignalPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_mnhf_signal_MnhfSignalPayload { version : obj . version , version_bit : obj . version_bit , quorum_hash : ferment :: boxed (obj . quorum_hash) , sig : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_to (obj . sig) }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_mnhf_signal_MnhfSignalPayload { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ferment :: unbox_any (ffi_ref . quorum_hash) ; ferment :: unbox_any (ffi_ref . sig) ; } } } } pub mod provider_registration { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ProviderMasternodeType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType { Regular = 0 , HighPerformance = 1 } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderMasternodeType > for dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType) -> dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderMasternodeType { let ffi_ref = & * ffi ; match ffi_ref { dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType :: Regular => dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderMasternodeType :: Regular , dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType :: HighPerformance => dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderMasternodeType :: HighPerformance } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderMasternodeType > for dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderMasternodeType) -> * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType { ferment :: boxed (match obj { dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderMasternodeType :: Regular => dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType :: Regular , dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderMasternodeType :: HighPerformance => dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType :: HighPerformance , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType { fn drop (& mut self) { unsafe { match self { dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType :: Regular => { } , dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType :: HighPerformance => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [doc = "FFI-representation of the [`ProviderRegistrationPayload`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload { pub version : u16 , pub masternode_type : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType , pub masternode_mode : u16 , pub collateral_outpoint : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint , pub service_address : * mut std :: net :: SocketAddr , pub owner_key_hash : * mut dashcore :: hash_types :: PubkeyHash , pub operator_public_key : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey , pub voting_key_hash : * mut dashcore :: hash_types :: PubkeyHash , pub operator_reward : u16 , pub script_payout : * mut crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf , pub inputs_hash : * mut dashcore :: hash_types :: InputsHash , pub signature : * mut crate :: fermented :: generics :: Vec_u8 , pub platform_node_id : * mut dashcore :: hash_types :: PubkeyHash , pub platform_p2p_port : * mut u16 , pub platform_http_port : * mut u16 } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderRegistrationPayload > for dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderRegistrationPayload { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderRegistrationPayload { version : ffi_ref . version , masternode_type : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderMasternodeType >> :: ffi_from (ffi_ref . masternode_type) , masternode_mode : ffi_ref . masternode_mode , collateral_outpoint : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: outpoint :: OutPoint >> :: ffi_from (ffi_ref . collateral_outpoint) , service_address : std :: ptr :: read (ffi_ref . service_address) , owner_key_hash : std :: ptr :: read (ffi_ref . owner_key_hash) , operator_public_key : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSPublicKey >> :: ffi_from (ffi_ref . operator_public_key) , voting_key_hash : std :: ptr :: read (ffi_ref . voting_key_hash) , operator_reward : ffi_ref . operator_reward , script_payout : < crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf as ferment :: FFIConversionFrom < dashcore :: blockdata :: script :: owned :: ScriptBuf >> :: ffi_from (ffi_ref . script_payout) , inputs_hash : std :: ptr :: read (ffi_ref . inputs_hash) , signature : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . signature) , platform_node_id : ferment :: from_opt_opaque (ffi_ref . platform_node_id) , platform_p2p_port : ferment :: from_opt_primitive (ffi_ref . platform_p2p_port) , platform_http_port : ferment :: from_opt_primitive (ffi_ref . platform_http_port) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderRegistrationPayload > for dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderRegistrationPayload) -> * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload { version : obj . version , masternode_type : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderMasternodeType >> :: ffi_to (obj . masternode_type) , masternode_mode : obj . masternode_mode , collateral_outpoint : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: outpoint :: OutPoint >> :: ffi_to (obj . collateral_outpoint) , service_address : ferment :: boxed (obj . service_address) , owner_key_hash : ferment :: boxed (obj . owner_key_hash) , operator_public_key : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSPublicKey >> :: ffi_to (obj . operator_public_key) , voting_key_hash : ferment :: boxed (obj . voting_key_hash) , operator_reward : obj . operator_reward , script_payout : < crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf as ferment :: FFIConversionTo < dashcore :: blockdata :: script :: owned :: ScriptBuf >> :: ffi_to (obj . script_payout) , inputs_hash : ferment :: boxed (obj . inputs_hash) , signature : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . signature) , platform_node_id : ferment :: to_opt_primitive (obj . platform_node_id) , platform_p2p_port : ferment :: to_opt_primitive (obj . platform_p2p_port) , platform_http_port : ferment :: to_opt_primitive (obj . platform_http_port) }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . masternode_type) ; ; ferment :: unbox_any (ffi_ref . collateral_outpoint) ; ferment :: unbox_any (ffi_ref . service_address) ; ferment :: unbox_any (ffi_ref . owner_key_hash) ; ferment :: unbox_any (ffi_ref . operator_public_key) ; ferment :: unbox_any (ffi_ref . voting_key_hash) ; ; ferment :: unbox_any (ffi_ref . script_payout) ; ferment :: unbox_any (ffi_ref . inputs_hash) ; ferment :: unbox_any (ffi_ref . signature) ; ferment :: unbox_any_opt (ffi_ref . platform_node_id) ; ferment :: unbox_any_opt (ffi_ref . platform_p2p_port) ; ferment :: unbox_any_opt (ffi_ref . platform_http_port) ; } } } # [doc = "FFI-representation of the [`dashcore::blockdata::transaction::special_transaction::provider_registration::ProviderRegistrationPayload::size`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_size (self_ : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> usize { let obj = dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderRegistrationPayload :: size (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderRegistrationPayload >> :: ffi_from (self_)))) ; obj } } pub mod provider_update_registrar { use crate as example_platform ; # [doc = "FFI-representation of the [`ProviderUpdateRegistrarPayload`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload { pub version : u16 , pub pro_tx_hash : * mut dashcore :: hash_types :: Txid , pub provider_mode : u16 , pub operator_public_key : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey , pub voting_key_hash : * mut dashcore :: hash_types :: PubkeyHash , pub script_payout : * mut crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf , pub inputs_hash : * mut dashcore :: hash_types :: InputsHash , pub payload_sig : * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: ProviderUpdateRegistrarPayload > for dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) -> dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: ProviderUpdateRegistrarPayload { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: ProviderUpdateRegistrarPayload { version : ffi_ref . version , pro_tx_hash : std :: ptr :: read (ffi_ref . pro_tx_hash) , provider_mode : ffi_ref . provider_mode , operator_public_key : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSPublicKey >> :: ffi_from (ffi_ref . operator_public_key) , voting_key_hash : std :: ptr :: read (ffi_ref . voting_key_hash) , script_payout : < crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf as ferment :: FFIConversionFrom < dashcore :: blockdata :: script :: owned :: ScriptBuf >> :: ffi_from (ffi_ref . script_payout) , inputs_hash : std :: ptr :: read (ffi_ref . inputs_hash) , payload_sig : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . payload_sig) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: ProviderUpdateRegistrarPayload > for dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: ProviderUpdateRegistrarPayload) -> * const dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload { version : obj . version , pro_tx_hash : ferment :: boxed (obj . pro_tx_hash) , provider_mode : obj . provider_mode , operator_public_key : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSPublicKey >> :: ffi_to (obj . operator_public_key) , voting_key_hash : ferment :: boxed (obj . voting_key_hash) , script_payout : < crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf as ferment :: FFIConversionTo < dashcore :: blockdata :: script :: owned :: ScriptBuf >> :: ffi_to (obj . script_payout) , inputs_hash : ferment :: boxed (obj . inputs_hash) , payload_sig : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . payload_sig) }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . pro_tx_hash) ; ; ferment :: unbox_any (ffi_ref . operator_public_key) ; ferment :: unbox_any (ffi_ref . voting_key_hash) ; ferment :: unbox_any (ffi_ref . script_payout) ; ferment :: unbox_any (ffi_ref . inputs_hash) ; ferment :: unbox_any (ffi_ref . payload_sig) ; } } } # [doc = "FFI-representation of the [`dashcore::blockdata::transaction::special_transaction::provider_update_registrar::ProviderUpdateRegistrarPayload::size`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_size (self_ : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) -> usize { let obj = dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: ProviderUpdateRegistrarPayload :: size (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: ProviderUpdateRegistrarPayload >> :: ffi_from (self_)))) ; obj } } pub mod provider_update_revocation { use crate as example_platform ; # [doc = "FFI-representation of the [`ProviderUpdateRevocationPayload`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload { pub version : u16 , pub pro_tx_hash : * mut dashcore :: hash_types :: Txid , pub reason : u16 , pub inputs_hash : * mut dashcore :: hash_types :: InputsHash , pub payload_sig : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: ProviderUpdateRevocationPayload > for dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload) -> dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: ProviderUpdateRevocationPayload { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: ProviderUpdateRevocationPayload { version : ffi_ref . version , pro_tx_hash : std :: ptr :: read (ffi_ref . pro_tx_hash) , reason : ffi_ref . reason , inputs_hash : std :: ptr :: read (ffi_ref . inputs_hash) , payload_sig : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_from (ffi_ref . payload_sig) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: ProviderUpdateRevocationPayload > for dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: ProviderUpdateRevocationPayload) -> * const dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload { version : obj . version , pro_tx_hash : ferment :: boxed (obj . pro_tx_hash) , reason : obj . reason , inputs_hash : ferment :: boxed (obj . inputs_hash) , payload_sig : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_to (obj . payload_sig) }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . pro_tx_hash) ; ; ferment :: unbox_any (ffi_ref . inputs_hash) ; ferment :: unbox_any (ffi_ref . payload_sig) ; } } } # [doc = "FFI-representation of the [`dashcore::blockdata::transaction::special_transaction::provider_update_revocation::ProviderUpdateRevocationPayload::size`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload_size (self_ : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload) -> usize { let obj = dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: ProviderUpdateRevocationPayload :: size (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: ProviderUpdateRevocationPayload >> :: ffi_from (self_)))) ; obj } } pub mod provider_update_service { use crate as example_platform ; # [doc = "FFI-representation of the [`ProviderUpdateServicePayload`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload { pub version : u16 , pub mn_type : * mut u16 , pub pro_tx_hash : * mut dashcore :: hash_types :: Txid , pub ip_address : * mut [u8 ; 16] , pub port : u16 , pub script_payout : * mut crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf , pub inputs_hash : * mut dashcore :: hash_types :: InputsHash , pub platform_node_id : * mut crate :: fermented :: generics :: Arr_u8_20 , pub platform_p2p_port : * mut u16 , pub platform_http_port : * mut u16 , pub payload_sig : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: ProviderUpdateServicePayload > for dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) -> dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: ProviderUpdateServicePayload { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: ProviderUpdateServicePayload { version : ffi_ref . version , mn_type : ferment :: from_opt_primitive (ffi_ref . mn_type) , pro_tx_hash : std :: ptr :: read (ffi_ref . pro_tx_hash) , ip_address : < [u8 ; 16] as ferment :: FFIConversionFrom < u128 >> :: ffi_from (ffi_ref . ip_address) , port : ffi_ref . port , script_payout : < crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf as ferment :: FFIConversionFrom < dashcore :: blockdata :: script :: owned :: ScriptBuf >> :: ffi_from (ffi_ref . script_payout) , inputs_hash : std :: ptr :: read (ffi_ref . inputs_hash) , platform_node_id : < crate :: fermented :: generics :: Arr_u8_20 as ferment :: FFIConversionFrom < [u8 ; 20] >> :: ffi_from_opt (ffi_ref . platform_node_id) , platform_p2p_port : ferment :: from_opt_primitive (ffi_ref . platform_p2p_port) , platform_http_port : ferment :: from_opt_primitive (ffi_ref . platform_http_port) , payload_sig : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_from (ffi_ref . payload_sig) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: ProviderUpdateServicePayload > for dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: ProviderUpdateServicePayload) -> * const dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload { version : obj . version , mn_type : ferment :: to_opt_primitive (obj . mn_type) , pro_tx_hash : ferment :: boxed (obj . pro_tx_hash) , ip_address : < [u8 ; 16] as ferment :: FFIConversionTo < u128 >> :: ffi_to (obj . ip_address) , port : obj . port , script_payout : < crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf as ferment :: FFIConversionTo < dashcore :: blockdata :: script :: owned :: ScriptBuf >> :: ffi_to (obj . script_payout) , inputs_hash : ferment :: boxed (obj . inputs_hash) , platform_node_id : < crate :: fermented :: generics :: Arr_u8_20 as ferment :: FFIConversionTo < [u8 ; 20] >> :: ffi_to_opt (obj . platform_node_id) , platform_p2p_port : ferment :: to_opt_primitive (obj . platform_p2p_port) , platform_http_port : ferment :: to_opt_primitive (obj . platform_http_port) , payload_sig : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_to (obj . payload_sig) }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any_opt (ffi_ref . mn_type) ; ferment :: unbox_any (ffi_ref . pro_tx_hash) ; ferment :: unbox_any_opt (ffi_ref . ip_address) ; ; ferment :: unbox_any (ffi_ref . script_payout) ; ferment :: unbox_any (ffi_ref . inputs_hash) ; ferment :: unbox_any_opt (ffi_ref . platform_node_id) ; ferment :: unbox_any_opt (ffi_ref . platform_p2p_port) ; ferment :: unbox_any_opt (ffi_ref . platform_http_port) ; ferment :: unbox_any (ffi_ref . payload_sig) ; } } } # [doc = "FFI-representation of the [`dashcore::blockdata::transaction::special_transaction::provider_update_service::ProviderUpdateServicePayload::size`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_size (self_ : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) -> usize { let obj = dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: ProviderUpdateServicePayload :: size (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: ProviderUpdateServicePayload >> :: ffi_from (self_)))) ; obj } } pub mod quorum_commitment { use crate as example_platform ; # [doc = "FFI-representation of the [`QuorumEntry`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry { pub version : u16 , pub llmq_type : * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType , pub quorum_hash : * mut dashcore :: hash_types :: QuorumHash , pub quorum_index : * mut i16 , pub signers : * mut crate :: fermented :: generics :: Vec_bool , pub valid_members : * mut crate :: fermented :: generics :: Vec_bool , pub quorum_public_key : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey , pub quorum_vvec_hash : * mut dashcore :: hash_types :: QuorumVVecHash , pub threshold_sig : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature , pub all_commitment_aggregated_signature : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry > for dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry { version : ffi_ref . version , llmq_type : < crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionFrom < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_from (ffi_ref . llmq_type) , quorum_hash : std :: ptr :: read (ffi_ref . quorum_hash) , quorum_index : ferment :: from_opt_primitive (ffi_ref . quorum_index) , signers : < crate :: fermented :: generics :: Vec_bool as ferment :: FFIConversionFrom < Vec < bool > >> :: ffi_from (ffi_ref . signers) , valid_members : < crate :: fermented :: generics :: Vec_bool as ferment :: FFIConversionFrom < Vec < bool > >> :: ffi_from (ffi_ref . valid_members) , quorum_public_key : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSPublicKey >> :: ffi_from (ffi_ref . quorum_public_key) , quorum_vvec_hash : std :: ptr :: read (ffi_ref . quorum_vvec_hash) , threshold_sig : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_from (ffi_ref . threshold_sig) , all_commitment_aggregated_signature : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_from (ffi_ref . all_commitment_aggregated_signature) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry > for dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry) -> * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry { version : obj . version , llmq_type : < crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionTo < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_to (obj . llmq_type) , quorum_hash : ferment :: boxed (obj . quorum_hash) , quorum_index : ferment :: to_opt_primitive (obj . quorum_index) , signers : < crate :: fermented :: generics :: Vec_bool as ferment :: FFIConversionTo < Vec < bool > >> :: ffi_to (obj . signers) , valid_members : < crate :: fermented :: generics :: Vec_bool as ferment :: FFIConversionTo < Vec < bool > >> :: ffi_to (obj . valid_members) , quorum_public_key : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSPublicKey >> :: ffi_to (obj . quorum_public_key) , quorum_vvec_hash : ferment :: boxed (obj . quorum_vvec_hash) , threshold_sig : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_to (obj . threshold_sig) , all_commitment_aggregated_signature : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_to (obj . all_commitment_aggregated_signature) }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . llmq_type) ; ferment :: unbox_any (ffi_ref . quorum_hash) ; ferment :: unbox_any_opt (ffi_ref . quorum_index) ; ferment :: unbox_any (ffi_ref . signers) ; ferment :: unbox_any (ffi_ref . valid_members) ; ferment :: unbox_any (ffi_ref . quorum_public_key) ; ferment :: unbox_any (ffi_ref . quorum_vvec_hash) ; ferment :: unbox_any (ffi_ref . threshold_sig) ; ferment :: unbox_any (ffi_ref . all_commitment_aggregated_signature) ; } } } # [doc = "FFI-representation of the [`dashcore::blockdata::transaction::special_transaction::quorum_commitment::QuorumEntry::size`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_size (self_ : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> usize { let obj = dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry :: size (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry >> :: ffi_from (self_)))) ; obj } # [doc = "FFI-representation of the [`QuorumCommitmentPayload`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload { pub version : u16 , pub height : u32 , pub finalization_commitment : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumCommitmentPayload > for dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload) -> dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumCommitmentPayload { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumCommitmentPayload { version : ffi_ref . version , height : ffi_ref . height , finalization_commitment : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry >> :: ffi_from (ffi_ref . finalization_commitment) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumCommitmentPayload > for dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumCommitmentPayload) -> * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload { version : obj . version , height : obj . height , finalization_commitment : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry >> :: ffi_to (obj . finalization_commitment) }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ferment :: unbox_any (ffi_ref . finalization_commitment) ; } } } # [doc = "FFI-representation of the [`dashcore::blockdata::transaction::special_transaction::quorum_commitment::QuorumCommitmentPayload::size`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload_size (self_ : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload) -> usize { let obj = dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumCommitmentPayload :: size (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumCommitmentPayload >> :: ffi_from (self_)))) ; obj } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TransactionPayload`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dashcore_blockdata_transaction_special_transaction_TransactionPayload { ProviderRegistrationPayloadType (* mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) , ProviderUpdateServicePayloadType (* mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) , ProviderUpdateRegistrarPayloadType (* mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) , ProviderUpdateRevocationPayloadType (* mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload) , CoinbasePayloadType (* mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload) , QuorumCommitmentPayloadType (* mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload) , MnhfSignalPayloadType (* mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: mnhf_signal :: dashcore_blockdata_transaction_special_transaction_mnhf_signal_MnhfSignalPayload) , AssetLockPayloadType (* mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload) , AssetUnlockPayloadType (* mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: qualified_asset_unlock :: dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload) } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload > for dashcore_blockdata_transaction_special_transaction_TransactionPayload { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_TransactionPayload) -> dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload { let ffi_ref = & * ffi ; match ffi_ref { dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderRegistrationPayloadType (o_0) => dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: ProviderRegistrationPayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderRegistrationPayload >> :: ffi_from (* o_0)) , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateServicePayloadType (o_0) => dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: ProviderUpdateServicePayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: ProviderUpdateServicePayload >> :: ffi_from (* o_0)) , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateRegistrarPayloadType (o_0) => dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: ProviderUpdateRegistrarPayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: ProviderUpdateRegistrarPayload >> :: ffi_from (* o_0)) , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateRevocationPayloadType (o_0) => dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: ProviderUpdateRevocationPayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: ProviderUpdateRevocationPayload >> :: ffi_from (* o_0)) , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: CoinbasePayloadType (o_0) => dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: CoinbasePayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: CoinbasePayload >> :: ffi_from (* o_0)) , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: QuorumCommitmentPayloadType (o_0) => dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: QuorumCommitmentPayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumCommitmentPayload >> :: ffi_from (* o_0)) , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: MnhfSignalPayloadType (o_0) => dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: MnhfSignalPayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: mnhf_signal :: dashcore_blockdata_transaction_special_transaction_mnhf_signal_MnhfSignalPayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: mnhf_signal :: MnhfSignalPayload >> :: ffi_from (* o_0)) , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: AssetLockPayloadType (o_0) => dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: AssetLockPayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: AssetLockPayload >> :: ffi_from (* o_0)) , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: AssetUnlockPayloadType (o_0) => dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: AssetUnlockPayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: qualified_asset_unlock :: dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: qualified_asset_unlock :: AssetUnlockPayload >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload > for dashcore_blockdata_transaction_special_transaction_TransactionPayload { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload) -> * const dashcore_blockdata_transaction_special_transaction_TransactionPayload { ferment :: boxed (match obj { dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: ProviderRegistrationPayloadType (o_0) => dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderRegistrationPayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderRegistrationPayload >> :: ffi_to (o_0)) , dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: ProviderUpdateServicePayloadType (o_0) => dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateServicePayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: ProviderUpdateServicePayload >> :: ffi_to (o_0)) , dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: ProviderUpdateRegistrarPayloadType (o_0) => dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateRegistrarPayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: ProviderUpdateRegistrarPayload >> :: ffi_to (o_0)) , dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: ProviderUpdateRevocationPayloadType (o_0) => dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateRevocationPayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: ProviderUpdateRevocationPayload >> :: ffi_to (o_0)) , dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: CoinbasePayloadType (o_0) => dashcore_blockdata_transaction_special_transaction_TransactionPayload :: CoinbasePayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: CoinbasePayload >> :: ffi_to (o_0)) , dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: QuorumCommitmentPayloadType (o_0) => dashcore_blockdata_transaction_special_transaction_TransactionPayload :: QuorumCommitmentPayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumCommitmentPayload >> :: ffi_to (o_0)) , dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: MnhfSignalPayloadType (o_0) => dashcore_blockdata_transaction_special_transaction_TransactionPayload :: MnhfSignalPayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: mnhf_signal :: dashcore_blockdata_transaction_special_transaction_mnhf_signal_MnhfSignalPayload as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: mnhf_signal :: MnhfSignalPayload >> :: ffi_to (o_0)) , dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: AssetLockPayloadType (o_0) => dashcore_blockdata_transaction_special_transaction_TransactionPayload :: AssetLockPayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: AssetLockPayload >> :: ffi_to (o_0)) , dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: AssetUnlockPayloadType (o_0) => dashcore_blockdata_transaction_special_transaction_TransactionPayload :: AssetUnlockPayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: qualified_asset_unlock :: dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: qualified_asset_unlock :: AssetUnlockPayload >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_TransactionPayload { fn drop (& mut self) { unsafe { match self { dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderRegistrationPayloadType (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateServicePayloadType (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateRegistrarPayloadType (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateRevocationPayloadType (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: CoinbasePayloadType (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: QuorumCommitmentPayloadType (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: MnhfSignalPayloadType (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: AssetLockPayloadType (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: AssetUnlockPayloadType (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [doc = "FFI-representation of the [`dashcore::blockdata::transaction::special_transaction::TransactionPayload::get_type`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionPayload_get_type (self_ : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: dashcore_blockdata_transaction_special_transaction_TransactionPayload) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: dashcore_blockdata_transaction_special_transaction_TransactionType { let obj = dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: get_type (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: dashcore_blockdata_transaction_special_transaction_TransactionPayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload >> :: ffi_from (self_)))) ; < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: dashcore_blockdata_transaction_special_transaction_TransactionType as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: TransactionType >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`dashcore::blockdata::transaction::special_transaction::TransactionPayload::len`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionPayload_len (self_ : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: dashcore_blockdata_transaction_special_transaction_TransactionPayload) -> usize { let obj = dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: len (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: dashcore_blockdata_transaction_special_transaction_TransactionPayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload >> :: ffi_from (self_)))) ; obj } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TransactionType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dashcore_blockdata_transaction_special_transaction_TransactionType { Classic = 0 , ProviderRegistration = 1 , ProviderUpdateService = 2 , ProviderUpdateRegistrar = 3 , ProviderUpdateRevocation = 4 , Coinbase = 5 , QuorumCommitment = 6 , MnhfSignal = 7 , AssetLock = 8 , AssetUnlock = 9 } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: TransactionType > for dashcore_blockdata_transaction_special_transaction_TransactionType { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_TransactionType) -> dashcore :: blockdata :: transaction :: special_transaction :: TransactionType { let ffi_ref = & * ffi ; match ffi_ref { dashcore_blockdata_transaction_special_transaction_TransactionType :: Classic => dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: Classic , dashcore_blockdata_transaction_special_transaction_TransactionType :: ProviderRegistration => dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: ProviderRegistration , dashcore_blockdata_transaction_special_transaction_TransactionType :: ProviderUpdateService => dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: ProviderUpdateService , dashcore_blockdata_transaction_special_transaction_TransactionType :: ProviderUpdateRegistrar => dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: ProviderUpdateRegistrar , dashcore_blockdata_transaction_special_transaction_TransactionType :: ProviderUpdateRevocation => dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: ProviderUpdateRevocation , dashcore_blockdata_transaction_special_transaction_TransactionType :: Coinbase => dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: Coinbase , dashcore_blockdata_transaction_special_transaction_TransactionType :: QuorumCommitment => dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: QuorumCommitment , dashcore_blockdata_transaction_special_transaction_TransactionType :: MnhfSignal => dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: MnhfSignal , dashcore_blockdata_transaction_special_transaction_TransactionType :: AssetLock => dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: AssetLock , dashcore_blockdata_transaction_special_transaction_TransactionType :: AssetUnlock => dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: AssetUnlock } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: TransactionType > for dashcore_blockdata_transaction_special_transaction_TransactionType { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: TransactionType) -> * const dashcore_blockdata_transaction_special_transaction_TransactionType { ferment :: boxed (match obj { dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: Classic => dashcore_blockdata_transaction_special_transaction_TransactionType :: Classic , dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: ProviderRegistration => dashcore_blockdata_transaction_special_transaction_TransactionType :: ProviderRegistration , dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: ProviderUpdateService => dashcore_blockdata_transaction_special_transaction_TransactionType :: ProviderUpdateService , dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: ProviderUpdateRegistrar => dashcore_blockdata_transaction_special_transaction_TransactionType :: ProviderUpdateRegistrar , dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: ProviderUpdateRevocation => dashcore_blockdata_transaction_special_transaction_TransactionType :: ProviderUpdateRevocation , dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: Coinbase => dashcore_blockdata_transaction_special_transaction_TransactionType :: Coinbase , dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: QuorumCommitment => dashcore_blockdata_transaction_special_transaction_TransactionType :: QuorumCommitment , dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: MnhfSignal => dashcore_blockdata_transaction_special_transaction_TransactionType :: MnhfSignal , dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: AssetLock => dashcore_blockdata_transaction_special_transaction_TransactionType :: AssetLock , dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: AssetUnlock => dashcore_blockdata_transaction_special_transaction_TransactionType :: AssetUnlock , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_TransactionType { fn drop (& mut self) { unsafe { match self { dashcore_blockdata_transaction_special_transaction_TransactionType :: Classic => { } , dashcore_blockdata_transaction_special_transaction_TransactionType :: ProviderRegistration => { } , dashcore_blockdata_transaction_special_transaction_TransactionType :: ProviderUpdateService => { } , dashcore_blockdata_transaction_special_transaction_TransactionType :: ProviderUpdateRegistrar => { } , dashcore_blockdata_transaction_special_transaction_TransactionType :: ProviderUpdateRevocation => { } , dashcore_blockdata_transaction_special_transaction_TransactionType :: Coinbase => { } , dashcore_blockdata_transaction_special_transaction_TransactionType :: QuorumCommitment => { } , dashcore_blockdata_transaction_special_transaction_TransactionType :: MnhfSignal => { } , dashcore_blockdata_transaction_special_transaction_TransactionType :: AssetLock => { } , dashcore_blockdata_transaction_special_transaction_TransactionType :: AssetUnlock => { } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod txin { use crate as example_platform ; # [doc = "FFI-representation of the [`TxIn`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_txin_TxIn { pub previous_output : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint , pub script_sig : * mut crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf , pub sequence : u32 , pub witness : * mut crate :: fermented :: types :: dashcore :: blockdata :: witness :: dashcore_blockdata_witness_Witness } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: txin :: TxIn > for dashcore_blockdata_transaction_txin_TxIn { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_txin_TxIn) -> dashcore :: blockdata :: transaction :: txin :: TxIn { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: txin :: TxIn { previous_output : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: outpoint :: OutPoint >> :: ffi_from (ffi_ref . previous_output) , script_sig : < crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf as ferment :: FFIConversionFrom < dashcore :: blockdata :: script :: owned :: ScriptBuf >> :: ffi_from (ffi_ref . script_sig) , sequence : ffi_ref . sequence , witness : < crate :: fermented :: types :: dashcore :: blockdata :: witness :: dashcore_blockdata_witness_Witness as ferment :: FFIConversionFrom < dashcore :: blockdata :: witness :: Witness >> :: ffi_from (ffi_ref . witness) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: txin :: TxIn > for dashcore_blockdata_transaction_txin_TxIn { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: txin :: TxIn) -> * const dashcore_blockdata_transaction_txin_TxIn { ferment :: boxed (dashcore_blockdata_transaction_txin_TxIn { previous_output : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: outpoint :: OutPoint >> :: ffi_to (obj . previous_output) , script_sig : < crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf as ferment :: FFIConversionTo < dashcore :: blockdata :: script :: owned :: ScriptBuf >> :: ffi_to (obj . script_sig) , sequence : obj . sequence , witness : < crate :: fermented :: types :: dashcore :: blockdata :: witness :: dashcore_blockdata_witness_Witness as ferment :: FFIConversionTo < dashcore :: blockdata :: witness :: Witness >> :: ffi_to (obj . witness) }) } } impl Drop for dashcore_blockdata_transaction_txin_TxIn { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . previous_output) ; ferment :: unbox_any (ffi_ref . script_sig) ; ; ferment :: unbox_any (ffi_ref . witness) ; } } } } pub mod txout { use crate as example_platform ; # [doc = "FFI-representation of the [`TxOut`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_txout_TxOut { pub value : u64 , pub script_pubkey : * mut crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: txout :: TxOut > for dashcore_blockdata_transaction_txout_TxOut { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_txout_TxOut) -> dashcore :: blockdata :: transaction :: txout :: TxOut { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: txout :: TxOut { value : ffi_ref . value , script_pubkey : < crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf as ferment :: FFIConversionFrom < dashcore :: blockdata :: script :: owned :: ScriptBuf >> :: ffi_from (ffi_ref . script_pubkey) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: txout :: TxOut > for dashcore_blockdata_transaction_txout_TxOut { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: txout :: TxOut) -> * const dashcore_blockdata_transaction_txout_TxOut { ferment :: boxed (dashcore_blockdata_transaction_txout_TxOut { value : obj . value , script_pubkey : < crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf as ferment :: FFIConversionTo < dashcore :: blockdata :: script :: owned :: ScriptBuf >> :: ffi_to (obj . script_pubkey) }) } } impl Drop for dashcore_blockdata_transaction_txout_TxOut { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . script_pubkey) ; } } } } # [doc = "FFI-representation of the [`Transaction`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_Transaction { pub version : u16 , pub lock_time : u32 , pub input : * mut crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txin_TxIn , pub output : * mut crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txout_TxOut , pub special_transaction_payload : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: dashcore_blockdata_transaction_special_transaction_TransactionPayload } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: Transaction > for dashcore_blockdata_transaction_Transaction { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_Transaction) -> dashcore :: blockdata :: transaction :: Transaction { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: Transaction { version : ffi_ref . version , lock_time : ffi_ref . lock_time , input : < crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txin_TxIn as ferment :: FFIConversionFrom < Vec < dashcore :: blockdata :: transaction :: txin :: TxIn > >> :: ffi_from (ffi_ref . input) , output : < crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txout_TxOut as ferment :: FFIConversionFrom < Vec < dashcore :: blockdata :: transaction :: txout :: TxOut > >> :: ffi_from (ffi_ref . output) , special_transaction_payload : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: dashcore_blockdata_transaction_special_transaction_TransactionPayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload >> :: ffi_from_opt (ffi_ref . special_transaction_payload) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: Transaction > for dashcore_blockdata_transaction_Transaction { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: Transaction) -> * const dashcore_blockdata_transaction_Transaction { ferment :: boxed (dashcore_blockdata_transaction_Transaction { version : obj . version , lock_time : obj . lock_time , input : < crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txin_TxIn as ferment :: FFIConversionTo < Vec < dashcore :: blockdata :: transaction :: txin :: TxIn > >> :: ffi_to (obj . input) , output : < crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txout_TxOut as ferment :: FFIConversionTo < Vec < dashcore :: blockdata :: transaction :: txout :: TxOut > >> :: ffi_to (obj . output) , special_transaction_payload : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: dashcore_blockdata_transaction_special_transaction_TransactionPayload as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload >> :: ffi_to_opt (obj . special_transaction_payload) }) } } impl Drop for dashcore_blockdata_transaction_Transaction { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ferment :: unbox_any (ffi_ref . input) ; ferment :: unbox_any (ffi_ref . output) ; ferment :: unbox_any_opt (ffi_ref . special_transaction_payload) ; } } } # [doc = "FFI-representation of the [`dashcore::blockdata::transaction::Transaction::txid`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_Transaction_txid (self_ : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: dashcore_blockdata_transaction_Transaction) -> * mut dashcore :: hash_types :: Txid { let obj = dashcore :: blockdata :: transaction :: Transaction :: txid (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: dashcore_blockdata_transaction_Transaction as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: Transaction >> :: ffi_from (self_)))) ; ferment :: boxed (obj) } # [doc = "FFI-representation of the [`dashcore::blockdata::transaction::Transaction::tx_type`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_Transaction_tx_type (self_ : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: dashcore_blockdata_transaction_Transaction) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: dashcore_blockdata_transaction_special_transaction_TransactionType { let obj = dashcore :: blockdata :: transaction :: Transaction :: tx_type (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: dashcore_blockdata_transaction_Transaction as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: Transaction >> :: ffi_from (self_)))) ; < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: dashcore_blockdata_transaction_special_transaction_TransactionType as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: TransactionType >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`dashcore::blockdata::transaction::Transaction::is_coin_base`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_Transaction_is_coin_base (self_ : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: dashcore_blockdata_transaction_Transaction) -> bool { let obj = dashcore :: blockdata :: transaction :: Transaction :: is_coin_base (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: dashcore_blockdata_transaction_Transaction as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: Transaction >> :: ffi_from (self_)))) ; obj } } pub mod witness { use crate as example_platform ; # [doc = "FFI-representation of the [`Witness`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_witness_Witness { pub content : * mut crate :: fermented :: generics :: Vec_u8 , pub witness_elements : usize , pub indices_start : usize } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: witness :: Witness > for dashcore_blockdata_witness_Witness { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_witness_Witness) -> dashcore :: blockdata :: witness :: Witness { let ffi_ref = & * ffi ; dashcore :: blockdata :: witness :: Witness { content : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . content) , witness_elements : ffi_ref . witness_elements , indices_start : ffi_ref . indices_start } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: witness :: Witness > for dashcore_blockdata_witness_Witness { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: witness :: Witness) -> * const dashcore_blockdata_witness_Witness { ferment :: boxed (dashcore_blockdata_witness_Witness { content : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . content) , witness_elements : obj . witness_elements , indices_start : obj . indices_start }) } } impl Drop for dashcore_blockdata_witness_Witness { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . content) ; ; ; } } } } } pub mod bls_sig_utils { use crate as example_platform ; # [doc = "FFI-representation of the [`BLSPublicKey`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_bls_sig_utils_BLSPublicKey (* mut crate :: fermented :: generics :: Arr_u8_48) ; impl ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSPublicKey > for dashcore_bls_sig_utils_BLSPublicKey { unsafe fn ffi_from_const (ffi : * const dashcore_bls_sig_utils_BLSPublicKey) -> dashcore :: bls_sig_utils :: BLSPublicKey { let ffi_ref = & * ffi ; dashcore :: bls_sig_utils :: BLSPublicKey (< crate :: fermented :: generics :: Arr_u8_48 as ferment :: FFIConversionFrom < [u8 ; 48] >> :: ffi_from (ffi_ref . 0)) } } impl ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSPublicKey > for dashcore_bls_sig_utils_BLSPublicKey { unsafe fn ffi_to_const (obj : dashcore :: bls_sig_utils :: BLSPublicKey) -> * const dashcore_bls_sig_utils_BLSPublicKey { ferment :: boxed (dashcore_bls_sig_utils_BLSPublicKey (< crate :: fermented :: generics :: Arr_u8_48 as ferment :: FFIConversionTo < [u8 ; 48] >> :: ffi_to (obj . 0))) } } impl Drop for dashcore_bls_sig_utils_BLSPublicKey { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [doc = "FFI-representation of the [`BLSSignature`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_bls_sig_utils_BLSSignature (* mut crate :: fermented :: generics :: Arr_u8_96) ; impl ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature > for dashcore_bls_sig_utils_BLSSignature { unsafe fn ffi_from_const (ffi : * const dashcore_bls_sig_utils_BLSSignature) -> dashcore :: bls_sig_utils :: BLSSignature { let ffi_ref = & * ffi ; dashcore :: bls_sig_utils :: BLSSignature (< crate :: fermented :: generics :: Arr_u8_96 as ferment :: FFIConversionFrom < [u8 ; 96] >> :: ffi_from (ffi_ref . 0)) } } impl ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature > for dashcore_bls_sig_utils_BLSSignature { unsafe fn ffi_to_const (obj : dashcore :: bls_sig_utils :: BLSSignature) -> * const dashcore_bls_sig_utils_BLSSignature { ferment :: boxed (dashcore_bls_sig_utils_BLSSignature (< crate :: fermented :: generics :: Arr_u8_96 as ferment :: FFIConversionTo < [u8 ; 96] >> :: ffi_to (obj . 0))) } } impl Drop for dashcore_bls_sig_utils_BLSSignature { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } } pub mod ephemerealdata { pub mod chain_lock { use crate as example_platform ; # [doc = "FFI-representation of the [`ChainLock`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_ephemerealdata_chain_lock_ChainLock { pub block_height : u32 , pub block_hash : * mut dashcore :: hash_types :: BlockHash , pub signature : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature } impl ferment :: FFIConversionFrom < dashcore :: ephemerealdata :: chain_lock :: ChainLock > for dashcore_ephemerealdata_chain_lock_ChainLock { unsafe fn ffi_from_const (ffi : * const dashcore_ephemerealdata_chain_lock_ChainLock) -> dashcore :: ephemerealdata :: chain_lock :: ChainLock { let ffi_ref = & * ffi ; dashcore :: ephemerealdata :: chain_lock :: ChainLock { block_height : ffi_ref . block_height , block_hash : std :: ptr :: read (ffi_ref . block_hash) , signature : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_from (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dashcore :: ephemerealdata :: chain_lock :: ChainLock > for dashcore_ephemerealdata_chain_lock_ChainLock { unsafe fn ffi_to_const (obj : dashcore :: ephemerealdata :: chain_lock :: ChainLock) -> * const dashcore_ephemerealdata_chain_lock_ChainLock { ferment :: boxed (dashcore_ephemerealdata_chain_lock_ChainLock { block_height : obj . block_height , block_hash : ferment :: boxed (obj . block_hash) , signature : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_to (obj . signature) }) } } impl Drop for dashcore_ephemerealdata_chain_lock_ChainLock { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . block_hash) ; ferment :: unbox_any (ffi_ref . signature) ; } } } } pub mod instant_lock { use crate as example_platform ; # [doc = "FFI-representation of the [`InstantLock`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_ephemerealdata_instant_lock_InstantLock { pub version : u8 , pub inputs : * mut crate :: fermented :: generics :: std_vec_Vec_dashcore_blockdata_transaction_outpoint_OutPoint , pub txid : * mut dashcore :: hash_types :: Txid , pub cyclehash : * mut dashcore :: hash_types :: CycleHash , pub signature : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature } impl ferment :: FFIConversionFrom < dashcore :: ephemerealdata :: instant_lock :: InstantLock > for dashcore_ephemerealdata_instant_lock_InstantLock { unsafe fn ffi_from_const (ffi : * const dashcore_ephemerealdata_instant_lock_InstantLock) -> dashcore :: ephemerealdata :: instant_lock :: InstantLock { let ffi_ref = & * ffi ; dashcore :: ephemerealdata :: instant_lock :: InstantLock { version : ffi_ref . version , inputs : < crate :: fermented :: generics :: std_vec_Vec_dashcore_blockdata_transaction_outpoint_OutPoint as ferment :: FFIConversionFrom < std :: vec :: Vec < dashcore :: blockdata :: transaction :: outpoint :: OutPoint > >> :: ffi_from (ffi_ref . inputs) , txid : std :: ptr :: read (ffi_ref . txid) , cyclehash : std :: ptr :: read (ffi_ref . cyclehash) , signature : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_from (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dashcore :: ephemerealdata :: instant_lock :: InstantLock > for dashcore_ephemerealdata_instant_lock_InstantLock { unsafe fn ffi_to_const (obj : dashcore :: ephemerealdata :: instant_lock :: InstantLock) -> * const dashcore_ephemerealdata_instant_lock_InstantLock { ferment :: boxed (dashcore_ephemerealdata_instant_lock_InstantLock { version : obj . version , inputs : < crate :: fermented :: generics :: std_vec_Vec_dashcore_blockdata_transaction_outpoint_OutPoint as ferment :: FFIConversionTo < std :: vec :: Vec < dashcore :: blockdata :: transaction :: outpoint :: OutPoint > >> :: ffi_to (obj . inputs) , txid : ferment :: boxed (obj . txid) , cyclehash : ferment :: boxed (obj . cyclehash) , signature : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_to (obj . signature) }) } } impl Drop for dashcore_ephemerealdata_instant_lock_InstantLock { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . inputs) ; ferment :: unbox_any (ffi_ref . txid) ; ferment :: unbox_any (ffi_ref . cyclehash) ; ferment :: unbox_any (ffi_ref . signature) ; } } } } } pub mod sml { pub mod error { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`SmlError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dashcore_sml_error_SmlError { BaseBlockNotGenesis (* mut dashcore :: hash_types :: BlockHash) , BlockHashLookupFailed (* mut dashcore :: hash_types :: BlockHash) , IncompleteMnListDiff , MissingStartMasternodeList (* mut dashcore :: hash_types :: BlockHash) , BaseBlockHashMismatch { expected : * mut dashcore :: hash_types :: BlockHash , found : * mut dashcore :: hash_types :: BlockHash } , UnknownError , CorruptedCodeExecution (* mut std :: os :: raw :: c_char) , FeatureNotTurnedOn (* mut std :: os :: raw :: c_char) , InvalidIndexInSignatureSet (u16) , IncompleteSignatureSet } impl ferment :: FFIConversionFrom < dashcore :: sml :: error :: SmlError > for dashcore_sml_error_SmlError { unsafe fn ffi_from_const (ffi : * const dashcore_sml_error_SmlError) -> dashcore :: sml :: error :: SmlError { let ffi_ref = & * ffi ; match ffi_ref { dashcore_sml_error_SmlError :: BaseBlockNotGenesis (o_0) => dashcore :: sml :: error :: SmlError :: BaseBlockNotGenesis (std :: ptr :: read (* o_0)) , dashcore_sml_error_SmlError :: BlockHashLookupFailed (o_0) => dashcore :: sml :: error :: SmlError :: BlockHashLookupFailed (std :: ptr :: read (* o_0)) , dashcore_sml_error_SmlError :: IncompleteMnListDiff => dashcore :: sml :: error :: SmlError :: IncompleteMnListDiff , dashcore_sml_error_SmlError :: MissingStartMasternodeList (o_0) => dashcore :: sml :: error :: SmlError :: MissingStartMasternodeList (std :: ptr :: read (* o_0)) , dashcore_sml_error_SmlError :: BaseBlockHashMismatch { expected , found } => dashcore :: sml :: error :: SmlError :: BaseBlockHashMismatch { expected : std :: ptr :: read (* expected) , found : std :: ptr :: read (* found) } , dashcore_sml_error_SmlError :: UnknownError => dashcore :: sml :: error :: SmlError :: UnknownError , dashcore_sml_error_SmlError :: CorruptedCodeExecution (o_0) => dashcore :: sml :: error :: SmlError :: CorruptedCodeExecution (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dashcore_sml_error_SmlError :: FeatureNotTurnedOn (o_0) => dashcore :: sml :: error :: SmlError :: FeatureNotTurnedOn (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dashcore_sml_error_SmlError :: InvalidIndexInSignatureSet (o_0) => dashcore :: sml :: error :: SmlError :: InvalidIndexInSignatureSet (* o_0) , dashcore_sml_error_SmlError :: IncompleteSignatureSet => dashcore :: sml :: error :: SmlError :: IncompleteSignatureSet } } } impl ferment :: FFIConversionTo < dashcore :: sml :: error :: SmlError > for dashcore_sml_error_SmlError { unsafe fn ffi_to_const (obj : dashcore :: sml :: error :: SmlError) -> * const dashcore_sml_error_SmlError { ferment :: boxed (match obj { dashcore :: sml :: error :: SmlError :: BaseBlockNotGenesis (o_0) => dashcore_sml_error_SmlError :: BaseBlockNotGenesis (ferment :: boxed (o_0)) , dashcore :: sml :: error :: SmlError :: BlockHashLookupFailed (o_0) => dashcore_sml_error_SmlError :: BlockHashLookupFailed (ferment :: boxed (o_0)) , dashcore :: sml :: error :: SmlError :: IncompleteMnListDiff => dashcore_sml_error_SmlError :: IncompleteMnListDiff , dashcore :: sml :: error :: SmlError :: MissingStartMasternodeList (o_0) => dashcore_sml_error_SmlError :: MissingStartMasternodeList (ferment :: boxed (o_0)) , dashcore :: sml :: error :: SmlError :: BaseBlockHashMismatch { expected , found } => dashcore_sml_error_SmlError :: BaseBlockHashMismatch { expected : ferment :: boxed (expected) , found : ferment :: boxed (found) } , dashcore :: sml :: error :: SmlError :: UnknownError => dashcore_sml_error_SmlError :: UnknownError , dashcore :: sml :: error :: SmlError :: CorruptedCodeExecution (o_0) => dashcore_sml_error_SmlError :: CorruptedCodeExecution (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dashcore :: sml :: error :: SmlError :: FeatureNotTurnedOn (o_0) => dashcore_sml_error_SmlError :: FeatureNotTurnedOn (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dashcore :: sml :: error :: SmlError :: InvalidIndexInSignatureSet (o_0) => dashcore_sml_error_SmlError :: InvalidIndexInSignatureSet (o_0) , dashcore :: sml :: error :: SmlError :: IncompleteSignatureSet => dashcore_sml_error_SmlError :: IncompleteSignatureSet , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dashcore_sml_error_SmlError { fn drop (& mut self) { unsafe { match self { dashcore_sml_error_SmlError :: BaseBlockNotGenesis (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_error_SmlError :: BlockHashLookupFailed (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_error_SmlError :: IncompleteMnListDiff => { } , dashcore_sml_error_SmlError :: MissingStartMasternodeList (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_error_SmlError :: BaseBlockHashMismatch { expected , found } => { ferment :: unbox_any (* expected) ; ; ferment :: unbox_any (* found) ; } , dashcore_sml_error_SmlError :: UnknownError => { } , dashcore_sml_error_SmlError :: CorruptedCodeExecution (o_0) => { ferment :: unbox_string (* o_0) ; } , dashcore_sml_error_SmlError :: FeatureNotTurnedOn (o_0) => { ferment :: unbox_string (* o_0) ; } , dashcore_sml_error_SmlError :: InvalidIndexInSignatureSet (o_0) => { ; } , dashcore_sml_error_SmlError :: IncompleteSignatureSet => { } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod llmq_entry_verification { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`LLMQEntryVerificationSkipStatus`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dashcore_sml_llmq_entry_verification_LLMQEntryVerificationSkipStatus { NotMarkedForVerification , MissedList (* mut crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight) , UnknownBlock (* mut dashcore :: hash_types :: BlockHash) , OtherContext (* mut std :: os :: raw :: c_char) } impl ferment :: FFIConversionFrom < dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationSkipStatus > for dashcore_sml_llmq_entry_verification_LLMQEntryVerificationSkipStatus { unsafe fn ffi_from_const (ffi : * const dashcore_sml_llmq_entry_verification_LLMQEntryVerificationSkipStatus) -> dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationSkipStatus { let ffi_ref = & * ffi ; match ffi_ref { dashcore_sml_llmq_entry_verification_LLMQEntryVerificationSkipStatus :: NotMarkedForVerification => dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationSkipStatus :: NotMarkedForVerification , dashcore_sml_llmq_entry_verification_LLMQEntryVerificationSkipStatus :: MissedList (o_0) => dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationSkipStatus :: MissedList (< crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight as ferment :: FFIConversionFrom < dashcore :: prelude :: CoreBlockHeight >> :: ffi_from (* o_0)) , dashcore_sml_llmq_entry_verification_LLMQEntryVerificationSkipStatus :: UnknownBlock (o_0) => dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationSkipStatus :: UnknownBlock (std :: ptr :: read (* o_0)) , dashcore_sml_llmq_entry_verification_LLMQEntryVerificationSkipStatus :: OtherContext (o_0) => dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationSkipStatus :: OtherContext (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationSkipStatus > for dashcore_sml_llmq_entry_verification_LLMQEntryVerificationSkipStatus { unsafe fn ffi_to_const (obj : dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationSkipStatus) -> * const dashcore_sml_llmq_entry_verification_LLMQEntryVerificationSkipStatus { ferment :: boxed (match obj { dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationSkipStatus :: NotMarkedForVerification => dashcore_sml_llmq_entry_verification_LLMQEntryVerificationSkipStatus :: NotMarkedForVerification , dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationSkipStatus :: MissedList (o_0) => dashcore_sml_llmq_entry_verification_LLMQEntryVerificationSkipStatus :: MissedList (< crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight as ferment :: FFIConversionTo < dashcore :: prelude :: CoreBlockHeight >> :: ffi_to (o_0)) , dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationSkipStatus :: UnknownBlock (o_0) => dashcore_sml_llmq_entry_verification_LLMQEntryVerificationSkipStatus :: UnknownBlock (ferment :: boxed (o_0)) , dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationSkipStatus :: OtherContext (o_0) => dashcore_sml_llmq_entry_verification_LLMQEntryVerificationSkipStatus :: OtherContext (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dashcore_sml_llmq_entry_verification_LLMQEntryVerificationSkipStatus { fn drop (& mut self) { unsafe { match self { dashcore_sml_llmq_entry_verification_LLMQEntryVerificationSkipStatus :: NotMarkedForVerification => { } , dashcore_sml_llmq_entry_verification_LLMQEntryVerificationSkipStatus :: MissedList (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_llmq_entry_verification_LLMQEntryVerificationSkipStatus :: UnknownBlock (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_llmq_entry_verification_LLMQEntryVerificationSkipStatus :: OtherContext (o_0) => { ferment :: unbox_string (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`LLMQEntryVerificationStatus`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus { Unknown , Verified , Skipped (* mut crate :: fermented :: types :: dashcore :: sml :: llmq_entry_verification :: dashcore_sml_llmq_entry_verification_LLMQEntryVerificationSkipStatus) , Invalid (* mut crate :: fermented :: types :: dashcore :: sml :: quorum_validation_error :: dashcore_sml_quorum_validation_error_QuorumValidationError) } impl ferment :: FFIConversionFrom < dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus > for dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus { unsafe fn ffi_from_const (ffi : * const dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus) -> dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus { let ffi_ref = & * ffi ; match ffi_ref { dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Unknown => dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus :: Unknown , dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Verified => dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus :: Verified , dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Skipped (o_0) => dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus :: Skipped (< crate :: fermented :: types :: dashcore :: sml :: llmq_entry_verification :: dashcore_sml_llmq_entry_verification_LLMQEntryVerificationSkipStatus as ferment :: FFIConversionFrom < dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationSkipStatus >> :: ffi_from (* o_0)) , dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Invalid (o_0) => dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus :: Invalid (< crate :: fermented :: types :: dashcore :: sml :: quorum_validation_error :: dashcore_sml_quorum_validation_error_QuorumValidationError as ferment :: FFIConversionFrom < dashcore :: sml :: quorum_validation_error :: QuorumValidationError >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus > for dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus { unsafe fn ffi_to_const (obj : dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus) -> * const dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus { ferment :: boxed (match obj { dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus :: Unknown => dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Unknown , dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus :: Verified => dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Verified , dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus :: Skipped (o_0) => dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Skipped (< crate :: fermented :: types :: dashcore :: sml :: llmq_entry_verification :: dashcore_sml_llmq_entry_verification_LLMQEntryVerificationSkipStatus as ferment :: FFIConversionTo < dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationSkipStatus >> :: ffi_to (o_0)) , dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus :: Invalid (o_0) => dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Invalid (< crate :: fermented :: types :: dashcore :: sml :: quorum_validation_error :: dashcore_sml_quorum_validation_error_QuorumValidationError as ferment :: FFIConversionTo < dashcore :: sml :: quorum_validation_error :: QuorumValidationError >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus { fn drop (& mut self) { unsafe { match self { dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Unknown => { } , dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Verified => { } , dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Skipped (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Invalid (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod llmq_type { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`LLMQType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dashcore_sml_llmq_type_LLMQType { LlmqtypeUnknown = 0 , Llmqtype50_60 = 1 , Llmqtype400_60 = 2 , Llmqtype400_85 = 3 , Llmqtype100_67 = 4 , Llmqtype60_75 = 5 , Llmqtype25_67 = 6 , LlmqtypeTest = 100 , LlmqtypeDevnet = 101 , LlmqtypeTestV17 = 102 , LlmqtypeTestDIP0024 = 103 , LlmqtypeTestInstantSend = 104 , LlmqtypeDevnetDIP0024 = 105 , LlmqtypeTestnetPlatform = 106 , LlmqtypeDevnetPlatform = 107 } impl ferment :: FFIConversionFrom < dashcore :: sml :: llmq_type :: LLMQType > for dashcore_sml_llmq_type_LLMQType { unsafe fn ffi_from_const (ffi : * const dashcore_sml_llmq_type_LLMQType) -> dashcore :: sml :: llmq_type :: LLMQType { let ffi_ref = & * ffi ; match ffi_ref { dashcore_sml_llmq_type_LLMQType :: LlmqtypeUnknown => dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeUnknown , dashcore_sml_llmq_type_LLMQType :: Llmqtype50_60 => dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype50_60 , dashcore_sml_llmq_type_LLMQType :: Llmqtype400_60 => dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype400_60 , dashcore_sml_llmq_type_LLMQType :: Llmqtype400_85 => dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype400_85 , dashcore_sml_llmq_type_LLMQType :: Llmqtype100_67 => dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype100_67 , dashcore_sml_llmq_type_LLMQType :: Llmqtype60_75 => dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype60_75 , dashcore_sml_llmq_type_LLMQType :: Llmqtype25_67 => dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype25_67 , dashcore_sml_llmq_type_LLMQType :: LlmqtypeTest => dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeTest , dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnet => dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeDevnet , dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestV17 => dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeTestV17 , dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestDIP0024 => dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeTestDIP0024 , dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestInstantSend => dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeTestInstantSend , dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnetDIP0024 => dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeDevnetDIP0024 , dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestnetPlatform => dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeTestnetPlatform , dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnetPlatform => dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeDevnetPlatform } } } impl ferment :: FFIConversionTo < dashcore :: sml :: llmq_type :: LLMQType > for dashcore_sml_llmq_type_LLMQType { unsafe fn ffi_to_const (obj : dashcore :: sml :: llmq_type :: LLMQType) -> * const dashcore_sml_llmq_type_LLMQType { ferment :: boxed (match obj { dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeUnknown => dashcore_sml_llmq_type_LLMQType :: LlmqtypeUnknown , dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype50_60 => dashcore_sml_llmq_type_LLMQType :: Llmqtype50_60 , dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype400_60 => dashcore_sml_llmq_type_LLMQType :: Llmqtype400_60 , dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype400_85 => dashcore_sml_llmq_type_LLMQType :: Llmqtype400_85 , dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype100_67 => dashcore_sml_llmq_type_LLMQType :: Llmqtype100_67 , dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype60_75 => dashcore_sml_llmq_type_LLMQType :: Llmqtype60_75 , dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype25_67 => dashcore_sml_llmq_type_LLMQType :: Llmqtype25_67 , dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeTest => dashcore_sml_llmq_type_LLMQType :: LlmqtypeTest , dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeDevnet => dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnet , dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeTestV17 => dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestV17 , dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeTestDIP0024 => dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestDIP0024 , dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeTestInstantSend => dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestInstantSend , dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeDevnetDIP0024 => dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnetDIP0024 , dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeTestnetPlatform => dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestnetPlatform , dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeDevnetPlatform => dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnetPlatform , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dashcore_sml_llmq_type_LLMQType { fn drop (& mut self) { unsafe { match self { dashcore_sml_llmq_type_LLMQType :: LlmqtypeUnknown => { } , dashcore_sml_llmq_type_LLMQType :: Llmqtype50_60 => { } , dashcore_sml_llmq_type_LLMQType :: Llmqtype400_60 => { } , dashcore_sml_llmq_type_LLMQType :: Llmqtype400_85 => { } , dashcore_sml_llmq_type_LLMQType :: Llmqtype100_67 => { } , dashcore_sml_llmq_type_LLMQType :: Llmqtype60_75 => { } , dashcore_sml_llmq_type_LLMQType :: Llmqtype25_67 => { } , dashcore_sml_llmq_type_LLMQType :: LlmqtypeTest => { } , dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnet => { } , dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestV17 => { } , dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestDIP0024 => { } , dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestInstantSend => { } , dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnetDIP0024 => { } , dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestnetPlatform => { } , dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnetPlatform => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [doc = "FFI-representation of the [`dashcore::sml::llmq_type::LLMQType::index`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_index (self_ : * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType) -> u8 { let obj = dashcore :: sml :: llmq_type :: LLMQType :: index (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionFrom < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_from (self_)))) ; obj } # [doc = "FFI-representation of the [`dashcore::sml::llmq_type::LLMQType::from_u16`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_from_u16 (index : u16) -> * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType { let obj = dashcore :: sml :: llmq_type :: LLMQType :: from_u16 (index) ; < crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionTo < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`dashcore::sml::llmq_type::LLMQType::from_u8`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_from_u8 (index : u8) -> * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType { let obj = dashcore :: sml :: llmq_type :: LLMQType :: from_u8 (index) ; < crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionTo < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`dashcore::sml::llmq_type::LLMQType::is_rotating_quorum_type`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_is_rotating_quorum_type (self_ : * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType) -> bool { let obj = dashcore :: sml :: llmq_type :: LLMQType :: is_rotating_quorum_type (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionFrom < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_from (self_)))) ; obj } # [doc = "FFI-representation of the [`dashcore::sml::llmq_type::LLMQType::get_cycle_base_height`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_get_cycle_base_height (self_ : * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType , height : u32) -> u32 { let obj = dashcore :: sml :: llmq_type :: LLMQType :: get_cycle_base_height (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionFrom < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_from (self_))) , height) ; obj } # [doc = "FFI-representation of the [`dashcore::sml::llmq_type::LLMQType::get_dkg_window_for_height`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_get_dkg_window_for_height (self_ : * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType , height : u32) -> * mut dashcore :: sml :: llmq_type :: DKGWindow { let obj = dashcore :: sml :: llmq_type :: LLMQType :: get_dkg_window_for_height (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionFrom < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_from (self_))) , height) ; ferment :: boxed (obj) } # [doc = "FFI-representation of the [`dashcore::sml::llmq_type::LLMQType::get_dkg_windows_in_range`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_get_dkg_windows_in_range (self_ : * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType , start : u32 , end : u32) -> * mut crate :: fermented :: generics :: Vec_dashcore_sml_llmq_type_DKGWindow { let obj = dashcore :: sml :: llmq_type :: LLMQType :: get_dkg_windows_in_range (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionFrom < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_from (self_))) , start , end) ; < crate :: fermented :: generics :: Vec_dashcore_sml_llmq_type_DKGWindow as ferment :: FFIConversionTo < Vec < dashcore :: sml :: llmq_type :: DKGWindow > >> :: ffi_to (obj) } } pub mod masternode_list { use crate as example_platform ; # [doc = "FFI-representation of the [`MasternodeList`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_sml_masternode_list_MasternodeList { pub block_hash : * mut dashcore :: hash_types :: BlockHash , pub known_height : u32 , pub masternode_merkle_root : * mut dashcore :: hash_types :: MerkleRootMasternodeList , pub llmq_merkle_root : * mut dashcore :: hash_types :: MerkleRootQuorums , pub masternodes : * mut crate :: fermented :: generics :: std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry , pub quorums : * mut crate :: fermented :: generics :: std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry } impl ferment :: FFIConversionFrom < dashcore :: sml :: masternode_list :: MasternodeList > for dashcore_sml_masternode_list_MasternodeList { unsafe fn ffi_from_const (ffi : * const dashcore_sml_masternode_list_MasternodeList) -> dashcore :: sml :: masternode_list :: MasternodeList { let ffi_ref = & * ffi ; dashcore :: sml :: masternode_list :: MasternodeList { block_hash : std :: ptr :: read (ffi_ref . block_hash) , known_height : ffi_ref . known_height , masternode_merkle_root : ferment :: from_opt_opaque (ffi_ref . masternode_merkle_root) , llmq_merkle_root : ferment :: from_opt_opaque (ffi_ref . llmq_merkle_root) , masternodes : < crate :: fermented :: generics :: std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dashcore :: hash_types :: ProTxHash , dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry > >> :: ffi_from (ffi_ref . masternodes) , quorums : < crate :: fermented :: generics :: std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dashcore :: sml :: llmq_type :: LLMQType , std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > > >> :: ffi_from (ffi_ref . quorums) } } } impl ferment :: FFIConversionTo < dashcore :: sml :: masternode_list :: MasternodeList > for dashcore_sml_masternode_list_MasternodeList { unsafe fn ffi_to_const (obj : dashcore :: sml :: masternode_list :: MasternodeList) -> * const dashcore_sml_masternode_list_MasternodeList { ferment :: boxed (dashcore_sml_masternode_list_MasternodeList { block_hash : ferment :: boxed (obj . block_hash) , known_height : obj . known_height , masternode_merkle_root : ferment :: to_opt_primitive (obj . masternode_merkle_root) , llmq_merkle_root : ferment :: to_opt_primitive (obj . llmq_merkle_root) , masternodes : < crate :: fermented :: generics :: std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dashcore :: hash_types :: ProTxHash , dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry > >> :: ffi_to (obj . masternodes) , quorums : < crate :: fermented :: generics :: std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dashcore :: sml :: llmq_type :: LLMQType , std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > > >> :: ffi_to (obj . quorums) }) } } impl Drop for dashcore_sml_masternode_list_MasternodeList { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . block_hash) ; ; ferment :: unbox_any_opt (ffi_ref . masternode_merkle_root) ; ferment :: unbox_any_opt (ffi_ref . llmq_merkle_root) ; ferment :: unbox_any (ffi_ref . masternodes) ; ferment :: unbox_any (ffi_ref . quorums) ; } } } } pub mod masternode_list_entry { use crate as example_platform ; pub mod qualified_masternode_list_entry { use crate as example_platform ; # [doc = "FFI-representation of the [`QualifiedMasternodeListEntry`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { pub masternode_list_entry : * mut crate :: fermented :: types :: dashcore :: sml :: masternode_list_entry :: dashcore_sml_masternode_list_entry_MasternodeListEntry , pub entry_hash : * mut dashcore :: hash_types :: Sha256dHash , pub confirmed_hash_hashed_with_pro_reg_tx : * mut dashcore :: hash_types :: ConfirmedHashHashedWithProRegTx } impl ferment :: FFIConversionFrom < dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry > for dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { unsafe fn ffi_from_const (ffi : * const dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry) -> dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry { let ffi_ref = & * ffi ; dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry { masternode_list_entry : < crate :: fermented :: types :: dashcore :: sml :: masternode_list_entry :: dashcore_sml_masternode_list_entry_MasternodeListEntry as ferment :: FFIConversionFrom < dashcore :: sml :: masternode_list_entry :: MasternodeListEntry >> :: ffi_from (ffi_ref . masternode_list_entry) , entry_hash : std :: ptr :: read (ffi_ref . entry_hash) , confirmed_hash_hashed_with_pro_reg_tx : ferment :: from_opt_opaque (ffi_ref . confirmed_hash_hashed_with_pro_reg_tx) } } } impl ferment :: FFIConversionTo < dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry > for dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { unsafe fn ffi_to_const (obj : dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry) -> * const dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { ferment :: boxed (dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { masternode_list_entry : < crate :: fermented :: types :: dashcore :: sml :: masternode_list_entry :: dashcore_sml_masternode_list_entry_MasternodeListEntry as ferment :: FFIConversionTo < dashcore :: sml :: masternode_list_entry :: MasternodeListEntry >> :: ffi_to (obj . masternode_list_entry) , entry_hash : ferment :: boxed (obj . entry_hash) , confirmed_hash_hashed_with_pro_reg_tx : ferment :: to_opt_primitive (obj . confirmed_hash_hashed_with_pro_reg_tx) }) } } impl Drop for dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . masternode_list_entry) ; ferment :: unbox_any (ffi_ref . entry_hash) ; ferment :: unbox_any_opt (ffi_ref . confirmed_hash_hashed_with_pro_reg_tx) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`EntryMasternodeType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dashcore_sml_masternode_list_entry_EntryMasternodeType { Regular , HighPerformance { platform_http_port : u16 , platform_node_id : * mut dashcore :: hash_types :: PubkeyHash } } impl ferment :: FFIConversionFrom < dashcore :: sml :: masternode_list_entry :: EntryMasternodeType > for dashcore_sml_masternode_list_entry_EntryMasternodeType { unsafe fn ffi_from_const (ffi : * const dashcore_sml_masternode_list_entry_EntryMasternodeType) -> dashcore :: sml :: masternode_list_entry :: EntryMasternodeType { let ffi_ref = & * ffi ; match ffi_ref { dashcore_sml_masternode_list_entry_EntryMasternodeType :: Regular => dashcore :: sml :: masternode_list_entry :: EntryMasternodeType :: Regular , dashcore_sml_masternode_list_entry_EntryMasternodeType :: HighPerformance { platform_http_port , platform_node_id } => dashcore :: sml :: masternode_list_entry :: EntryMasternodeType :: HighPerformance { platform_http_port : * platform_http_port , platform_node_id : std :: ptr :: read (* platform_node_id) } } } } impl ferment :: FFIConversionTo < dashcore :: sml :: masternode_list_entry :: EntryMasternodeType > for dashcore_sml_masternode_list_entry_EntryMasternodeType { unsafe fn ffi_to_const (obj : dashcore :: sml :: masternode_list_entry :: EntryMasternodeType) -> * const dashcore_sml_masternode_list_entry_EntryMasternodeType { ferment :: boxed (match obj { dashcore :: sml :: masternode_list_entry :: EntryMasternodeType :: Regular => dashcore_sml_masternode_list_entry_EntryMasternodeType :: Regular , dashcore :: sml :: masternode_list_entry :: EntryMasternodeType :: HighPerformance { platform_http_port , platform_node_id } => dashcore_sml_masternode_list_entry_EntryMasternodeType :: HighPerformance { platform_http_port : platform_http_port , platform_node_id : ferment :: boxed (platform_node_id) } , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dashcore_sml_masternode_list_entry_EntryMasternodeType { fn drop (& mut self) { unsafe { match self { dashcore_sml_masternode_list_entry_EntryMasternodeType :: Regular => { } , dashcore_sml_masternode_list_entry_EntryMasternodeType :: HighPerformance { platform_http_port , platform_node_id } => { ; ; ferment :: unbox_any (* platform_node_id) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [doc = "FFI-representation of the [`OperatorPublicKey`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_sml_masternode_list_entry_OperatorPublicKey { pub data : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey , pub version : u16 } impl ferment :: FFIConversionFrom < dashcore :: sml :: masternode_list_entry :: OperatorPublicKey > for dashcore_sml_masternode_list_entry_OperatorPublicKey { unsafe fn ffi_from_const (ffi : * const dashcore_sml_masternode_list_entry_OperatorPublicKey) -> dashcore :: sml :: masternode_list_entry :: OperatorPublicKey { let ffi_ref = & * ffi ; dashcore :: sml :: masternode_list_entry :: OperatorPublicKey { data : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSPublicKey >> :: ffi_from (ffi_ref . data) , version : ffi_ref . version } } } impl ferment :: FFIConversionTo < dashcore :: sml :: masternode_list_entry :: OperatorPublicKey > for dashcore_sml_masternode_list_entry_OperatorPublicKey { unsafe fn ffi_to_const (obj : dashcore :: sml :: masternode_list_entry :: OperatorPublicKey) -> * const dashcore_sml_masternode_list_entry_OperatorPublicKey { ferment :: boxed (dashcore_sml_masternode_list_entry_OperatorPublicKey { data : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSPublicKey >> :: ffi_to (obj . data) , version : obj . version }) } } impl Drop for dashcore_sml_masternode_list_entry_OperatorPublicKey { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data) ; ; } } } # [doc = "FFI-representation of the [`MasternodeListEntry`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_sml_masternode_list_entry_MasternodeListEntry { pub version : u16 , pub pro_reg_tx_hash : * mut dashcore :: hash_types :: ProTxHash , pub confirmed_hash : * mut dashcore :: hash_types :: ConfirmedHash , pub service_address : * mut std :: net :: SocketAddr , pub operator_public_key : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey , pub key_id_voting : * mut dashcore :: hash_types :: PubkeyHash , pub is_valid : bool , pub mn_type : * mut crate :: fermented :: types :: dashcore :: sml :: masternode_list_entry :: dashcore_sml_masternode_list_entry_EntryMasternodeType } impl ferment :: FFIConversionFrom < dashcore :: sml :: masternode_list_entry :: MasternodeListEntry > for dashcore_sml_masternode_list_entry_MasternodeListEntry { unsafe fn ffi_from_const (ffi : * const dashcore_sml_masternode_list_entry_MasternodeListEntry) -> dashcore :: sml :: masternode_list_entry :: MasternodeListEntry { let ffi_ref = & * ffi ; dashcore :: sml :: masternode_list_entry :: MasternodeListEntry { version : ffi_ref . version , pro_reg_tx_hash : std :: ptr :: read (ffi_ref . pro_reg_tx_hash) , confirmed_hash : ferment :: from_opt_opaque (ffi_ref . confirmed_hash) , service_address : std :: ptr :: read (ffi_ref . service_address) , operator_public_key : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSPublicKey >> :: ffi_from (ffi_ref . operator_public_key) , key_id_voting : std :: ptr :: read (ffi_ref . key_id_voting) , is_valid : ffi_ref . is_valid , mn_type : < crate :: fermented :: types :: dashcore :: sml :: masternode_list_entry :: dashcore_sml_masternode_list_entry_EntryMasternodeType as ferment :: FFIConversionFrom < dashcore :: sml :: masternode_list_entry :: EntryMasternodeType >> :: ffi_from (ffi_ref . mn_type) } } } impl ferment :: FFIConversionTo < dashcore :: sml :: masternode_list_entry :: MasternodeListEntry > for dashcore_sml_masternode_list_entry_MasternodeListEntry { unsafe fn ffi_to_const (obj : dashcore :: sml :: masternode_list_entry :: MasternodeListEntry) -> * const dashcore_sml_masternode_list_entry_MasternodeListEntry { ferment :: boxed (dashcore_sml_masternode_list_entry_MasternodeListEntry { version : obj . version , pro_reg_tx_hash : ferment :: boxed (obj . pro_reg_tx_hash) , confirmed_hash : ferment :: to_opt_primitive (obj . confirmed_hash) , service_address : ferment :: boxed (obj . service_address) , operator_public_key : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSPublicKey >> :: ffi_to (obj . operator_public_key) , key_id_voting : ferment :: boxed (obj . key_id_voting) , is_valid : obj . is_valid , mn_type : < crate :: fermented :: types :: dashcore :: sml :: masternode_list_entry :: dashcore_sml_masternode_list_entry_EntryMasternodeType as ferment :: FFIConversionTo < dashcore :: sml :: masternode_list_entry :: EntryMasternodeType >> :: ffi_to (obj . mn_type) }) } } impl Drop for dashcore_sml_masternode_list_entry_MasternodeListEntry { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . pro_reg_tx_hash) ; ferment :: unbox_any_opt (ffi_ref . confirmed_hash) ; ferment :: unbox_any (ffi_ref . service_address) ; ferment :: unbox_any (ffi_ref . operator_public_key) ; ferment :: unbox_any (ffi_ref . key_id_voting) ; ; ferment :: unbox_any (ffi_ref . mn_type) ; } } } } pub mod quorum_entry { pub mod qualified_quorum_entry { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`VerifyingChainLockSignaturesType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType { Rotating (* mut crate :: fermented :: generics :: Arr_dashcore_bls_sig_utils_BLSSignature_4) , NonRotating (* mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature) } impl ferment :: FFIConversionFrom < dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: VerifyingChainLockSignaturesType > for dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType { unsafe fn ffi_from_const (ffi : * const dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType) -> dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: VerifyingChainLockSignaturesType { let ffi_ref = & * ffi ; match ffi_ref { dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType :: Rotating (o_0) => dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: VerifyingChainLockSignaturesType :: Rotating (< crate :: fermented :: generics :: Arr_dashcore_bls_sig_utils_BLSSignature_4 as ferment :: FFIConversionFrom < [dashcore :: bls_sig_utils :: BLSSignature ; 4] >> :: ffi_from (* o_0)) , dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType :: NonRotating (o_0) => dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: VerifyingChainLockSignaturesType :: NonRotating (< crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: VerifyingChainLockSignaturesType > for dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType { unsafe fn ffi_to_const (obj : dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: VerifyingChainLockSignaturesType) -> * const dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType { ferment :: boxed (match obj { dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: VerifyingChainLockSignaturesType :: Rotating (o_0) => dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType :: Rotating (< crate :: fermented :: generics :: Arr_dashcore_bls_sig_utils_BLSSignature_4 as ferment :: FFIConversionTo < [dashcore :: bls_sig_utils :: BLSSignature ; 4] >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: VerifyingChainLockSignaturesType :: NonRotating (o_0) => dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType :: NonRotating (< crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType { fn drop (& mut self) { unsafe { match self { dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType :: Rotating (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType :: NonRotating (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [doc = "FFI-representation of the [`QualifiedQuorumEntry`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { pub quorum_entry : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry , pub verified : * mut crate :: fermented :: types :: dashcore :: sml :: llmq_entry_verification :: dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus , pub commitment_hash : * mut dashcore :: hash_types :: QuorumCommitmentHash , pub entry_hash : * mut dashcore :: hash_types :: QuorumEntryHash , pub verifying_chain_lock_signature : * mut crate :: fermented :: types :: dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType } impl ferment :: FFIConversionFrom < dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > for dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { unsafe fn ffi_from_const (ffi : * const dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) -> dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry { let ffi_ref = & * ffi ; dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry { quorum_entry : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry >> :: ffi_from (ffi_ref . quorum_entry) , verified : < crate :: fermented :: types :: dashcore :: sml :: llmq_entry_verification :: dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus as ferment :: FFIConversionFrom < dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus >> :: ffi_from (ffi_ref . verified) , commitment_hash : std :: ptr :: read (ffi_ref . commitment_hash) , entry_hash : std :: ptr :: read (ffi_ref . entry_hash) , verifying_chain_lock_signature : < crate :: fermented :: types :: dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType as ferment :: FFIConversionFrom < dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: VerifyingChainLockSignaturesType >> :: ffi_from_opt (ffi_ref . verifying_chain_lock_signature) } } } impl ferment :: FFIConversionTo < dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > for dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { unsafe fn ffi_to_const (obj : dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry) -> * const dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { ferment :: boxed (dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { quorum_entry : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry >> :: ffi_to (obj . quorum_entry) , verified : < crate :: fermented :: types :: dashcore :: sml :: llmq_entry_verification :: dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus as ferment :: FFIConversionTo < dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus >> :: ffi_to (obj . verified) , commitment_hash : ferment :: boxed (obj . commitment_hash) , entry_hash : ferment :: boxed (obj . entry_hash) , verifying_chain_lock_signature : < crate :: fermented :: types :: dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType as ferment :: FFIConversionTo < dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: VerifyingChainLockSignaturesType >> :: ffi_to_opt (obj . verifying_chain_lock_signature) }) } } impl Drop for dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . quorum_entry) ; ferment :: unbox_any (ffi_ref . verified) ; ferment :: unbox_any (ffi_ref . commitment_hash) ; ferment :: unbox_any (ffi_ref . entry_hash) ; ferment :: unbox_any_opt (ffi_ref . verifying_chain_lock_signature) ; } } } } } pub mod quorum_validation_error { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ClientDataRetrievalError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dashcore_sml_quorum_validation_error_ClientDataRetrievalError { RequiredBlockNotPresent (* mut dashcore :: hash_types :: BlockHash) , CoinbaseNotFoundOnBlock (* mut dashcore :: hash_types :: BlockHash) } impl ferment :: FFIConversionFrom < dashcore :: sml :: quorum_validation_error :: ClientDataRetrievalError > for dashcore_sml_quorum_validation_error_ClientDataRetrievalError { unsafe fn ffi_from_const (ffi : * const dashcore_sml_quorum_validation_error_ClientDataRetrievalError) -> dashcore :: sml :: quorum_validation_error :: ClientDataRetrievalError { let ffi_ref = & * ffi ; match ffi_ref { dashcore_sml_quorum_validation_error_ClientDataRetrievalError :: RequiredBlockNotPresent (o_0) => dashcore :: sml :: quorum_validation_error :: ClientDataRetrievalError :: RequiredBlockNotPresent (std :: ptr :: read (* o_0)) , dashcore_sml_quorum_validation_error_ClientDataRetrievalError :: CoinbaseNotFoundOnBlock (o_0) => dashcore :: sml :: quorum_validation_error :: ClientDataRetrievalError :: CoinbaseNotFoundOnBlock (std :: ptr :: read (* o_0)) } } } impl ferment :: FFIConversionTo < dashcore :: sml :: quorum_validation_error :: ClientDataRetrievalError > for dashcore_sml_quorum_validation_error_ClientDataRetrievalError { unsafe fn ffi_to_const (obj : dashcore :: sml :: quorum_validation_error :: ClientDataRetrievalError) -> * const dashcore_sml_quorum_validation_error_ClientDataRetrievalError { ferment :: boxed (match obj { dashcore :: sml :: quorum_validation_error :: ClientDataRetrievalError :: RequiredBlockNotPresent (o_0) => dashcore_sml_quorum_validation_error_ClientDataRetrievalError :: RequiredBlockNotPresent (ferment :: boxed (o_0)) , dashcore :: sml :: quorum_validation_error :: ClientDataRetrievalError :: CoinbaseNotFoundOnBlock (o_0) => dashcore_sml_quorum_validation_error_ClientDataRetrievalError :: CoinbaseNotFoundOnBlock (ferment :: boxed (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dashcore_sml_quorum_validation_error_ClientDataRetrievalError { fn drop (& mut self) { unsafe { match self { dashcore_sml_quorum_validation_error_ClientDataRetrievalError :: RequiredBlockNotPresent (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_quorum_validation_error_ClientDataRetrievalError :: CoinbaseNotFoundOnBlock (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`QuorumValidationError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dashcore_sml_quorum_validation_error_QuorumValidationError { RequiredBlockNotPresent (* mut dashcore :: hash_types :: BlockHash , * mut std :: os :: raw :: c_char) , RequiredBlockHeightNotPresent (* mut crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight) , VerifyingMasternodeListNotPresent (* mut crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight) , RequiredMasternodeListNotPresent (* mut crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight) , RequiredChainLockNotPresent (* mut crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight , * mut dashcore :: hash_types :: BlockHash) , RequiredRotatedChainLockSigNotPresent (u8 , * mut dashcore :: hash_types :: BlockHash) , RequiredRotatedChainLockSigsNotPresent (* mut dashcore :: hash_types :: BlockHash) , InsufficientSigners { required : u64 , found : u64 } , InsufficientValidMembers { required : u64 , found : u64 } , MismatchedBitsetLengths { signers_len : usize , valid_members_len : usize } , InvalidQuorumPublicKey , InvalidBLSPublicKey (* mut std :: os :: raw :: c_char) , InvalidBLSSignature (* mut std :: os :: raw :: c_char) , InvalidQuorumSignature , InvalidFinalSignature , AllCommitmentAggregatedSignatureNotValid (* mut std :: os :: raw :: c_char) , ThresholdSignatureNotValid (* mut std :: os :: raw :: c_char) , CommitmentHashNotPresent , RequiredSnapshotNotPresent (* mut dashcore :: hash_types :: BlockHash) , SMLError (* mut crate :: fermented :: types :: dashcore :: sml :: error :: dashcore_sml_error_SmlError) , RequiredQuorumIndexNotPresent (* mut dashcore :: hash_types :: QuorumHash) , CorruptedCodeExecution (* mut std :: os :: raw :: c_char) , ExpectedOnlyRotatedQuorums (* mut dashcore :: hash_types :: QuorumHash , * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType) , ClientDataRetrievalError (* mut crate :: fermented :: types :: dashcore :: sml :: quorum_validation_error :: dashcore_sml_quorum_validation_error_ClientDataRetrievalError) , FeatureNotTurnedOn (* mut std :: os :: raw :: c_char) } impl ferment :: FFIConversionFrom < dashcore :: sml :: quorum_validation_error :: QuorumValidationError > for dashcore_sml_quorum_validation_error_QuorumValidationError { unsafe fn ffi_from_const (ffi : * const dashcore_sml_quorum_validation_error_QuorumValidationError) -> dashcore :: sml :: quorum_validation_error :: QuorumValidationError { let ffi_ref = & * ffi ; match ffi_ref { dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredBlockNotPresent (o_0 , o_1) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredBlockNotPresent (std :: ptr :: read (* o_0) , < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_1)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredBlockHeightNotPresent (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredBlockHeightNotPresent (< crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight as ferment :: FFIConversionFrom < dashcore :: prelude :: CoreBlockHeight >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: VerifyingMasternodeListNotPresent (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: VerifyingMasternodeListNotPresent (< crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight as ferment :: FFIConversionFrom < dashcore :: prelude :: CoreBlockHeight >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredMasternodeListNotPresent (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredMasternodeListNotPresent (< crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight as ferment :: FFIConversionFrom < dashcore :: prelude :: CoreBlockHeight >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredChainLockNotPresent (o_0 , o_1) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredChainLockNotPresent (< crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight as ferment :: FFIConversionFrom < dashcore :: prelude :: CoreBlockHeight >> :: ffi_from (* o_0) , std :: ptr :: read (* o_1)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredRotatedChainLockSigNotPresent (o_0 , o_1) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredRotatedChainLockSigNotPresent (* o_0 , std :: ptr :: read (* o_1)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredRotatedChainLockSigsNotPresent (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredRotatedChainLockSigsNotPresent (std :: ptr :: read (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: InsufficientSigners { required , found } => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InsufficientSigners { required : * required , found : * found } , dashcore_sml_quorum_validation_error_QuorumValidationError :: InsufficientValidMembers { required , found } => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InsufficientValidMembers { required : * required , found : * found } , dashcore_sml_quorum_validation_error_QuorumValidationError :: MismatchedBitsetLengths { signers_len , valid_members_len } => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: MismatchedBitsetLengths { signers_len : * signers_len , valid_members_len : * valid_members_len } , dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidQuorumPublicKey => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InvalidQuorumPublicKey , dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidBLSPublicKey (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InvalidBLSPublicKey (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidBLSSignature (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InvalidBLSSignature (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidQuorumSignature => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InvalidQuorumSignature , dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidFinalSignature => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InvalidFinalSignature , dashcore_sml_quorum_validation_error_QuorumValidationError :: AllCommitmentAggregatedSignatureNotValid (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: AllCommitmentAggregatedSignatureNotValid (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: ThresholdSignatureNotValid (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: ThresholdSignatureNotValid (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: CommitmentHashNotPresent => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: CommitmentHashNotPresent , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredSnapshotNotPresent (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredSnapshotNotPresent (std :: ptr :: read (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: SMLError (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: SMLError (< crate :: fermented :: types :: dashcore :: sml :: error :: dashcore_sml_error_SmlError as ferment :: FFIConversionFrom < dashcore :: sml :: error :: SmlError >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredQuorumIndexNotPresent (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredQuorumIndexNotPresent (std :: ptr :: read (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: CorruptedCodeExecution (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: CorruptedCodeExecution (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: ExpectedOnlyRotatedQuorums (o_0 , o_1) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: ExpectedOnlyRotatedQuorums (std :: ptr :: read (* o_0) , < crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionFrom < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_from (* o_1)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: ClientDataRetrievalError (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: ClientDataRetrievalError (< crate :: fermented :: types :: dashcore :: sml :: quorum_validation_error :: dashcore_sml_quorum_validation_error_ClientDataRetrievalError as ferment :: FFIConversionFrom < dashcore :: sml :: quorum_validation_error :: ClientDataRetrievalError >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: FeatureNotTurnedOn (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: FeatureNotTurnedOn (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dashcore :: sml :: quorum_validation_error :: QuorumValidationError > for dashcore_sml_quorum_validation_error_QuorumValidationError { unsafe fn ffi_to_const (obj : dashcore :: sml :: quorum_validation_error :: QuorumValidationError) -> * const dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (match obj { dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredBlockNotPresent (o_0 , o_1) => dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredBlockNotPresent (ferment :: boxed (o_0) , < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_1)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredBlockHeightNotPresent (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredBlockHeightNotPresent (< crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight as ferment :: FFIConversionTo < dashcore :: prelude :: CoreBlockHeight >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: VerifyingMasternodeListNotPresent (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: VerifyingMasternodeListNotPresent (< crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight as ferment :: FFIConversionTo < dashcore :: prelude :: CoreBlockHeight >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredMasternodeListNotPresent (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredMasternodeListNotPresent (< crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight as ferment :: FFIConversionTo < dashcore :: prelude :: CoreBlockHeight >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredChainLockNotPresent (o_0 , o_1) => dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredChainLockNotPresent (< crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight as ferment :: FFIConversionTo < dashcore :: prelude :: CoreBlockHeight >> :: ffi_to (o_0) , ferment :: boxed (o_1)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredRotatedChainLockSigNotPresent (o_0 , o_1) => dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredRotatedChainLockSigNotPresent (o_0 , ferment :: boxed (o_1)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredRotatedChainLockSigsNotPresent (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredRotatedChainLockSigsNotPresent (ferment :: boxed (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InsufficientSigners { required , found } => dashcore_sml_quorum_validation_error_QuorumValidationError :: InsufficientSigners { required : required , found : found } , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InsufficientValidMembers { required , found } => dashcore_sml_quorum_validation_error_QuorumValidationError :: InsufficientValidMembers { required : required , found : found } , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: MismatchedBitsetLengths { signers_len , valid_members_len } => dashcore_sml_quorum_validation_error_QuorumValidationError :: MismatchedBitsetLengths { signers_len : signers_len , valid_members_len : valid_members_len } , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InvalidQuorumPublicKey => dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidQuorumPublicKey , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InvalidBLSPublicKey (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidBLSPublicKey (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InvalidBLSSignature (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidBLSSignature (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InvalidQuorumSignature => dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidQuorumSignature , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InvalidFinalSignature => dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidFinalSignature , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: AllCommitmentAggregatedSignatureNotValid (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: AllCommitmentAggregatedSignatureNotValid (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: ThresholdSignatureNotValid (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: ThresholdSignatureNotValid (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: CommitmentHashNotPresent => dashcore_sml_quorum_validation_error_QuorumValidationError :: CommitmentHashNotPresent , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredSnapshotNotPresent (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredSnapshotNotPresent (ferment :: boxed (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: SMLError (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: SMLError (< crate :: fermented :: types :: dashcore :: sml :: error :: dashcore_sml_error_SmlError as ferment :: FFIConversionTo < dashcore :: sml :: error :: SmlError >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredQuorumIndexNotPresent (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredQuorumIndexNotPresent (ferment :: boxed (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: CorruptedCodeExecution (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: CorruptedCodeExecution (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: ExpectedOnlyRotatedQuorums (o_0 , o_1) => dashcore_sml_quorum_validation_error_QuorumValidationError :: ExpectedOnlyRotatedQuorums (ferment :: boxed (o_0) , < crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionTo < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_to (o_1)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: ClientDataRetrievalError (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: ClientDataRetrievalError (< crate :: fermented :: types :: dashcore :: sml :: quorum_validation_error :: dashcore_sml_quorum_validation_error_ClientDataRetrievalError as ferment :: FFIConversionTo < dashcore :: sml :: quorum_validation_error :: ClientDataRetrievalError >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: FeatureNotTurnedOn (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: FeatureNotTurnedOn (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dashcore_sml_quorum_validation_error_QuorumValidationError { fn drop (& mut self) { unsafe { match self { dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredBlockNotPresent (o_0 , o_1) => { ferment :: unbox_any (* o_0) ; ; ferment :: unbox_string (* o_1) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredBlockHeightNotPresent (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: VerifyingMasternodeListNotPresent (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredMasternodeListNotPresent (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredChainLockNotPresent (o_0 , o_1) => { ferment :: unbox_any (* o_0) ; ; ferment :: unbox_any (* o_1) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredRotatedChainLockSigNotPresent (o_0 , o_1) => { ; ; ferment :: unbox_any (* o_1) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredRotatedChainLockSigsNotPresent (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: InsufficientSigners { required , found } => { ; ; ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: InsufficientValidMembers { required , found } => { ; ; ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: MismatchedBitsetLengths { signers_len , valid_members_len } => { ; ; ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidQuorumPublicKey => { } , dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidBLSPublicKey (o_0) => { ferment :: unbox_string (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidBLSSignature (o_0) => { ferment :: unbox_string (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidQuorumSignature => { } , dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidFinalSignature => { } , dashcore_sml_quorum_validation_error_QuorumValidationError :: AllCommitmentAggregatedSignatureNotValid (o_0) => { ferment :: unbox_string (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: ThresholdSignatureNotValid (o_0) => { ferment :: unbox_string (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: CommitmentHashNotPresent => { } , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredSnapshotNotPresent (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: SMLError (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredQuorumIndexNotPresent (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: CorruptedCodeExecution (o_0) => { ferment :: unbox_string (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: ExpectedOnlyRotatedQuorums (o_0 , o_1) => { ferment :: unbox_any (* o_0) ; ; ferment :: unbox_any (* o_1) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: ClientDataRetrievalError (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: FeatureNotTurnedOn (o_0) => { ferment :: unbox_string (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } } pub mod prelude { use crate as example_platform ; # [doc = "FFI-representation of the [`CoreBlockHeight`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_prelude_CoreBlockHeight (u32) ; impl ferment :: FFIConversionFrom < dashcore :: prelude :: CoreBlockHeight > for dashcore_prelude_CoreBlockHeight { unsafe fn ffi_from_const (ffi : * const dashcore_prelude_CoreBlockHeight) -> dashcore :: prelude :: CoreBlockHeight { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dashcore :: prelude :: CoreBlockHeight > for dashcore_prelude_CoreBlockHeight { unsafe fn ffi_to_const (obj : dashcore :: prelude :: CoreBlockHeight) -> * const dashcore_prelude_CoreBlockHeight { ferment :: boxed (dashcore_prelude_CoreBlockHeight (obj)) } } } } pub mod dpp { pub mod data_contract { use crate as example_platform ; pub mod errors { pub mod contract { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DataContractError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_errors_contract_DataContractError { DecodingContractError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: decoding_error :: dpp_errors_consensus_basic_decode_decoding_error_DecodingError) , DecodingDocumentError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: decoding_error :: dpp_errors_consensus_basic_decode_decoding_error_DecodingError) , InvalidDocumentTypeError (* mut crate :: fermented :: types :: dpp :: data_contract :: errors :: invalid_document_type_error :: dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError) , DocumentTypesAreMissingError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: document_types_are_missing_error :: dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError) , MissingRequiredKey (* mut std :: os :: raw :: c_char) , FieldRequirementUnmet (* mut std :: os :: raw :: c_char) , RegexError (* mut std :: os :: raw :: c_char) , KeyWrongType (* mut std :: os :: raw :: c_char) , ValueWrongType (* mut std :: os :: raw :: c_char) , InvalidURI (* mut std :: os :: raw :: c_char) , KeyWrongBounds (* mut std :: os :: raw :: c_char) , KeyValueMustExist (* mut std :: os :: raw :: c_char) , ValueDecodingError (* mut std :: os :: raw :: c_char) , EncodingDataStructureNotSupported (* mut std :: os :: raw :: c_char) , InvalidContractStructure (* mut std :: os :: raw :: c_char) , DocumentTypeNotFound (* mut std :: os :: raw :: c_char) , DocumentTypeFieldNotFound (* mut std :: os :: raw :: c_char) , ReferenceDefinitionNotFound (* mut std :: os :: raw :: c_char) , DocumentOwnerIdMissing (* mut std :: os :: raw :: c_char) , DocumentIdMissing (* mut std :: os :: raw :: c_char) , Unsupported (* mut std :: os :: raw :: c_char) , CorruptedSerialization (* mut std :: os :: raw :: c_char) , JsonSchema (* mut crate :: fermented :: types :: dpp :: data_contract :: errors :: json_schema_error :: dpp_data_contract_errors_json_schema_error_JsonSchemaError) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: errors :: contract :: DataContractError > for dpp_data_contract_errors_contract_DataContractError { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_errors_contract_DataContractError) -> dpp :: data_contract :: errors :: contract :: DataContractError { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_errors_contract_DataContractError :: DecodingContractError (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: DecodingContractError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: decoding_error :: dpp_errors_consensus_basic_decode_decoding_error_DecodingError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: decode :: decoding_error :: DecodingError >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: DecodingDocumentError (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: DecodingDocumentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: decoding_error :: dpp_errors_consensus_basic_decode_decoding_error_DecodingError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: decode :: decoding_error :: DecodingError >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: InvalidDocumentTypeError (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: InvalidDocumentTypeError (< crate :: fermented :: types :: dpp :: data_contract :: errors :: invalid_document_type_error :: dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError as ferment :: FFIConversionFrom < dpp :: data_contract :: errors :: invalid_document_type_error :: InvalidDocumentTypeError >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: DocumentTypesAreMissingError (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: DocumentTypesAreMissingError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: document_types_are_missing_error :: dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: document_types_are_missing_error :: DocumentTypesAreMissingError >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: MissingRequiredKey (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: MissingRequiredKey (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: FieldRequirementUnmet (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: FieldRequirementUnmet (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: RegexError (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: RegexError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: KeyWrongType (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: KeyWrongType (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: ValueWrongType (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: ValueWrongType (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: InvalidURI (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: InvalidURI (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: KeyWrongBounds (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: KeyWrongBounds (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: KeyValueMustExist (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: KeyValueMustExist (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: ValueDecodingError (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: ValueDecodingError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: EncodingDataStructureNotSupported (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: EncodingDataStructureNotSupported (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: InvalidContractStructure (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: InvalidContractStructure (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: DocumentTypeNotFound (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: DocumentTypeNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: DocumentTypeFieldNotFound (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: DocumentTypeFieldNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: ReferenceDefinitionNotFound (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: ReferenceDefinitionNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: DocumentOwnerIdMissing (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: DocumentOwnerIdMissing (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: DocumentIdMissing (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: DocumentIdMissing (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: Unsupported (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: Unsupported (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: CorruptedSerialization (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: CorruptedSerialization (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: JsonSchema (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: JsonSchema (< crate :: fermented :: types :: dpp :: data_contract :: errors :: json_schema_error :: dpp_data_contract_errors_json_schema_error_JsonSchemaError as ferment :: FFIConversionFrom < dpp :: data_contract :: errors :: json_schema_error :: JsonSchemaError >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: errors :: contract :: DataContractError > for dpp_data_contract_errors_contract_DataContractError { unsafe fn ffi_to_const (obj : dpp :: data_contract :: errors :: contract :: DataContractError) -> * const dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (match obj { dpp :: data_contract :: errors :: contract :: DataContractError :: DecodingContractError (o_0) => dpp_data_contract_errors_contract_DataContractError :: DecodingContractError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: decoding_error :: dpp_errors_consensus_basic_decode_decoding_error_DecodingError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: decode :: decoding_error :: DecodingError >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: DecodingDocumentError (o_0) => dpp_data_contract_errors_contract_DataContractError :: DecodingDocumentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: decoding_error :: dpp_errors_consensus_basic_decode_decoding_error_DecodingError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: decode :: decoding_error :: DecodingError >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: InvalidDocumentTypeError (o_0) => dpp_data_contract_errors_contract_DataContractError :: InvalidDocumentTypeError (< crate :: fermented :: types :: dpp :: data_contract :: errors :: invalid_document_type_error :: dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError as ferment :: FFIConversionTo < dpp :: data_contract :: errors :: invalid_document_type_error :: InvalidDocumentTypeError >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: DocumentTypesAreMissingError (o_0) => dpp_data_contract_errors_contract_DataContractError :: DocumentTypesAreMissingError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: document_types_are_missing_error :: dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: document_types_are_missing_error :: DocumentTypesAreMissingError >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: MissingRequiredKey (o_0) => dpp_data_contract_errors_contract_DataContractError :: MissingRequiredKey (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: FieldRequirementUnmet (o_0) => dpp_data_contract_errors_contract_DataContractError :: FieldRequirementUnmet (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: RegexError (o_0) => dpp_data_contract_errors_contract_DataContractError :: RegexError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: KeyWrongType (o_0) => dpp_data_contract_errors_contract_DataContractError :: KeyWrongType (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: ValueWrongType (o_0) => dpp_data_contract_errors_contract_DataContractError :: ValueWrongType (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: InvalidURI (o_0) => dpp_data_contract_errors_contract_DataContractError :: InvalidURI (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: KeyWrongBounds (o_0) => dpp_data_contract_errors_contract_DataContractError :: KeyWrongBounds (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: KeyValueMustExist (o_0) => dpp_data_contract_errors_contract_DataContractError :: KeyValueMustExist (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: ValueDecodingError (o_0) => dpp_data_contract_errors_contract_DataContractError :: ValueDecodingError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: EncodingDataStructureNotSupported (o_0) => dpp_data_contract_errors_contract_DataContractError :: EncodingDataStructureNotSupported (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: InvalidContractStructure (o_0) => dpp_data_contract_errors_contract_DataContractError :: InvalidContractStructure (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: DocumentTypeNotFound (o_0) => dpp_data_contract_errors_contract_DataContractError :: DocumentTypeNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: DocumentTypeFieldNotFound (o_0) => dpp_data_contract_errors_contract_DataContractError :: DocumentTypeFieldNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: ReferenceDefinitionNotFound (o_0) => dpp_data_contract_errors_contract_DataContractError :: ReferenceDefinitionNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: DocumentOwnerIdMissing (o_0) => dpp_data_contract_errors_contract_DataContractError :: DocumentOwnerIdMissing (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: DocumentIdMissing (o_0) => dpp_data_contract_errors_contract_DataContractError :: DocumentIdMissing (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: Unsupported (o_0) => dpp_data_contract_errors_contract_DataContractError :: Unsupported (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: CorruptedSerialization (o_0) => dpp_data_contract_errors_contract_DataContractError :: CorruptedSerialization (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: JsonSchema (o_0) => dpp_data_contract_errors_contract_DataContractError :: JsonSchema (< crate :: fermented :: types :: dpp :: data_contract :: errors :: json_schema_error :: dpp_data_contract_errors_json_schema_error_JsonSchemaError as ferment :: FFIConversionTo < dpp :: data_contract :: errors :: json_schema_error :: JsonSchemaError >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_errors_contract_DataContractError { fn drop (& mut self) { unsafe { match self { dpp_data_contract_errors_contract_DataContractError :: DecodingContractError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: DecodingDocumentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: InvalidDocumentTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: DocumentTypesAreMissingError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: MissingRequiredKey (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: FieldRequirementUnmet (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: RegexError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: KeyWrongType (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: ValueWrongType (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: InvalidURI (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: KeyWrongBounds (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: KeyValueMustExist (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: ValueDecodingError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: EncodingDataStructureNotSupported (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: InvalidContractStructure (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: DocumentTypeNotFound (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: DocumentTypeFieldNotFound (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: ReferenceDefinitionNotFound (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: DocumentOwnerIdMissing (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: DocumentIdMissing (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: Unsupported (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: CorruptedSerialization (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: JsonSchema (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod data_contract_not_present_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DataContractNotPresentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: data_contract :: errors :: data_contract_not_present_error :: DataContractNotPresentError > for dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError) -> dpp :: data_contract :: errors :: data_contract_not_present_error :: DataContractNotPresentError { let ffi_ref = & * ffi ; dpp :: data_contract :: errors :: data_contract_not_present_error :: DataContractNotPresentError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: errors :: data_contract_not_present_error :: DataContractNotPresentError > for dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError { unsafe fn ffi_to_const (obj : dpp :: data_contract :: errors :: data_contract_not_present_error :: DataContractNotPresentError) -> * const dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError { ferment :: boxed (dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) }) } } impl Drop for dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; } } } } pub mod identity_not_present_error { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityNotPresentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError { pub id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: data_contract :: errors :: identity_not_present_error :: IdentityNotPresentError > for dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError) -> dpp :: data_contract :: errors :: identity_not_present_error :: IdentityNotPresentError { let ffi_ref = & * ffi ; dpp :: data_contract :: errors :: identity_not_present_error :: IdentityNotPresentError { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . id) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: errors :: identity_not_present_error :: IdentityNotPresentError > for dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError { unsafe fn ffi_to_const (obj : dpp :: data_contract :: errors :: identity_not_present_error :: IdentityNotPresentError) -> * const dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError { ferment :: boxed (dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . id) }) } } impl Drop for dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; } } } } pub mod invalid_document_type_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidDocumentTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError { pub doc_type : * mut std :: os :: raw :: c_char , pub data_contract : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DataContract } impl ferment :: FFIConversionFrom < dpp :: data_contract :: errors :: invalid_document_type_error :: InvalidDocumentTypeError > for dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError) -> dpp :: data_contract :: errors :: invalid_document_type_error :: InvalidDocumentTypeError { let ffi_ref = & * ffi ; dpp :: data_contract :: errors :: invalid_document_type_error :: InvalidDocumentTypeError { doc_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . doc_type) , data_contract : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DataContract as ferment :: FFIConversionFrom < dpp :: data_contract :: DataContract >> :: ffi_from (ffi_ref . data_contract) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: errors :: invalid_document_type_error :: InvalidDocumentTypeError > for dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError { unsafe fn ffi_to_const (obj : dpp :: data_contract :: errors :: invalid_document_type_error :: InvalidDocumentTypeError) -> * const dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError { ferment :: boxed (dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError { doc_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . doc_type) , data_contract : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DataContract as ferment :: FFIConversionTo < dpp :: data_contract :: DataContract >> :: ffi_to (obj . data_contract) }) } } impl Drop for dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . doc_type) ; ferment :: unbox_any (ffi_ref . data_contract) ; } } } } pub mod json_schema_error { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`JsonSchemaError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_errors_json_schema_error_JsonSchemaError { CreateSchemaError (* mut std :: os :: raw :: c_char) , SchemaCompatibilityValidationError (* mut std :: os :: raw :: c_char) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: errors :: json_schema_error :: JsonSchemaError > for dpp_data_contract_errors_json_schema_error_JsonSchemaError { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_errors_json_schema_error_JsonSchemaError) -> dpp :: data_contract :: errors :: json_schema_error :: JsonSchemaError { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_errors_json_schema_error_JsonSchemaError :: CreateSchemaError (o_0) => dpp :: data_contract :: errors :: json_schema_error :: JsonSchemaError :: CreateSchemaError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_json_schema_error_JsonSchemaError :: SchemaCompatibilityValidationError (o_0) => dpp :: data_contract :: errors :: json_schema_error :: JsonSchemaError :: SchemaCompatibilityValidationError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: errors :: json_schema_error :: JsonSchemaError > for dpp_data_contract_errors_json_schema_error_JsonSchemaError { unsafe fn ffi_to_const (obj : dpp :: data_contract :: errors :: json_schema_error :: JsonSchemaError) -> * const dpp_data_contract_errors_json_schema_error_JsonSchemaError { ferment :: boxed (match obj { dpp :: data_contract :: errors :: json_schema_error :: JsonSchemaError :: CreateSchemaError (o_0) => dpp_data_contract_errors_json_schema_error_JsonSchemaError :: CreateSchemaError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: json_schema_error :: JsonSchemaError :: SchemaCompatibilityValidationError (o_0) => dpp_data_contract_errors_json_schema_error_JsonSchemaError :: SchemaCompatibilityValidationError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_errors_json_schema_error_JsonSchemaError { fn drop (& mut self) { unsafe { match self { dpp_data_contract_errors_json_schema_error_JsonSchemaError :: CreateSchemaError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_json_schema_error_JsonSchemaError :: SchemaCompatibilityValidationError (o_0) => { ferment :: unbox_string (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } } pub mod document_type { use crate as example_platform ; pub mod property { use crate as example_platform ; pub mod array { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ArrayItemType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_document_type_property_array_ArrayItemType { Integer , Number , String (* mut usize , * mut usize) , ByteArray (* mut usize , * mut usize) , Identifier , Boolean , Date } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType > for dpp_data_contract_document_type_property_array_ArrayItemType { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_property_array_ArrayItemType) -> dpp :: data_contract :: document_type :: property :: array :: ArrayItemType { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_document_type_property_array_ArrayItemType :: Integer => dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: Integer , dpp_data_contract_document_type_property_array_ArrayItemType :: Number => dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: Number , dpp_data_contract_document_type_property_array_ArrayItemType :: String (o_0 , o_1) => dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: String (ferment :: from_opt_primitive (* o_0) , ferment :: from_opt_primitive (* o_1)) , dpp_data_contract_document_type_property_array_ArrayItemType :: ByteArray (o_0 , o_1) => dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: ByteArray (ferment :: from_opt_primitive (* o_0) , ferment :: from_opt_primitive (* o_1)) , dpp_data_contract_document_type_property_array_ArrayItemType :: Identifier => dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: Identifier , dpp_data_contract_document_type_property_array_ArrayItemType :: Boolean => dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: Boolean , dpp_data_contract_document_type_property_array_ArrayItemType :: Date => dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: Date } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType > for dpp_data_contract_document_type_property_array_ArrayItemType { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: property :: array :: ArrayItemType) -> * const dpp_data_contract_document_type_property_array_ArrayItemType { ferment :: boxed (match obj { dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: Integer => dpp_data_contract_document_type_property_array_ArrayItemType :: Integer , dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: Number => dpp_data_contract_document_type_property_array_ArrayItemType :: Number , dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: String (o_0 , o_1) => dpp_data_contract_document_type_property_array_ArrayItemType :: String (ferment :: to_opt_primitive (o_0) , ferment :: to_opt_primitive (o_1)) , dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: ByteArray (o_0 , o_1) => dpp_data_contract_document_type_property_array_ArrayItemType :: ByteArray (ferment :: to_opt_primitive (o_0) , ferment :: to_opt_primitive (o_1)) , dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: Identifier => dpp_data_contract_document_type_property_array_ArrayItemType :: Identifier , dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: Boolean => dpp_data_contract_document_type_property_array_ArrayItemType :: Boolean , dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: Date => dpp_data_contract_document_type_property_array_ArrayItemType :: Date , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_document_type_property_array_ArrayItemType { fn drop (& mut self) { unsafe { match self { dpp_data_contract_document_type_property_array_ArrayItemType :: Integer => { } , dpp_data_contract_document_type_property_array_ArrayItemType :: Number => { } , dpp_data_contract_document_type_property_array_ArrayItemType :: String (o_0 , o_1) => { ferment :: unbox_any_opt (* o_0) ; ; ferment :: unbox_any_opt (* o_1) ; } , dpp_data_contract_document_type_property_array_ArrayItemType :: ByteArray (o_0 , o_1) => { ferment :: unbox_any_opt (* o_0) ; ; ferment :: unbox_any_opt (* o_1) ; } , dpp_data_contract_document_type_property_array_ArrayItemType :: Identifier => { } , dpp_data_contract_document_type_property_array_ArrayItemType :: Boolean => { } , dpp_data_contract_document_type_property_array_ArrayItemType :: Date => { } , _ => unreachable ! ("This is unreachable") } ; } } } } # [doc = "FFI-representation of the [`DocumentProperty`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_document_type_property_DocumentProperty { pub property_type : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_DocumentPropertyType , pub required : bool , pub transient : bool } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: property :: DocumentProperty > for dpp_data_contract_document_type_property_DocumentProperty { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_property_DocumentProperty) -> dpp :: data_contract :: document_type :: property :: DocumentProperty { let ffi_ref = & * ffi ; dpp :: data_contract :: document_type :: property :: DocumentProperty { property_type : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_DocumentPropertyType as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: property :: DocumentPropertyType >> :: ffi_from (ffi_ref . property_type) , required : ffi_ref . required , transient : ffi_ref . transient } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: property :: DocumentProperty > for dpp_data_contract_document_type_property_DocumentProperty { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: property :: DocumentProperty) -> * const dpp_data_contract_document_type_property_DocumentProperty { ferment :: boxed (dpp_data_contract_document_type_property_DocumentProperty { property_type : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_DocumentPropertyType as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: property :: DocumentPropertyType >> :: ffi_to (obj . property_type) , required : obj . required , transient : obj . transient }) } } impl Drop for dpp_data_contract_document_type_property_DocumentProperty { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . property_type) ; ; ; } } } # [doc = "FFI-representation of the [`StringPropertySizes`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_document_type_property_StringPropertySizes { pub min_length : * mut u16 , pub max_length : * mut u16 } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: property :: StringPropertySizes > for dpp_data_contract_document_type_property_StringPropertySizes { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_property_StringPropertySizes) -> dpp :: data_contract :: document_type :: property :: StringPropertySizes { let ffi_ref = & * ffi ; dpp :: data_contract :: document_type :: property :: StringPropertySizes { min_length : ferment :: from_opt_primitive (ffi_ref . min_length) , max_length : ferment :: from_opt_primitive (ffi_ref . max_length) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: property :: StringPropertySizes > for dpp_data_contract_document_type_property_StringPropertySizes { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: property :: StringPropertySizes) -> * const dpp_data_contract_document_type_property_StringPropertySizes { ferment :: boxed (dpp_data_contract_document_type_property_StringPropertySizes { min_length : ferment :: to_opt_primitive (obj . min_length) , max_length : ferment :: to_opt_primitive (obj . max_length) }) } } impl Drop for dpp_data_contract_document_type_property_StringPropertySizes { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any_opt (ffi_ref . min_length) ; ferment :: unbox_any_opt (ffi_ref . max_length) ; } } } # [doc = "FFI-representation of the [`ByteArrayPropertySizes`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_document_type_property_ByteArrayPropertySizes { pub min_size : * mut u16 , pub max_size : * mut u16 } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: property :: ByteArrayPropertySizes > for dpp_data_contract_document_type_property_ByteArrayPropertySizes { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_property_ByteArrayPropertySizes) -> dpp :: data_contract :: document_type :: property :: ByteArrayPropertySizes { let ffi_ref = & * ffi ; dpp :: data_contract :: document_type :: property :: ByteArrayPropertySizes { min_size : ferment :: from_opt_primitive (ffi_ref . min_size) , max_size : ferment :: from_opt_primitive (ffi_ref . max_size) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: property :: ByteArrayPropertySizes > for dpp_data_contract_document_type_property_ByteArrayPropertySizes { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: property :: ByteArrayPropertySizes) -> * const dpp_data_contract_document_type_property_ByteArrayPropertySizes { ferment :: boxed (dpp_data_contract_document_type_property_ByteArrayPropertySizes { min_size : ferment :: to_opt_primitive (obj . min_size) , max_size : ferment :: to_opt_primitive (obj . max_size) }) } } impl Drop for dpp_data_contract_document_type_property_ByteArrayPropertySizes { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any_opt (ffi_ref . min_size) ; ferment :: unbox_any_opt (ffi_ref . max_size) ; } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentPropertyType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_document_type_property_DocumentPropertyType { U128 , I128 , U64 , I64 , U32 , I32 , U16 , I16 , U8 , I8 , F64 , String (* mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_StringPropertySizes) , ByteArray (* mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_ByteArrayPropertySizes) , Identifier , Boolean , Date , Object (* mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty) , Array (* mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: array :: dpp_data_contract_document_type_property_array_ArrayItemType) , VariableTypeArray (* mut crate :: fermented :: generics :: Vec_dpp_data_contract_document_type_property_array_ArrayItemType) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: property :: DocumentPropertyType > for dpp_data_contract_document_type_property_DocumentPropertyType { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_property_DocumentPropertyType) -> dpp :: data_contract :: document_type :: property :: DocumentPropertyType { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_document_type_property_DocumentPropertyType :: U128 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: U128 , dpp_data_contract_document_type_property_DocumentPropertyType :: I128 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: I128 , dpp_data_contract_document_type_property_DocumentPropertyType :: U64 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: U64 , dpp_data_contract_document_type_property_DocumentPropertyType :: I64 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: I64 , dpp_data_contract_document_type_property_DocumentPropertyType :: U32 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: U32 , dpp_data_contract_document_type_property_DocumentPropertyType :: I32 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: I32 , dpp_data_contract_document_type_property_DocumentPropertyType :: U16 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: U16 , dpp_data_contract_document_type_property_DocumentPropertyType :: I16 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: I16 , dpp_data_contract_document_type_property_DocumentPropertyType :: U8 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: U8 , dpp_data_contract_document_type_property_DocumentPropertyType :: I8 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: I8 , dpp_data_contract_document_type_property_DocumentPropertyType :: F64 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: F64 , dpp_data_contract_document_type_property_DocumentPropertyType :: String (o_0) => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: String (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_StringPropertySizes as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: property :: StringPropertySizes >> :: ffi_from (* o_0)) , dpp_data_contract_document_type_property_DocumentPropertyType :: ByteArray (o_0) => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: ByteArray (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_ByteArrayPropertySizes as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: property :: ByteArrayPropertySizes >> :: ffi_from (* o_0)) , dpp_data_contract_document_type_property_DocumentPropertyType :: Identifier => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: Identifier , dpp_data_contract_document_type_property_DocumentPropertyType :: Boolean => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: Boolean , dpp_data_contract_document_type_property_DocumentPropertyType :: Date => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: Date , dpp_data_contract_document_type_property_DocumentPropertyType :: Object (o_0) => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: Object (< crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty as ferment :: FFIConversionFrom < indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > >> :: ffi_from (* o_0)) , dpp_data_contract_document_type_property_DocumentPropertyType :: Array (o_0) => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: Array (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: array :: dpp_data_contract_document_type_property_array_ArrayItemType as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType >> :: ffi_from (* o_0)) , dpp_data_contract_document_type_property_DocumentPropertyType :: VariableTypeArray (o_0) => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: VariableTypeArray (< crate :: fermented :: generics :: Vec_dpp_data_contract_document_type_property_array_ArrayItemType as ferment :: FFIConversionFrom < Vec < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType > >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: property :: DocumentPropertyType > for dpp_data_contract_document_type_property_DocumentPropertyType { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: property :: DocumentPropertyType) -> * const dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (match obj { dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: U128 => dpp_data_contract_document_type_property_DocumentPropertyType :: U128 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: I128 => dpp_data_contract_document_type_property_DocumentPropertyType :: I128 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: U64 => dpp_data_contract_document_type_property_DocumentPropertyType :: U64 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: I64 => dpp_data_contract_document_type_property_DocumentPropertyType :: I64 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: U32 => dpp_data_contract_document_type_property_DocumentPropertyType :: U32 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: I32 => dpp_data_contract_document_type_property_DocumentPropertyType :: I32 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: U16 => dpp_data_contract_document_type_property_DocumentPropertyType :: U16 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: I16 => dpp_data_contract_document_type_property_DocumentPropertyType :: I16 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: U8 => dpp_data_contract_document_type_property_DocumentPropertyType :: U8 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: I8 => dpp_data_contract_document_type_property_DocumentPropertyType :: I8 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: F64 => dpp_data_contract_document_type_property_DocumentPropertyType :: F64 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: String (o_0) => dpp_data_contract_document_type_property_DocumentPropertyType :: String (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_StringPropertySizes as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: property :: StringPropertySizes >> :: ffi_to (o_0)) , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: ByteArray (o_0) => dpp_data_contract_document_type_property_DocumentPropertyType :: ByteArray (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_ByteArrayPropertySizes as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: property :: ByteArrayPropertySizes >> :: ffi_to (o_0)) , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: Identifier => dpp_data_contract_document_type_property_DocumentPropertyType :: Identifier , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: Boolean => dpp_data_contract_document_type_property_DocumentPropertyType :: Boolean , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: Date => dpp_data_contract_document_type_property_DocumentPropertyType :: Date , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: Object (o_0) => dpp_data_contract_document_type_property_DocumentPropertyType :: Object (< crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty as ferment :: FFIConversionTo < indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > >> :: ffi_to (o_0)) , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: Array (o_0) => dpp_data_contract_document_type_property_DocumentPropertyType :: Array (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: array :: dpp_data_contract_document_type_property_array_ArrayItemType as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType >> :: ffi_to (o_0)) , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: VariableTypeArray (o_0) => dpp_data_contract_document_type_property_DocumentPropertyType :: VariableTypeArray (< crate :: fermented :: generics :: Vec_dpp_data_contract_document_type_property_array_ArrayItemType as ferment :: FFIConversionTo < Vec < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType > >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_document_type_property_DocumentPropertyType { fn drop (& mut self) { unsafe { match self { dpp_data_contract_document_type_property_DocumentPropertyType :: U128 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: I128 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: U64 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: I64 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: U32 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: I32 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: U16 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: I16 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: U8 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: I8 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: F64 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: String (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_document_type_property_DocumentPropertyType :: ByteArray (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_document_type_property_DocumentPropertyType :: Identifier => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: Boolean => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: Date => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: Object (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_document_type_property_DocumentPropertyType :: Array (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_document_type_property_DocumentPropertyType :: VariableTypeArray (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod index { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`OrderBy`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_document_type_index_OrderBy { Asc , Desc } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index :: OrderBy > for dpp_data_contract_document_type_index_OrderBy { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_index_OrderBy) -> dpp :: data_contract :: document_type :: index :: OrderBy { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_document_type_index_OrderBy :: Asc => dpp :: data_contract :: document_type :: index :: OrderBy :: Asc , dpp_data_contract_document_type_index_OrderBy :: Desc => dpp :: data_contract :: document_type :: index :: OrderBy :: Desc } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index :: OrderBy > for dpp_data_contract_document_type_index_OrderBy { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: index :: OrderBy) -> * const dpp_data_contract_document_type_index_OrderBy { ferment :: boxed (match obj { dpp :: data_contract :: document_type :: index :: OrderBy :: Asc => dpp_data_contract_document_type_index_OrderBy :: Asc , dpp :: data_contract :: document_type :: index :: OrderBy :: Desc => dpp_data_contract_document_type_index_OrderBy :: Desc , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_document_type_index_OrderBy { fn drop (& mut self) { unsafe { match self { dpp_data_contract_document_type_index_OrderBy :: Asc => { } , dpp_data_contract_document_type_index_OrderBy :: Desc => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ContestedIndexResolution`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_document_type_index_ContestedIndexResolution { MasternodeVote = 0 } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index :: ContestedIndexResolution > for dpp_data_contract_document_type_index_ContestedIndexResolution { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_index_ContestedIndexResolution) -> dpp :: data_contract :: document_type :: index :: ContestedIndexResolution { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_document_type_index_ContestedIndexResolution :: MasternodeVote => dpp :: data_contract :: document_type :: index :: ContestedIndexResolution :: MasternodeVote } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index :: ContestedIndexResolution > for dpp_data_contract_document_type_index_ContestedIndexResolution { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: index :: ContestedIndexResolution) -> * const dpp_data_contract_document_type_index_ContestedIndexResolution { ferment :: boxed (match obj { dpp :: data_contract :: document_type :: index :: ContestedIndexResolution :: MasternodeVote => dpp_data_contract_document_type_index_ContestedIndexResolution :: MasternodeVote , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_document_type_index_ContestedIndexResolution { fn drop (& mut self) { unsafe { match self { dpp_data_contract_document_type_index_ContestedIndexResolution :: MasternodeVote => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ContestedIndexFieldMatch`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_document_type_index_ContestedIndexFieldMatch { Regex (* mut dpp :: data_contract :: document_type :: index :: LazyRegex) , PositiveIntegerMatch (* mut [u8 ; 16]) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch > for dpp_data_contract_document_type_index_ContestedIndexFieldMatch { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_index_ContestedIndexFieldMatch) -> dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_document_type_index_ContestedIndexFieldMatch :: Regex (o_0) => dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch :: Regex (std :: ptr :: read (* o_0)) , dpp_data_contract_document_type_index_ContestedIndexFieldMatch :: PositiveIntegerMatch (o_0) => dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch :: PositiveIntegerMatch (< [u8 ; 16] as ferment :: FFIConversionFrom < u128 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch > for dpp_data_contract_document_type_index_ContestedIndexFieldMatch { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch) -> * const dpp_data_contract_document_type_index_ContestedIndexFieldMatch { ferment :: boxed (match obj { dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch :: Regex (o_0) => dpp_data_contract_document_type_index_ContestedIndexFieldMatch :: Regex (ferment :: boxed (o_0)) , dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch :: PositiveIntegerMatch (o_0) => dpp_data_contract_document_type_index_ContestedIndexFieldMatch :: PositiveIntegerMatch (< [u8 ; 16] as ferment :: FFIConversionTo < u128 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_document_type_index_ContestedIndexFieldMatch { fn drop (& mut self) { unsafe { match self { dpp_data_contract_document_type_index_ContestedIndexFieldMatch :: Regex (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_document_type_index_ContestedIndexFieldMatch :: PositiveIntegerMatch (o_0) => { ferment :: unbox_any_opt (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [doc = "FFI-representation of the [`ContestedIndexInformation`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_document_type_index_ContestedIndexInformation { pub field_matches : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch , pub resolution : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexResolution } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index :: ContestedIndexInformation > for dpp_data_contract_document_type_index_ContestedIndexInformation { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_index_ContestedIndexInformation) -> dpp :: data_contract :: document_type :: index :: ContestedIndexInformation { let ffi_ref = & * ffi ; dpp :: data_contract :: document_type :: index :: ContestedIndexInformation { field_matches : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch > >> :: ffi_from (ffi_ref . field_matches) , resolution : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexResolution as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index :: ContestedIndexResolution >> :: ffi_from (ffi_ref . resolution) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index :: ContestedIndexInformation > for dpp_data_contract_document_type_index_ContestedIndexInformation { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: index :: ContestedIndexInformation) -> * const dpp_data_contract_document_type_index_ContestedIndexInformation { ferment :: boxed (dpp_data_contract_document_type_index_ContestedIndexInformation { field_matches : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch as ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch > >> :: ffi_to (obj . field_matches) , resolution : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexResolution as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index :: ContestedIndexResolution >> :: ffi_to (obj . resolution) }) } } impl Drop for dpp_data_contract_document_type_index_ContestedIndexInformation { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . field_matches) ; ferment :: unbox_any (ffi_ref . resolution) ; } } } # [doc = "FFI-representation of the [`Index`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_document_type_index_Index { pub name : * mut std :: os :: raw :: c_char , pub properties : * mut crate :: fermented :: generics :: Vec_dpp_data_contract_document_type_index_IndexProperty , pub unique : bool , pub null_searchable : bool , pub contested_index : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexInformation } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index :: Index > for dpp_data_contract_document_type_index_Index { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_index_Index) -> dpp :: data_contract :: document_type :: index :: Index { let ffi_ref = & * ffi ; dpp :: data_contract :: document_type :: index :: Index { name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . name) , properties : < crate :: fermented :: generics :: Vec_dpp_data_contract_document_type_index_IndexProperty as ferment :: FFIConversionFrom < Vec < dpp :: data_contract :: document_type :: index :: IndexProperty > >> :: ffi_from (ffi_ref . properties) , unique : ffi_ref . unique , null_searchable : ffi_ref . null_searchable , contested_index : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexInformation as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index :: ContestedIndexInformation >> :: ffi_from_opt (ffi_ref . contested_index) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index :: Index > for dpp_data_contract_document_type_index_Index { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: index :: Index) -> * const dpp_data_contract_document_type_index_Index { ferment :: boxed (dpp_data_contract_document_type_index_Index { name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . name) , properties : < crate :: fermented :: generics :: Vec_dpp_data_contract_document_type_index_IndexProperty as ferment :: FFIConversionTo < Vec < dpp :: data_contract :: document_type :: index :: IndexProperty > >> :: ffi_to (obj . properties) , unique : obj . unique , null_searchable : obj . null_searchable , contested_index : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexInformation as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index :: ContestedIndexInformation >> :: ffi_to_opt (obj . contested_index) }) } } impl Drop for dpp_data_contract_document_type_index_Index { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . name) ; ferment :: unbox_any (ffi_ref . properties) ; ; ; ferment :: unbox_any_opt (ffi_ref . contested_index) ; } } } # [doc = "FFI-representation of the [`IndexProperty`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_document_type_index_IndexProperty { pub name : * mut std :: os :: raw :: c_char , pub ascending : bool } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index :: IndexProperty > for dpp_data_contract_document_type_index_IndexProperty { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_index_IndexProperty) -> dpp :: data_contract :: document_type :: index :: IndexProperty { let ffi_ref = & * ffi ; dpp :: data_contract :: document_type :: index :: IndexProperty { name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . name) , ascending : ffi_ref . ascending } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index :: IndexProperty > for dpp_data_contract_document_type_index_IndexProperty { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: index :: IndexProperty) -> * const dpp_data_contract_document_type_index_IndexProperty { ferment :: boxed (dpp_data_contract_document_type_index_IndexProperty { name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . name) , ascending : obj . ascending }) } } impl Drop for dpp_data_contract_document_type_index_IndexProperty { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . name) ; ; } } } } pub mod index_level { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`IndexType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_document_type_index_level_IndexType { NonUniqueIndex , UniqueIndex , ContestedResourceIndex } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index_level :: IndexType > for dpp_data_contract_document_type_index_level_IndexType { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_index_level_IndexType) -> dpp :: data_contract :: document_type :: index_level :: IndexType { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_document_type_index_level_IndexType :: NonUniqueIndex => dpp :: data_contract :: document_type :: index_level :: IndexType :: NonUniqueIndex , dpp_data_contract_document_type_index_level_IndexType :: UniqueIndex => dpp :: data_contract :: document_type :: index_level :: IndexType :: UniqueIndex , dpp_data_contract_document_type_index_level_IndexType :: ContestedResourceIndex => dpp :: data_contract :: document_type :: index_level :: IndexType :: ContestedResourceIndex } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index_level :: IndexType > for dpp_data_contract_document_type_index_level_IndexType { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: index_level :: IndexType) -> * const dpp_data_contract_document_type_index_level_IndexType { ferment :: boxed (match obj { dpp :: data_contract :: document_type :: index_level :: IndexType :: NonUniqueIndex => dpp_data_contract_document_type_index_level_IndexType :: NonUniqueIndex , dpp :: data_contract :: document_type :: index_level :: IndexType :: UniqueIndex => dpp_data_contract_document_type_index_level_IndexType :: UniqueIndex , dpp :: data_contract :: document_type :: index_level :: IndexType :: ContestedResourceIndex => dpp_data_contract_document_type_index_level_IndexType :: ContestedResourceIndex , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_document_type_index_level_IndexType { fn drop (& mut self) { unsafe { match self { dpp_data_contract_document_type_index_level_IndexType :: NonUniqueIndex => { } , dpp_data_contract_document_type_index_level_IndexType :: UniqueIndex => { } , dpp_data_contract_document_type_index_level_IndexType :: ContestedResourceIndex => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [doc = "FFI-representation of the [`IndexLevelTypeInfo`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_document_type_index_level_IndexLevelTypeInfo { pub should_insert_with_all_null : bool , pub index_type : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexType } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index_level :: IndexLevelTypeInfo > for dpp_data_contract_document_type_index_level_IndexLevelTypeInfo { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_index_level_IndexLevelTypeInfo) -> dpp :: data_contract :: document_type :: index_level :: IndexLevelTypeInfo { let ffi_ref = & * ffi ; dpp :: data_contract :: document_type :: index_level :: IndexLevelTypeInfo { should_insert_with_all_null : ffi_ref . should_insert_with_all_null , index_type : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexType as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index_level :: IndexType >> :: ffi_from (ffi_ref . index_type) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index_level :: IndexLevelTypeInfo > for dpp_data_contract_document_type_index_level_IndexLevelTypeInfo { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: index_level :: IndexLevelTypeInfo) -> * const dpp_data_contract_document_type_index_level_IndexLevelTypeInfo { ferment :: boxed (dpp_data_contract_document_type_index_level_IndexLevelTypeInfo { should_insert_with_all_null : obj . should_insert_with_all_null , index_type : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexType as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index_level :: IndexType >> :: ffi_to (obj . index_type) }) } } impl Drop for dpp_data_contract_document_type_index_level_IndexLevelTypeInfo { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . index_type) ; } } } # [doc = "FFI-representation of the [`IndexLevel`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_document_type_index_level_IndexLevel { pub sub_index_levels : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel , pub has_index_with_type : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevelTypeInfo , pub level_identifier : u64 } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index_level :: IndexLevel > for dpp_data_contract_document_type_index_level_IndexLevel { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_index_level_IndexLevel) -> dpp :: data_contract :: document_type :: index_level :: IndexLevel { let ffi_ref = & * ffi ; dpp :: data_contract :: document_type :: index_level :: IndexLevel { sub_index_levels : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index_level :: IndexLevel > >> :: ffi_from (ffi_ref . sub_index_levels) , has_index_with_type : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevelTypeInfo as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index_level :: IndexLevelTypeInfo >> :: ffi_from_opt (ffi_ref . has_index_with_type) , level_identifier : ffi_ref . level_identifier } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index_level :: IndexLevel > for dpp_data_contract_document_type_index_level_IndexLevel { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: index_level :: IndexLevel) -> * const dpp_data_contract_document_type_index_level_IndexLevel { ferment :: boxed (dpp_data_contract_document_type_index_level_IndexLevel { sub_index_levels : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel as ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index_level :: IndexLevel > >> :: ffi_to (obj . sub_index_levels) , has_index_with_type : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevelTypeInfo as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index_level :: IndexLevelTypeInfo >> :: ffi_to_opt (obj . has_index_with_type) , level_identifier : obj . level_identifier }) } } impl Drop for dpp_data_contract_document_type_index_level_IndexLevel { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . sub_index_levels) ; ferment :: unbox_any_opt (ffi_ref . has_index_with_type) ; ; } } } } pub mod restricted_creation { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`CreationRestrictionMode`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode { NoRestrictions , OwnerOnly , NoCreationAllowed } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode > for dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode) -> dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: NoRestrictions => dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode :: NoRestrictions , dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: OwnerOnly => dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode :: OwnerOnly , dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: NoCreationAllowed => dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode :: NoCreationAllowed } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode > for dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode) -> * const dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode { ferment :: boxed (match obj { dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode :: NoRestrictions => dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: NoRestrictions , dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode :: OwnerOnly => dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: OwnerOnly , dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode :: NoCreationAllowed => dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: NoCreationAllowed , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode { fn drop (& mut self) { unsafe { match self { dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: NoRestrictions => { } , dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: OwnerOnly => { } , dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: NoCreationAllowed => { } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod token_costs { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`TokenCostsV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_document_type_token_costs_v0_TokenCostsV0 { pub create : * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost , pub replace : * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost , pub delete : * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost , pub transfer : * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost , pub update_price : * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost , pub purchase : * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: token_costs :: v0 :: TokenCostsV0 > for dpp_data_contract_document_type_token_costs_v0_TokenCostsV0 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_token_costs_v0_TokenCostsV0) -> dpp :: data_contract :: document_type :: token_costs :: v0 :: TokenCostsV0 { let ffi_ref = & * ffi ; dpp :: data_contract :: document_type :: token_costs :: v0 :: TokenCostsV0 { create : < crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost as ferment :: FFIConversionFrom < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost >> :: ffi_from_opt (ffi_ref . create) , replace : < crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost as ferment :: FFIConversionFrom < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost >> :: ffi_from_opt (ffi_ref . replace) , delete : < crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost as ferment :: FFIConversionFrom < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost >> :: ffi_from_opt (ffi_ref . delete) , transfer : < crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost as ferment :: FFIConversionFrom < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost >> :: ffi_from_opt (ffi_ref . transfer) , update_price : < crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost as ferment :: FFIConversionFrom < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost >> :: ffi_from_opt (ffi_ref . update_price) , purchase : < crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost as ferment :: FFIConversionFrom < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost >> :: ffi_from_opt (ffi_ref . purchase) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: token_costs :: v0 :: TokenCostsV0 > for dpp_data_contract_document_type_token_costs_v0_TokenCostsV0 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: token_costs :: v0 :: TokenCostsV0) -> * const dpp_data_contract_document_type_token_costs_v0_TokenCostsV0 { ferment :: boxed (dpp_data_contract_document_type_token_costs_v0_TokenCostsV0 { create : < crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost as ferment :: FFIConversionTo < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost >> :: ffi_to_opt (obj . create) , replace : < crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost as ferment :: FFIConversionTo < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost >> :: ffi_to_opt (obj . replace) , delete : < crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost as ferment :: FFIConversionTo < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost >> :: ffi_to_opt (obj . delete) , transfer : < crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost as ferment :: FFIConversionTo < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost >> :: ffi_to_opt (obj . transfer) , update_price : < crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost as ferment :: FFIConversionTo < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost >> :: ffi_to_opt (obj . update_price) , purchase : < crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost as ferment :: FFIConversionTo < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost >> :: ffi_to_opt (obj . purchase) }) } } impl Drop for dpp_data_contract_document_type_token_costs_v0_TokenCostsV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any_opt (ffi_ref . create) ; ferment :: unbox_any_opt (ffi_ref . replace) ; ferment :: unbox_any_opt (ffi_ref . delete) ; ferment :: unbox_any_opt (ffi_ref . transfer) ; ferment :: unbox_any_opt (ffi_ref . update_price) ; ferment :: unbox_any_opt (ffi_ref . purchase) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenCosts`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_document_type_token_costs_TokenCosts { V0 (* mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: token_costs :: v0 :: dpp_data_contract_document_type_token_costs_v0_TokenCostsV0) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: token_costs :: TokenCosts > for dpp_data_contract_document_type_token_costs_TokenCosts { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_token_costs_TokenCosts) -> dpp :: data_contract :: document_type :: token_costs :: TokenCosts { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_document_type_token_costs_TokenCosts :: V0 (o_0) => dpp :: data_contract :: document_type :: token_costs :: TokenCosts :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: token_costs :: v0 :: dpp_data_contract_document_type_token_costs_v0_TokenCostsV0 as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: token_costs :: v0 :: TokenCostsV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: token_costs :: TokenCosts > for dpp_data_contract_document_type_token_costs_TokenCosts { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: token_costs :: TokenCosts) -> * const dpp_data_contract_document_type_token_costs_TokenCosts { ferment :: boxed (match obj { dpp :: data_contract :: document_type :: token_costs :: TokenCosts :: V0 (o_0) => dpp_data_contract_document_type_token_costs_TokenCosts :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: token_costs :: v0 :: dpp_data_contract_document_type_token_costs_v0_TokenCostsV0 as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: token_costs :: v0 :: TokenCostsV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_document_type_token_costs_TokenCosts { fn drop (& mut self) { unsafe { match self { dpp_data_contract_document_type_token_costs_TokenCosts :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`DocumentTypeV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_document_type_v0_DocumentTypeV0 { pub name : * mut std :: os :: raw :: c_char , pub schema : * mut crate :: fermented :: types :: platform_value :: platform_value_Value , pub indices : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index , pub index_structure : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel , pub flattened_properties : * mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty , pub properties : * mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty , pub identifier_paths : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , pub binary_paths : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , pub required_fields : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , pub transient_fields : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , pub documents_keep_history : bool , pub documents_mutable : bool , pub documents_can_be_deleted : bool , pub documents_transferable : * mut crate :: fermented :: types :: dpp :: document :: transfer :: dpp_document_transfer_Transferable , pub trade_mode : * mut crate :: fermented :: types :: dpp :: nft :: dpp_nft_TradeMode , pub creation_restriction_mode : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode , pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub requires_identity_encryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements , pub requires_identity_decryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements , pub security_level_requirement : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel , # [cfg (feature = "validation")] pub json_schema_validator : * mut dpp :: data_contract :: document_type :: validator :: StatelessJsonSchemaLazyValidator } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: v0 :: DocumentTypeV0 > for dpp_data_contract_document_type_v0_DocumentTypeV0 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> dpp :: data_contract :: document_type :: v0 :: DocumentTypeV0 { let ffi_ref = & * ffi ; dpp :: data_contract :: document_type :: v0 :: DocumentTypeV0 { name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . name) , schema : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (ffi_ref . schema) , indices : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: Index > >> :: ffi_from (ffi_ref . indices) , index_structure : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index_level :: IndexLevel >> :: ffi_from (ffi_ref . index_structure) , flattened_properties : < crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty as ferment :: FFIConversionFrom < indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > >> :: ffi_from (ffi_ref . flattened_properties) , properties : < crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty as ferment :: FFIConversionFrom < indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > >> :: ffi_from (ffi_ref . properties) , identifier_paths : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < String > >> :: ffi_from (ffi_ref . identifier_paths) , binary_paths : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < String > >> :: ffi_from (ffi_ref . binary_paths) , required_fields : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < String > >> :: ffi_from (ffi_ref . required_fields) , transient_fields : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < String > >> :: ffi_from (ffi_ref . transient_fields) , documents_keep_history : ffi_ref . documents_keep_history , documents_mutable : ffi_ref . documents_mutable , documents_can_be_deleted : ffi_ref . documents_can_be_deleted , documents_transferable : < crate :: fermented :: types :: dpp :: document :: transfer :: dpp_document_transfer_Transferable as ferment :: FFIConversionFrom < dpp :: document :: transfer :: Transferable >> :: ffi_from (ffi_ref . documents_transferable) , trade_mode : < crate :: fermented :: types :: dpp :: nft :: dpp_nft_TradeMode as ferment :: FFIConversionFrom < dpp :: nft :: TradeMode >> :: ffi_from (ffi_ref . trade_mode) , creation_restriction_mode : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode >> :: ffi_from (ffi_ref . creation_restriction_mode) , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , requires_identity_encryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionFrom < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_from_opt (ffi_ref . requires_identity_encryption_bounded_key) , requires_identity_decryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionFrom < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_from_opt (ffi_ref . requires_identity_decryption_bounded_key) , security_level_requirement : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_from (ffi_ref . security_level_requirement) , # [cfg (feature = "validation")] json_schema_validator : std :: ptr :: read (ffi_ref . json_schema_validator) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: v0 :: DocumentTypeV0 > for dpp_data_contract_document_type_v0_DocumentTypeV0 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: v0 :: DocumentTypeV0) -> * const dpp_data_contract_document_type_v0_DocumentTypeV0 { ferment :: boxed (dpp_data_contract_document_type_v0_DocumentTypeV0 { name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . name) , schema : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (obj . schema) , indices : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index as ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: Index > >> :: ffi_to (obj . indices) , index_structure : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index_level :: IndexLevel >> :: ffi_to (obj . index_structure) , flattened_properties : < crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty as ferment :: FFIConversionTo < indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > >> :: ffi_to (obj . flattened_properties) , properties : < crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty as ferment :: FFIConversionTo < indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > >> :: ffi_to (obj . properties) , identifier_paths : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionTo < std :: collections :: BTreeSet < String > >> :: ffi_to (obj . identifier_paths) , binary_paths : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionTo < std :: collections :: BTreeSet < String > >> :: ffi_to (obj . binary_paths) , required_fields : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionTo < std :: collections :: BTreeSet < String > >> :: ffi_to (obj . required_fields) , transient_fields : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionTo < std :: collections :: BTreeSet < String > >> :: ffi_to (obj . transient_fields) , documents_keep_history : obj . documents_keep_history , documents_mutable : obj . documents_mutable , documents_can_be_deleted : obj . documents_can_be_deleted , documents_transferable : < crate :: fermented :: types :: dpp :: document :: transfer :: dpp_document_transfer_Transferable as ferment :: FFIConversionTo < dpp :: document :: transfer :: Transferable >> :: ffi_to (obj . documents_transferable) , trade_mode : < crate :: fermented :: types :: dpp :: nft :: dpp_nft_TradeMode as ferment :: FFIConversionTo < dpp :: nft :: TradeMode >> :: ffi_to (obj . trade_mode) , creation_restriction_mode : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode >> :: ffi_to (obj . creation_restriction_mode) , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , requires_identity_encryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionTo < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_to_opt (obj . requires_identity_encryption_bounded_key) , requires_identity_decryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionTo < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_to_opt (obj . requires_identity_decryption_bounded_key) , security_level_requirement : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_to (obj . security_level_requirement) , # [cfg (feature = "validation")] json_schema_validator : ferment :: boxed (obj . json_schema_validator) }) } } impl Drop for dpp_data_contract_document_type_v0_DocumentTypeV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . name) ; ferment :: unbox_any (ffi_ref . schema) ; ferment :: unbox_any (ffi_ref . indices) ; ferment :: unbox_any (ffi_ref . index_structure) ; ferment :: unbox_any (ffi_ref . flattened_properties) ; ferment :: unbox_any (ffi_ref . properties) ; ferment :: unbox_any (ffi_ref . identifier_paths) ; ferment :: unbox_any (ffi_ref . binary_paths) ; ferment :: unbox_any (ffi_ref . required_fields) ; ferment :: unbox_any (ffi_ref . transient_fields) ; ; ; ; ferment :: unbox_any (ffi_ref . documents_transferable) ; ferment :: unbox_any (ffi_ref . trade_mode) ; ferment :: unbox_any (ffi_ref . creation_restriction_mode) ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any_opt (ffi_ref . requires_identity_encryption_bounded_key) ; ferment :: unbox_any_opt (ffi_ref . requires_identity_decryption_bounded_key) ; ferment :: unbox_any (ffi_ref . security_level_requirement) ; # [cfg (feature = "validation")] ferment :: unbox_any (ffi_ref . json_schema_validator) ; } } } } pub mod v1 { use crate as example_platform ; # [doc = "FFI-representation of the [`DocumentTypeV1`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_document_type_v1_DocumentTypeV1 { pub name : * mut std :: os :: raw :: c_char , pub schema : * mut crate :: fermented :: types :: platform_value :: platform_value_Value , pub indices : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index , pub index_structure : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel , pub flattened_properties : * mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty , pub properties : * mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty , pub identifier_paths : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , pub binary_paths : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , pub required_fields : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , pub transient_fields : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , pub documents_keep_history : bool , pub documents_mutable : bool , pub documents_can_be_deleted : bool , pub documents_transferable : * mut crate :: fermented :: types :: dpp :: document :: transfer :: dpp_document_transfer_Transferable , pub trade_mode : * mut crate :: fermented :: types :: dpp :: nft :: dpp_nft_TradeMode , pub creation_restriction_mode : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode , pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub requires_identity_encryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements , pub requires_identity_decryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements , pub security_level_requirement : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel , # [cfg (feature = "validation")] pub json_schema_validator : * mut dpp :: data_contract :: document_type :: validator :: StatelessJsonSchemaLazyValidator , pub token_costs : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: token_costs :: dpp_data_contract_document_type_token_costs_TokenCosts } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: v1 :: DocumentTypeV1 > for dpp_data_contract_document_type_v1_DocumentTypeV1 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_v1_DocumentTypeV1) -> dpp :: data_contract :: document_type :: v1 :: DocumentTypeV1 { let ffi_ref = & * ffi ; dpp :: data_contract :: document_type :: v1 :: DocumentTypeV1 { name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . name) , schema : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (ffi_ref . schema) , indices : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: Index > >> :: ffi_from (ffi_ref . indices) , index_structure : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index_level :: IndexLevel >> :: ffi_from (ffi_ref . index_structure) , flattened_properties : < crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty as ferment :: FFIConversionFrom < indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > >> :: ffi_from (ffi_ref . flattened_properties) , properties : < crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty as ferment :: FFIConversionFrom < indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > >> :: ffi_from (ffi_ref . properties) , identifier_paths : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < String > >> :: ffi_from (ffi_ref . identifier_paths) , binary_paths : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < String > >> :: ffi_from (ffi_ref . binary_paths) , required_fields : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < String > >> :: ffi_from (ffi_ref . required_fields) , transient_fields : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < String > >> :: ffi_from (ffi_ref . transient_fields) , documents_keep_history : ffi_ref . documents_keep_history , documents_mutable : ffi_ref . documents_mutable , documents_can_be_deleted : ffi_ref . documents_can_be_deleted , documents_transferable : < crate :: fermented :: types :: dpp :: document :: transfer :: dpp_document_transfer_Transferable as ferment :: FFIConversionFrom < dpp :: document :: transfer :: Transferable >> :: ffi_from (ffi_ref . documents_transferable) , trade_mode : < crate :: fermented :: types :: dpp :: nft :: dpp_nft_TradeMode as ferment :: FFIConversionFrom < dpp :: nft :: TradeMode >> :: ffi_from (ffi_ref . trade_mode) , creation_restriction_mode : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode >> :: ffi_from (ffi_ref . creation_restriction_mode) , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , requires_identity_encryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionFrom < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_from_opt (ffi_ref . requires_identity_encryption_bounded_key) , requires_identity_decryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionFrom < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_from_opt (ffi_ref . requires_identity_decryption_bounded_key) , security_level_requirement : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_from (ffi_ref . security_level_requirement) , # [cfg (feature = "validation")] json_schema_validator : std :: ptr :: read (ffi_ref . json_schema_validator) , token_costs : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: token_costs :: dpp_data_contract_document_type_token_costs_TokenCosts as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: token_costs :: TokenCosts >> :: ffi_from (ffi_ref . token_costs) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: v1 :: DocumentTypeV1 > for dpp_data_contract_document_type_v1_DocumentTypeV1 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: v1 :: DocumentTypeV1) -> * const dpp_data_contract_document_type_v1_DocumentTypeV1 { ferment :: boxed (dpp_data_contract_document_type_v1_DocumentTypeV1 { name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . name) , schema : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (obj . schema) , indices : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index as ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: Index > >> :: ffi_to (obj . indices) , index_structure : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index_level :: IndexLevel >> :: ffi_to (obj . index_structure) , flattened_properties : < crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty as ferment :: FFIConversionTo < indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > >> :: ffi_to (obj . flattened_properties) , properties : < crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty as ferment :: FFIConversionTo < indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > >> :: ffi_to (obj . properties) , identifier_paths : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionTo < std :: collections :: BTreeSet < String > >> :: ffi_to (obj . identifier_paths) , binary_paths : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionTo < std :: collections :: BTreeSet < String > >> :: ffi_to (obj . binary_paths) , required_fields : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionTo < std :: collections :: BTreeSet < String > >> :: ffi_to (obj . required_fields) , transient_fields : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionTo < std :: collections :: BTreeSet < String > >> :: ffi_to (obj . transient_fields) , documents_keep_history : obj . documents_keep_history , documents_mutable : obj . documents_mutable , documents_can_be_deleted : obj . documents_can_be_deleted , documents_transferable : < crate :: fermented :: types :: dpp :: document :: transfer :: dpp_document_transfer_Transferable as ferment :: FFIConversionTo < dpp :: document :: transfer :: Transferable >> :: ffi_to (obj . documents_transferable) , trade_mode : < crate :: fermented :: types :: dpp :: nft :: dpp_nft_TradeMode as ferment :: FFIConversionTo < dpp :: nft :: TradeMode >> :: ffi_to (obj . trade_mode) , creation_restriction_mode : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode >> :: ffi_to (obj . creation_restriction_mode) , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , requires_identity_encryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionTo < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_to_opt (obj . requires_identity_encryption_bounded_key) , requires_identity_decryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionTo < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_to_opt (obj . requires_identity_decryption_bounded_key) , security_level_requirement : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_to (obj . security_level_requirement) , # [cfg (feature = "validation")] json_schema_validator : ferment :: boxed (obj . json_schema_validator) , token_costs : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: token_costs :: dpp_data_contract_document_type_token_costs_TokenCosts as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: token_costs :: TokenCosts >> :: ffi_to (obj . token_costs) }) } } impl Drop for dpp_data_contract_document_type_v1_DocumentTypeV1 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . name) ; ferment :: unbox_any (ffi_ref . schema) ; ferment :: unbox_any (ffi_ref . indices) ; ferment :: unbox_any (ffi_ref . index_structure) ; ferment :: unbox_any (ffi_ref . flattened_properties) ; ferment :: unbox_any (ffi_ref . properties) ; ferment :: unbox_any (ffi_ref . identifier_paths) ; ferment :: unbox_any (ffi_ref . binary_paths) ; ferment :: unbox_any (ffi_ref . required_fields) ; ferment :: unbox_any (ffi_ref . transient_fields) ; ; ; ; ferment :: unbox_any (ffi_ref . documents_transferable) ; ferment :: unbox_any (ffi_ref . trade_mode) ; ferment :: unbox_any (ffi_ref . creation_restriction_mode) ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any_opt (ffi_ref . requires_identity_encryption_bounded_key) ; ferment :: unbox_any_opt (ffi_ref . requires_identity_decryption_bounded_key) ; ferment :: unbox_any (ffi_ref . security_level_requirement) ; # [cfg (feature = "validation")] ferment :: unbox_any (ffi_ref . json_schema_validator) ; ferment :: unbox_any (ffi_ref . token_costs) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentTypeRef`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_document_type_DocumentTypeRef { V0 (* mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: v0 :: dpp_data_contract_document_type_v0_DocumentTypeV0) , V1 (* mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: v1 :: dpp_data_contract_document_type_v1_DocumentTypeV1) } impl < 'a , > ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: DocumentTypeRef < 'a > > for dpp_data_contract_document_type_DocumentTypeRef { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_DocumentTypeRef) -> dpp :: data_contract :: document_type :: DocumentTypeRef < 'a > { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_document_type_DocumentTypeRef :: V0 (o_0) => dpp :: data_contract :: document_type :: DocumentTypeRef :: V0 (Box :: leak (Box :: new (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: v0 :: dpp_data_contract_document_type_v0_DocumentTypeV0 as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: v0 :: DocumentTypeV0 >> :: ffi_from (* o_0)))) , dpp_data_contract_document_type_DocumentTypeRef :: V1 (o_0) => dpp :: data_contract :: document_type :: DocumentTypeRef :: V1 (Box :: leak (Box :: new (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: v1 :: dpp_data_contract_document_type_v1_DocumentTypeV1 as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: v1 :: DocumentTypeV1 >> :: ffi_from (* o_0)))) } } } impl < 'a , > ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: DocumentTypeRef < 'a > > for dpp_data_contract_document_type_DocumentTypeRef { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: DocumentTypeRef < 'a >) -> * const dpp_data_contract_document_type_DocumentTypeRef { ferment :: boxed (match obj { dpp :: data_contract :: document_type :: DocumentTypeRef :: V0 (o_0) => dpp_data_contract_document_type_DocumentTypeRef :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: v0 :: dpp_data_contract_document_type_v0_DocumentTypeV0 as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: v0 :: DocumentTypeV0 >> :: ffi_to (o_0 . clone ())) , dpp :: data_contract :: document_type :: DocumentTypeRef :: V1 (o_0) => dpp_data_contract_document_type_DocumentTypeRef :: V1 (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: v1 :: dpp_data_contract_document_type_v1_DocumentTypeV1 as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: v1 :: DocumentTypeV1 >> :: ffi_to (o_0 . clone ())) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_document_type_DocumentTypeRef { fn drop (& mut self) { unsafe { match self { dpp_data_contract_document_type_DocumentTypeRef :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_document_type_DocumentTypeRef :: V1 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_document_type_DocumentType { V0 (* mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: v0 :: dpp_data_contract_document_type_v0_DocumentTypeV0) , V1 (* mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: v1 :: dpp_data_contract_document_type_v1_DocumentTypeV1) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: DocumentType > for dpp_data_contract_document_type_DocumentType { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_DocumentType) -> dpp :: data_contract :: document_type :: DocumentType { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_document_type_DocumentType :: V0 (o_0) => dpp :: data_contract :: document_type :: DocumentType :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: v0 :: dpp_data_contract_document_type_v0_DocumentTypeV0 as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: v0 :: DocumentTypeV0 >> :: ffi_from (* o_0)) , dpp_data_contract_document_type_DocumentType :: V1 (o_0) => dpp :: data_contract :: document_type :: DocumentType :: V1 (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: v1 :: dpp_data_contract_document_type_v1_DocumentTypeV1 as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: v1 :: DocumentTypeV1 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: DocumentType > for dpp_data_contract_document_type_DocumentType { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: DocumentType) -> * const dpp_data_contract_document_type_DocumentType { ferment :: boxed (match obj { dpp :: data_contract :: document_type :: DocumentType :: V0 (o_0) => dpp_data_contract_document_type_DocumentType :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: v0 :: dpp_data_contract_document_type_v0_DocumentTypeV0 as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: v0 :: DocumentTypeV0 >> :: ffi_to (o_0)) , dpp :: data_contract :: document_type :: DocumentType :: V1 (o_0) => dpp_data_contract_document_type_DocumentType :: V1 (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: v1 :: dpp_data_contract_document_type_v1_DocumentTypeV1 as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: v1 :: DocumentTypeV1 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_document_type_DocumentType { fn drop (& mut self) { unsafe { match self { dpp_data_contract_document_type_DocumentType :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_document_type_DocumentType :: V1 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod v0 { pub mod data_contract { use crate as example_platform ; # [doc = "FFI-representation of the [`DataContractV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_v0_data_contract_DataContractV0 { pub id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub version : u32 , pub owner_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub document_types : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType , pub metadata : * mut crate :: fermented :: types :: dpp :: metadata :: dpp_metadata_Metadata , pub config : * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig , pub schema_defs : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value } impl ferment :: FFIConversionFrom < dpp :: data_contract :: v0 :: data_contract :: DataContractV0 > for dpp_data_contract_v0_data_contract_DataContractV0 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_v0_data_contract_DataContractV0) -> dpp :: data_contract :: v0 :: data_contract :: DataContractV0 { let ffi_ref = & * ffi ; dpp :: data_contract :: v0 :: data_contract :: DataContractV0 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . id) , version : ffi_ref . version , owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . owner_id) , document_types : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , dpp :: data_contract :: document_type :: DocumentType > >> :: ffi_from (ffi_ref . document_types) , metadata : < crate :: fermented :: types :: dpp :: metadata :: dpp_metadata_Metadata as ferment :: FFIConversionFrom < dpp :: metadata :: Metadata >> :: ffi_from_opt (ffi_ref . metadata) , config : < crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig as ferment :: FFIConversionFrom < dpp :: data_contract :: config :: DataContractConfig >> :: ffi_from (ffi_ref . config) , schema_defs : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > >> :: ffi_from_opt (ffi_ref . schema_defs) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: v0 :: data_contract :: DataContractV0 > for dpp_data_contract_v0_data_contract_DataContractV0 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: v0 :: data_contract :: DataContractV0) -> * const dpp_data_contract_v0_data_contract_DataContractV0 { ferment :: boxed (dpp_data_contract_v0_data_contract_DataContractV0 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . id) , version : obj . version , owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . owner_id) , document_types : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , dpp :: data_contract :: document_type :: DocumentType > >> :: ffi_to (obj . document_types) , metadata : < crate :: fermented :: types :: dpp :: metadata :: dpp_metadata_Metadata as ferment :: FFIConversionTo < dpp :: metadata :: Metadata >> :: ffi_to_opt (obj . metadata) , config : < crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig as ferment :: FFIConversionTo < dpp :: data_contract :: config :: DataContractConfig >> :: ffi_to (obj . config) , schema_defs : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > >> :: ffi_to_opt (obj . schema_defs) }) } } impl Drop for dpp_data_contract_v0_data_contract_DataContractV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; ; ferment :: unbox_any (ffi_ref . owner_id) ; ferment :: unbox_any (ffi_ref . document_types) ; ferment :: unbox_any_opt (ffi_ref . metadata) ; ferment :: unbox_any (ffi_ref . config) ; ferment :: unbox_any_opt (ffi_ref . schema_defs) ; } } } } } pub mod v1 { pub mod data_contract { use crate as example_platform ; # [doc = "FFI-representation of the [`DataContractV1`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_v1_data_contract_DataContractV1 { pub id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub version : u32 , pub owner_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub document_types : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType , pub config : * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig , pub schema_defs : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value , pub created_at : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis , pub updated_at : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis , pub created_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , pub updated_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , pub created_at_epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex , pub updated_at_epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex , pub groups : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group , pub tokens : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration , pub keywords : * mut crate :: fermented :: generics :: Vec_String , pub description : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: data_contract :: v1 :: data_contract :: DataContractV1 > for dpp_data_contract_v1_data_contract_DataContractV1 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_v1_data_contract_DataContractV1) -> dpp :: data_contract :: v1 :: data_contract :: DataContractV1 { let ffi_ref = & * ffi ; dpp :: data_contract :: v1 :: data_contract :: DataContractV1 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . id) , version : ffi_ref . version , owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . owner_id) , document_types : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , dpp :: data_contract :: document_type :: DocumentType > >> :: ffi_from (ffi_ref . document_types) , config : < crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig as ferment :: FFIConversionFrom < dpp :: data_contract :: config :: DataContractConfig >> :: ffi_from (ffi_ref . config) , schema_defs : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > >> :: ffi_from_opt (ffi_ref . schema_defs) , created_at : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_from_opt (ffi_ref . created_at) , updated_at : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_from_opt (ffi_ref . updated_at) , created_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: BlockHeight >> :: ffi_from_opt (ffi_ref . created_at_block_height) , updated_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: BlockHeight >> :: ffi_from_opt (ffi_ref . updated_at_block_height) , created_at_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionFrom < dpp :: block :: epoch :: EpochIndex >> :: ffi_from_opt (ffi_ref . created_at_epoch) , updated_at_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionFrom < dpp :: block :: epoch :: EpochIndex >> :: ffi_from_opt (ffi_ref . updated_at_epoch) , groups : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: GroupContractPosition , dpp :: data_contract :: group :: Group > >> :: ffi_from (ffi_ref . groups) , tokens : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: TokenContractPosition , dpp :: data_contract :: associated_token :: token_configuration :: TokenConfiguration > >> :: ffi_from (ffi_ref . tokens) , keywords : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionFrom < Vec < String > >> :: ffi_from (ffi_ref . keywords) , description : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . description) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: v1 :: data_contract :: DataContractV1 > for dpp_data_contract_v1_data_contract_DataContractV1 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: v1 :: data_contract :: DataContractV1) -> * const dpp_data_contract_v1_data_contract_DataContractV1 { ferment :: boxed (dpp_data_contract_v1_data_contract_DataContractV1 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . id) , version : obj . version , owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . owner_id) , document_types : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , dpp :: data_contract :: document_type :: DocumentType > >> :: ffi_to (obj . document_types) , config : < crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig as ferment :: FFIConversionTo < dpp :: data_contract :: config :: DataContractConfig >> :: ffi_to (obj . config) , schema_defs : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > >> :: ffi_to_opt (obj . schema_defs) , created_at : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_to_opt (obj . created_at) , updated_at : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_to_opt (obj . updated_at) , created_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: BlockHeight >> :: ffi_to_opt (obj . created_at_block_height) , updated_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: BlockHeight >> :: ffi_to_opt (obj . updated_at_block_height) , created_at_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionTo < dpp :: block :: epoch :: EpochIndex >> :: ffi_to_opt (obj . created_at_epoch) , updated_at_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionTo < dpp :: block :: epoch :: EpochIndex >> :: ffi_to_opt (obj . updated_at_epoch) , groups : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: GroupContractPosition , dpp :: data_contract :: group :: Group > >> :: ffi_to (obj . groups) , tokens : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: TokenContractPosition , dpp :: data_contract :: associated_token :: token_configuration :: TokenConfiguration > >> :: ffi_to (obj . tokens) , keywords : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionTo < Vec < String > >> :: ffi_to (obj . keywords) , description : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . description) }) } } impl Drop for dpp_data_contract_v1_data_contract_DataContractV1 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; ; ferment :: unbox_any (ffi_ref . owner_id) ; ferment :: unbox_any (ffi_ref . document_types) ; ferment :: unbox_any (ffi_ref . config) ; ferment :: unbox_any_opt (ffi_ref . schema_defs) ; ferment :: unbox_any_opt (ffi_ref . created_at) ; ferment :: unbox_any_opt (ffi_ref . updated_at) ; ferment :: unbox_any_opt (ffi_ref . created_at_block_height) ; ferment :: unbox_any_opt (ffi_ref . updated_at_block_height) ; ferment :: unbox_any_opt (ffi_ref . created_at_epoch) ; ferment :: unbox_any_opt (ffi_ref . updated_at_epoch) ; ferment :: unbox_any (ffi_ref . groups) ; ferment :: unbox_any (ffi_ref . tokens) ; ferment :: unbox_any (ffi_ref . keywords) ; ferment :: unbox_any_opt (ffi_ref . description) ; } } } } } pub mod serialized_version { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`DataContractInSerializationFormatV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 { pub id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub config : * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig , pub version : u32 , pub owner_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub schema_defs : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value , pub document_schemas : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value } impl ferment :: FFIConversionFrom < dpp :: data_contract :: serialized_version :: v0 :: DataContractInSerializationFormatV0 > for dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0) -> dpp :: data_contract :: serialized_version :: v0 :: DataContractInSerializationFormatV0 { let ffi_ref = & * ffi ; dpp :: data_contract :: serialized_version :: v0 :: DataContractInSerializationFormatV0 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . id) , config : < crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig as ferment :: FFIConversionFrom < dpp :: data_contract :: config :: DataContractConfig >> :: ffi_from (ffi_ref . config) , version : ffi_ref . version , owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . owner_id) , schema_defs : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > >> :: ffi_from_opt (ffi_ref . schema_defs) , document_schemas : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , platform_value :: Value > >> :: ffi_from (ffi_ref . document_schemas) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: serialized_version :: v0 :: DataContractInSerializationFormatV0 > for dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: serialized_version :: v0 :: DataContractInSerializationFormatV0) -> * const dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 { ferment :: boxed (dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . id) , config : < crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig as ferment :: FFIConversionTo < dpp :: data_contract :: config :: DataContractConfig >> :: ffi_to (obj . config) , version : obj . version , owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . owner_id) , schema_defs : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > >> :: ffi_to_opt (obj . schema_defs) , document_schemas : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , platform_value :: Value > >> :: ffi_to (obj . document_schemas) }) } } impl Drop for dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; ferment :: unbox_any (ffi_ref . config) ; ; ferment :: unbox_any (ffi_ref . owner_id) ; ferment :: unbox_any_opt (ffi_ref . schema_defs) ; ferment :: unbox_any (ffi_ref . document_schemas) ; } } } } pub mod v1 { use crate as example_platform ; # [doc = "FFI-representation of the [`DataContractInSerializationFormatV1`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 { pub id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub config : * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig , pub version : u32 , pub owner_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub schema_defs : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value , pub document_schemas : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value , pub created_at : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis , pub updated_at : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis , pub created_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , pub updated_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , pub created_at_epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex , pub updated_at_epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex , pub groups : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group , pub tokens : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration , pub keywords : * mut crate :: fermented :: generics :: Vec_String , pub description : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: data_contract :: serialized_version :: v1 :: DataContractInSerializationFormatV1 > for dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> dpp :: data_contract :: serialized_version :: v1 :: DataContractInSerializationFormatV1 { let ffi_ref = & * ffi ; dpp :: data_contract :: serialized_version :: v1 :: DataContractInSerializationFormatV1 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . id) , config : < crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig as ferment :: FFIConversionFrom < dpp :: data_contract :: config :: DataContractConfig >> :: ffi_from (ffi_ref . config) , version : ffi_ref . version , owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . owner_id) , schema_defs : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > >> :: ffi_from_opt (ffi_ref . schema_defs) , document_schemas : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , platform_value :: Value > >> :: ffi_from (ffi_ref . document_schemas) , created_at : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_from_opt (ffi_ref . created_at) , updated_at : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_from_opt (ffi_ref . updated_at) , created_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: BlockHeight >> :: ffi_from_opt (ffi_ref . created_at_block_height) , updated_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: BlockHeight >> :: ffi_from_opt (ffi_ref . updated_at_block_height) , created_at_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionFrom < dpp :: block :: epoch :: EpochIndex >> :: ffi_from_opt (ffi_ref . created_at_epoch) , updated_at_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionFrom < dpp :: block :: epoch :: EpochIndex >> :: ffi_from_opt (ffi_ref . updated_at_epoch) , groups : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: GroupContractPosition , dpp :: data_contract :: group :: Group > >> :: ffi_from (ffi_ref . groups) , tokens : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: TokenContractPosition , dpp :: data_contract :: associated_token :: token_configuration :: TokenConfiguration > >> :: ffi_from (ffi_ref . tokens) , keywords : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionFrom < Vec < String > >> :: ffi_from (ffi_ref . keywords) , description : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . description) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: serialized_version :: v1 :: DataContractInSerializationFormatV1 > for dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: serialized_version :: v1 :: DataContractInSerializationFormatV1) -> * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 { ferment :: boxed (dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . id) , config : < crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig as ferment :: FFIConversionTo < dpp :: data_contract :: config :: DataContractConfig >> :: ffi_to (obj . config) , version : obj . version , owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . owner_id) , schema_defs : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > >> :: ffi_to_opt (obj . schema_defs) , document_schemas : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , platform_value :: Value > >> :: ffi_to (obj . document_schemas) , created_at : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_to_opt (obj . created_at) , updated_at : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_to_opt (obj . updated_at) , created_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: BlockHeight >> :: ffi_to_opt (obj . created_at_block_height) , updated_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: BlockHeight >> :: ffi_to_opt (obj . updated_at_block_height) , created_at_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionTo < dpp :: block :: epoch :: EpochIndex >> :: ffi_to_opt (obj . created_at_epoch) , updated_at_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionTo < dpp :: block :: epoch :: EpochIndex >> :: ffi_to_opt (obj . updated_at_epoch) , groups : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: GroupContractPosition , dpp :: data_contract :: group :: Group > >> :: ffi_to (obj . groups) , tokens : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: TokenContractPosition , dpp :: data_contract :: associated_token :: token_configuration :: TokenConfiguration > >> :: ffi_to (obj . tokens) , keywords : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionTo < Vec < String > >> :: ffi_to (obj . keywords) , description : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . description) }) } } impl Drop for dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; ferment :: unbox_any (ffi_ref . config) ; ; ferment :: unbox_any (ffi_ref . owner_id) ; ferment :: unbox_any_opt (ffi_ref . schema_defs) ; ferment :: unbox_any (ffi_ref . document_schemas) ; ferment :: unbox_any_opt (ffi_ref . created_at) ; ferment :: unbox_any_opt (ffi_ref . updated_at) ; ferment :: unbox_any_opt (ffi_ref . created_at_block_height) ; ferment :: unbox_any_opt (ffi_ref . updated_at_block_height) ; ferment :: unbox_any_opt (ffi_ref . created_at_epoch) ; ferment :: unbox_any_opt (ffi_ref . updated_at_epoch) ; ferment :: unbox_any (ffi_ref . groups) ; ferment :: unbox_any (ffi_ref . tokens) ; ferment :: unbox_any (ffi_ref . keywords) ; ferment :: unbox_any_opt (ffi_ref . description) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DataContractInSerializationFormat`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_serialized_version_DataContractInSerializationFormat { V0 (* mut crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: v0 :: dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0) , V1 (* mut crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: v1 :: dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat > for dpp_data_contract_serialized_version_DataContractInSerializationFormat { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_serialized_version_DataContractInSerializationFormat) -> dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_serialized_version_DataContractInSerializationFormat :: V0 (o_0) => dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: v0 :: dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 as ferment :: FFIConversionFrom < dpp :: data_contract :: serialized_version :: v0 :: DataContractInSerializationFormatV0 >> :: ffi_from (* o_0)) , dpp_data_contract_serialized_version_DataContractInSerializationFormat :: V1 (o_0) => dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat :: V1 (< crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: v1 :: dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 as ferment :: FFIConversionFrom < dpp :: data_contract :: serialized_version :: v1 :: DataContractInSerializationFormatV1 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat > for dpp_data_contract_serialized_version_DataContractInSerializationFormat { unsafe fn ffi_to_const (obj : dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat) -> * const dpp_data_contract_serialized_version_DataContractInSerializationFormat { ferment :: boxed (match obj { dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat :: V0 (o_0) => dpp_data_contract_serialized_version_DataContractInSerializationFormat :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: v0 :: dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 as ferment :: FFIConversionTo < dpp :: data_contract :: serialized_version :: v0 :: DataContractInSerializationFormatV0 >> :: ffi_to (o_0)) , dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat :: V1 (o_0) => dpp_data_contract_serialized_version_DataContractInSerializationFormat :: V1 (< crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: v1 :: dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 as ferment :: FFIConversionTo < dpp :: data_contract :: serialized_version :: v1 :: DataContractInSerializationFormatV1 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_serialized_version_DataContractInSerializationFormat { fn drop (& mut self) { unsafe { match self { dpp_data_contract_serialized_version_DataContractInSerializationFormat :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_serialized_version_DataContractInSerializationFormat :: V1 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod associated_token { pub mod token_configuration_convention { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`TokenConfigurationConventionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0 { pub localizations : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization , pub decimals : u8 } impl ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_configuration_convention :: v0 :: TokenConfigurationConventionV0 > for dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0) -> dpp :: data_contract :: associated_token :: token_configuration_convention :: v0 :: TokenConfigurationConventionV0 { let ffi_ref = & * ffi ; dpp :: data_contract :: associated_token :: token_configuration_convention :: v0 :: TokenConfigurationConventionV0 { localizations : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization > >> :: ffi_from (ffi_ref . localizations) , decimals : ffi_ref . decimals } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_configuration_convention :: v0 :: TokenConfigurationConventionV0 > for dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: associated_token :: token_configuration_convention :: v0 :: TokenConfigurationConventionV0) -> * const dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0 { ferment :: boxed (dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0 { localizations : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization as ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization > >> :: ffi_to (obj . localizations) , decimals : obj . decimals }) } } impl Drop for dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . localizations) ; ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenConfigurationConvention`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention { V0 (* mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_convention :: v0 :: dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_configuration_convention :: TokenConfigurationConvention > for dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention) -> dpp :: data_contract :: associated_token :: token_configuration_convention :: TokenConfigurationConvention { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention :: V0 (o_0) => dpp :: data_contract :: associated_token :: token_configuration_convention :: TokenConfigurationConvention :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_convention :: v0 :: dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0 as ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_configuration_convention :: v0 :: TokenConfigurationConventionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_configuration_convention :: TokenConfigurationConvention > for dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention { unsafe fn ffi_to_const (obj : dpp :: data_contract :: associated_token :: token_configuration_convention :: TokenConfigurationConvention) -> * const dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention { ferment :: boxed (match obj { dpp :: data_contract :: associated_token :: token_configuration_convention :: TokenConfigurationConvention :: V0 (o_0) => dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_convention :: v0 :: dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0 as ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_configuration_convention :: v0 :: TokenConfigurationConventionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention { fn drop (& mut self) { unsafe { match self { dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod token_configuration_localization { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`TokenConfigurationLocalizationV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0 { pub should_capitalize : bool , pub singular_form : * mut std :: os :: raw :: c_char , pub plural_form : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_configuration_localization :: v0 :: TokenConfigurationLocalizationV0 > for dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0) -> dpp :: data_contract :: associated_token :: token_configuration_localization :: v0 :: TokenConfigurationLocalizationV0 { let ffi_ref = & * ffi ; dpp :: data_contract :: associated_token :: token_configuration_localization :: v0 :: TokenConfigurationLocalizationV0 { should_capitalize : ffi_ref . should_capitalize , singular_form : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . singular_form) , plural_form : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . plural_form) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_configuration_localization :: v0 :: TokenConfigurationLocalizationV0 > for dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: associated_token :: token_configuration_localization :: v0 :: TokenConfigurationLocalizationV0) -> * const dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0 { ferment :: boxed (dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0 { should_capitalize : obj . should_capitalize , singular_form : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . singular_form) , plural_form : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . plural_form) }) } } impl Drop for dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_string (ffi_ref . singular_form) ; ferment :: unbox_string (ffi_ref . plural_form) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenConfigurationLocalization`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { V0 (* mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_localization :: v0 :: dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization > for dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization) -> dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization :: V0 (o_0) => dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_localization :: v0 :: dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0 as ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_configuration_localization :: v0 :: TokenConfigurationLocalizationV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization > for dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { unsafe fn ffi_to_const (obj : dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization) -> * const dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { ferment :: boxed (match obj { dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization :: V0 (o_0) => dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_localization :: v0 :: dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0 as ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_configuration_localization :: v0 :: TokenConfigurationLocalizationV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { fn drop (& mut self) { unsafe { match self { dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod token_distribution_key { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenDistributionType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType { PreProgrammed = 0 , Perpetual = 1 } impl ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_distribution_key :: TokenDistributionType > for dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType) -> dpp :: data_contract :: associated_token :: token_distribution_key :: TokenDistributionType { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType :: PreProgrammed => dpp :: data_contract :: associated_token :: token_distribution_key :: TokenDistributionType :: PreProgrammed , dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType :: Perpetual => dpp :: data_contract :: associated_token :: token_distribution_key :: TokenDistributionType :: Perpetual } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_distribution_key :: TokenDistributionType > for dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType { unsafe fn ffi_to_const (obj : dpp :: data_contract :: associated_token :: token_distribution_key :: TokenDistributionType) -> * const dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType { ferment :: boxed (match obj { dpp :: data_contract :: associated_token :: token_distribution_key :: TokenDistributionType :: PreProgrammed => dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType :: PreProgrammed , dpp :: data_contract :: associated_token :: token_distribution_key :: TokenDistributionType :: Perpetual => dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType :: Perpetual , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType { fn drop (& mut self) { unsafe { match self { dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType :: PreProgrammed => { } , dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType :: Perpetual => { } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod token_perpetual_distribution { pub mod distribution_function { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DistributionFunction`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { FixedAmount { amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount } , Random { min : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , max : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount } , StepDecreasingAmount { step_count : u32 , decrease_per_interval_numerator : u16 , decrease_per_interval_denominator : u16 , start_decreasing_offset : * mut u64 , max_interval_count : * mut u16 , distribution_start_amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , trailing_distribution_interval_amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , min_value : * mut u64 } , Stepwise (* mut crate :: fermented :: generics :: std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount) , Linear { a : i64 , d : u64 , start_step : * mut u64 , starting_amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , min_value : * mut u64 , max_value : * mut u64 } , Polynomial { a : i64 , d : u64 , m : i64 , n : u64 , o : i64 , start_moment : * mut u64 , b : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , min_value : * mut u64 , max_value : * mut u64 } , Exponential { a : u64 , d : u64 , m : i64 , n : u64 , o : i64 , start_moment : * mut u64 , b : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , min_value : * mut u64 , max_value : * mut u64 } , Logarithmic { a : i64 , d : u64 , m : u64 , n : u64 , o : i64 , start_moment : * mut u64 , b : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , min_value : * mut u64 , max_value : * mut u64 } , InvertedLogarithmic { a : i64 , d : u64 , m : u64 , n : u64 , o : i64 , start_moment : * mut u64 , b : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , min_value : * mut u64 , max_value : * mut u64 } } impl ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction > for dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction) -> dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: FixedAmount { amount } => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: FixedAmount { amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (* amount) } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Random { min , max } => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Random { min : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (* min) , max : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (* max) } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: StepDecreasingAmount { step_count , decrease_per_interval_numerator , decrease_per_interval_denominator , start_decreasing_offset , max_interval_count , distribution_start_amount , trailing_distribution_interval_amount , min_value } => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: StepDecreasingAmount { step_count : * step_count , decrease_per_interval_numerator : * decrease_per_interval_numerator , decrease_per_interval_denominator : * decrease_per_interval_denominator , start_decreasing_offset : ferment :: from_opt_primitive (* start_decreasing_offset) , max_interval_count : ferment :: from_opt_primitive (* max_interval_count) , distribution_start_amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (* distribution_start_amount) , trailing_distribution_interval_amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (* trailing_distribution_interval_amount) , min_value : ferment :: from_opt_primitive (* min_value) } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Stepwise (o_0) => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Stepwise (< crate :: fermented :: generics :: std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u64 , dpp :: balances :: credits :: TokenAmount > >> :: ffi_from (* o_0)) , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Linear { a , d , start_step , starting_amount , min_value , max_value } => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Linear { a : * a , d : * d , start_step : ferment :: from_opt_primitive (* start_step) , starting_amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (* starting_amount) , min_value : ferment :: from_opt_primitive (* min_value) , max_value : ferment :: from_opt_primitive (* max_value) } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Polynomial { a , d , m , n , o , start_moment , b , min_value , max_value } => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Polynomial { a : * a , d : * d , m : * m , n : * n , o : * o , start_moment : ferment :: from_opt_primitive (* start_moment) , b : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (* b) , min_value : ferment :: from_opt_primitive (* min_value) , max_value : ferment :: from_opt_primitive (* max_value) } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Exponential { a , d , m , n , o , start_moment , b , min_value , max_value } => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Exponential { a : * a , d : * d , m : * m , n : * n , o : * o , start_moment : ferment :: from_opt_primitive (* start_moment) , b : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (* b) , min_value : ferment :: from_opt_primitive (* min_value) , max_value : ferment :: from_opt_primitive (* max_value) } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Logarithmic { a , d , m , n , o , start_moment , b , min_value , max_value } => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Logarithmic { a : * a , d : * d , m : * m , n : * n , o : * o , start_moment : ferment :: from_opt_primitive (* start_moment) , b : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (* b) , min_value : ferment :: from_opt_primitive (* min_value) , max_value : ferment :: from_opt_primitive (* max_value) } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: InvertedLogarithmic { a , d , m , n , o , start_moment , b , min_value , max_value } => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: InvertedLogarithmic { a : * a , d : * d , m : * m , n : * n , o : * o , start_moment : ferment :: from_opt_primitive (* start_moment) , b : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (* b) , min_value : ferment :: from_opt_primitive (* min_value) , max_value : ferment :: from_opt_primitive (* max_value) } } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction > for dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { unsafe fn ffi_to_const (obj : dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction) -> * const dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { ferment :: boxed (match obj { dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: FixedAmount { amount } => dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: FixedAmount { amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (amount) } , dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Random { min , max } => dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Random { min : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (min) , max : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (max) } , dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: StepDecreasingAmount { step_count , decrease_per_interval_numerator , decrease_per_interval_denominator , start_decreasing_offset , max_interval_count , distribution_start_amount , trailing_distribution_interval_amount , min_value } => dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: StepDecreasingAmount { step_count : step_count , decrease_per_interval_numerator : decrease_per_interval_numerator , decrease_per_interval_denominator : decrease_per_interval_denominator , start_decreasing_offset : ferment :: to_opt_primitive (start_decreasing_offset) , max_interval_count : ferment :: to_opt_primitive (max_interval_count) , distribution_start_amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (distribution_start_amount) , trailing_distribution_interval_amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (trailing_distribution_interval_amount) , min_value : ferment :: to_opt_primitive (min_value) } , dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Stepwise (o_0) => dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Stepwise (< crate :: fermented :: generics :: std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < std :: collections :: BTreeMap < u64 , dpp :: balances :: credits :: TokenAmount > >> :: ffi_to (o_0)) , dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Linear { a , d , start_step , starting_amount , min_value , max_value } => dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Linear { a : a , d : d , start_step : ferment :: to_opt_primitive (start_step) , starting_amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (starting_amount) , min_value : ferment :: to_opt_primitive (min_value) , max_value : ferment :: to_opt_primitive (max_value) } , dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Polynomial { a , d , m , n , o , start_moment , b , min_value , max_value } => dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Polynomial { a : a , d : d , m : m , n : n , o : o , start_moment : ferment :: to_opt_primitive (start_moment) , b : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (b) , min_value : ferment :: to_opt_primitive (min_value) , max_value : ferment :: to_opt_primitive (max_value) } , dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Exponential { a , d , m , n , o , start_moment , b , min_value , max_value } => dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Exponential { a : a , d : d , m : m , n : n , o : o , start_moment : ferment :: to_opt_primitive (start_moment) , b : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (b) , min_value : ferment :: to_opt_primitive (min_value) , max_value : ferment :: to_opt_primitive (max_value) } , dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Logarithmic { a , d , m , n , o , start_moment , b , min_value , max_value } => dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Logarithmic { a : a , d : d , m : m , n : n , o : o , start_moment : ferment :: to_opt_primitive (start_moment) , b : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (b) , min_value : ferment :: to_opt_primitive (min_value) , max_value : ferment :: to_opt_primitive (max_value) } , dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: InvertedLogarithmic { a , d , m , n , o , start_moment , b , min_value , max_value } => dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: InvertedLogarithmic { a : a , d : d , m : m , n : n , o : o , start_moment : ferment :: to_opt_primitive (start_moment) , b : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (b) , min_value : ferment :: to_opt_primitive (min_value) , max_value : ferment :: to_opt_primitive (max_value) } , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { fn drop (& mut self) { unsafe { match self { dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: FixedAmount { amount } => { ferment :: unbox_any (* amount) ; } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Random { min , max } => { ferment :: unbox_any (* min) ; ; ferment :: unbox_any (* max) ; } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: StepDecreasingAmount { step_count , decrease_per_interval_numerator , decrease_per_interval_denominator , start_decreasing_offset , max_interval_count , distribution_start_amount , trailing_distribution_interval_amount , min_value } => { ; ; ; ; ; ; ferment :: unbox_any_opt (* start_decreasing_offset) ; ; ferment :: unbox_any_opt (* max_interval_count) ; ; ferment :: unbox_any (* distribution_start_amount) ; ; ferment :: unbox_any (* trailing_distribution_interval_amount) ; ; ferment :: unbox_any_opt (* min_value) ; } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Stepwise (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Linear { a , d , start_step , starting_amount , min_value , max_value } => { ; ; ; ; ferment :: unbox_any_opt (* start_step) ; ; ferment :: unbox_any (* starting_amount) ; ; ferment :: unbox_any_opt (* min_value) ; ; ferment :: unbox_any_opt (* max_value) ; } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Polynomial { a , d , m , n , o , start_moment , b , min_value , max_value } => { ; ; ; ; ; ; ; ; ; ; ferment :: unbox_any_opt (* start_moment) ; ; ferment :: unbox_any (* b) ; ; ferment :: unbox_any_opt (* min_value) ; ; ferment :: unbox_any_opt (* max_value) ; } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Exponential { a , d , m , n , o , start_moment , b , min_value , max_value } => { ; ; ; ; ; ; ; ; ; ; ferment :: unbox_any_opt (* start_moment) ; ; ferment :: unbox_any (* b) ; ; ferment :: unbox_any_opt (* min_value) ; ; ferment :: unbox_any_opt (* max_value) ; } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Logarithmic { a , d , m , n , o , start_moment , b , min_value , max_value } => { ; ; ; ; ; ; ; ; ; ; ferment :: unbox_any_opt (* start_moment) ; ; ferment :: unbox_any (* b) ; ; ferment :: unbox_any_opt (* min_value) ; ; ferment :: unbox_any_opt (* max_value) ; } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: InvertedLogarithmic { a , d , m , n , o , start_moment , b , min_value , max_value } => { ; ; ; ; ; ; ; ; ; ; ferment :: unbox_any_opt (* start_moment) ; ; ferment :: unbox_any (* b) ; ; ferment :: unbox_any_opt (* min_value) ; ; ferment :: unbox_any_opt (* max_value) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod reward_distribution_moment { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`RewardDistributionMoment`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment { BlockBasedMoment (* mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight) , TimeBasedMoment (* mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis) , EpochBasedMoment (* mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment > for dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment) -> dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: BlockBasedMoment (o_0) => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment :: BlockBasedMoment (< crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: BlockHeight >> :: ffi_from (* o_0)) , dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: TimeBasedMoment (o_0) => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment :: TimeBasedMoment (< crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionFrom < dpp :: prelude :: TimestampMillis >> :: ffi_from (* o_0)) , dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: EpochBasedMoment (o_0) => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment :: EpochBasedMoment (< crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionFrom < dpp :: block :: epoch :: EpochIndex >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment > for dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment { unsafe fn ffi_to_const (obj : dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment) -> * const dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment { ferment :: boxed (match obj { dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment :: BlockBasedMoment (o_0) => dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: BlockBasedMoment (< crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: BlockHeight >> :: ffi_to (o_0)) , dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment :: TimeBasedMoment (o_0) => dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: TimeBasedMoment (< crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionTo < dpp :: prelude :: TimestampMillis >> :: ffi_to (o_0)) , dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment :: EpochBasedMoment (o_0) => dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: EpochBasedMoment (< crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionTo < dpp :: block :: epoch :: EpochIndex >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment { fn drop (& mut self) { unsafe { match self { dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: BlockBasedMoment (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: TimeBasedMoment (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: EpochBasedMoment (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } } } pub mod change_control_rules { use crate as example_platform ; pub mod authorized_action_takers { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`AuthorizedActionTakers`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { NoOne , ContractOwner , Identity (* mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) , MainGroup , Group (* mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers > for dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers) -> dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: NoOne => dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers :: NoOne , dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: ContractOwner => dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers :: ContractOwner , dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: Identity (o_0) => dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers :: Identity (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (* o_0)) , dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: MainGroup => dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers :: MainGroup , dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: Group (o_0) => dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers :: Group (< crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers > for dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { unsafe fn ffi_to_const (obj : dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers) -> * const dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { ferment :: boxed (match obj { dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers :: NoOne => dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: NoOne , dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers :: ContractOwner => dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: ContractOwner , dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers :: Identity (o_0) => dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: Identity (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (o_0)) , dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers :: MainGroup => dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: MainGroup , dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers :: Group (o_0) => dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: Group (< crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { fn drop (& mut self) { unsafe { match self { dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: NoOne => { } , dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: ContractOwner => { } , dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: Identity (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: MainGroup => { } , dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: Group (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`ChangeControlRulesV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 { pub authorized_to_make_change : * mut crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers , pub admin_action_takers : * mut crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers , pub changing_authorized_action_takers_to_no_one_allowed : bool , pub changing_admin_action_takers_to_no_one_allowed : bool , pub self_changing_admin_action_takers_allowed : bool } impl ferment :: FFIConversionFrom < dpp :: data_contract :: change_control_rules :: v0 :: ChangeControlRulesV0 > for dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0) -> dpp :: data_contract :: change_control_rules :: v0 :: ChangeControlRulesV0 { let ffi_ref = & * ffi ; dpp :: data_contract :: change_control_rules :: v0 :: ChangeControlRulesV0 { authorized_to_make_change : < crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers as ferment :: FFIConversionFrom < dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers >> :: ffi_from (ffi_ref . authorized_to_make_change) , admin_action_takers : < crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers as ferment :: FFIConversionFrom < dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers >> :: ffi_from (ffi_ref . admin_action_takers) , changing_authorized_action_takers_to_no_one_allowed : ffi_ref . changing_authorized_action_takers_to_no_one_allowed , changing_admin_action_takers_to_no_one_allowed : ffi_ref . changing_admin_action_takers_to_no_one_allowed , self_changing_admin_action_takers_allowed : ffi_ref . self_changing_admin_action_takers_allowed } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: change_control_rules :: v0 :: ChangeControlRulesV0 > for dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: change_control_rules :: v0 :: ChangeControlRulesV0) -> * const dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 { ferment :: boxed (dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 { authorized_to_make_change : < crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers as ferment :: FFIConversionTo < dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers >> :: ffi_to (obj . authorized_to_make_change) , admin_action_takers : < crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers as ferment :: FFIConversionTo < dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers >> :: ffi_to (obj . admin_action_takers) , changing_authorized_action_takers_to_no_one_allowed : obj . changing_authorized_action_takers_to_no_one_allowed , changing_admin_action_takers_to_no_one_allowed : obj . changing_admin_action_takers_to_no_one_allowed , self_changing_admin_action_takers_allowed : obj . self_changing_admin_action_takers_allowed }) } } impl Drop for dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . authorized_to_make_change) ; ferment :: unbox_any (ffi_ref . admin_action_takers) ; ; ; ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ChangeControlRules`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_change_control_rules_ChangeControlRules { V0 (* mut crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: v0 :: dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: change_control_rules :: ChangeControlRules > for dpp_data_contract_change_control_rules_ChangeControlRules { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_change_control_rules_ChangeControlRules) -> dpp :: data_contract :: change_control_rules :: ChangeControlRules { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_change_control_rules_ChangeControlRules :: V0 (o_0) => dpp :: data_contract :: change_control_rules :: ChangeControlRules :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: v0 :: dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 as ferment :: FFIConversionFrom < dpp :: data_contract :: change_control_rules :: v0 :: ChangeControlRulesV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: change_control_rules :: ChangeControlRules > for dpp_data_contract_change_control_rules_ChangeControlRules { unsafe fn ffi_to_const (obj : dpp :: data_contract :: change_control_rules :: ChangeControlRules) -> * const dpp_data_contract_change_control_rules_ChangeControlRules { ferment :: boxed (match obj { dpp :: data_contract :: change_control_rules :: ChangeControlRules :: V0 (o_0) => dpp_data_contract_change_control_rules_ChangeControlRules :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: v0 :: dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 as ferment :: FFIConversionTo < dpp :: data_contract :: change_control_rules :: v0 :: ChangeControlRulesV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_change_control_rules_ChangeControlRules { fn drop (& mut self) { unsafe { match self { dpp_data_contract_change_control_rules_ChangeControlRules :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod config { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`DataContractConfigV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_config_v0_DataContractConfigV0 { pub can_be_deleted : bool , pub readonly : bool , pub keeps_history : bool , pub documents_keep_history_contract_default : bool , pub documents_mutable_contract_default : bool , pub documents_can_be_deleted_contract_default : bool , pub requires_identity_encryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements , pub requires_identity_decryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements } impl ferment :: FFIConversionFrom < dpp :: data_contract :: config :: v0 :: DataContractConfigV0 > for dpp_data_contract_config_v0_DataContractConfigV0 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_config_v0_DataContractConfigV0) -> dpp :: data_contract :: config :: v0 :: DataContractConfigV0 { let ffi_ref = & * ffi ; dpp :: data_contract :: config :: v0 :: DataContractConfigV0 { can_be_deleted : ffi_ref . can_be_deleted , readonly : ffi_ref . readonly , keeps_history : ffi_ref . keeps_history , documents_keep_history_contract_default : ffi_ref . documents_keep_history_contract_default , documents_mutable_contract_default : ffi_ref . documents_mutable_contract_default , documents_can_be_deleted_contract_default : ffi_ref . documents_can_be_deleted_contract_default , requires_identity_encryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionFrom < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_from_opt (ffi_ref . requires_identity_encryption_bounded_key) , requires_identity_decryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionFrom < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_from_opt (ffi_ref . requires_identity_decryption_bounded_key) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: config :: v0 :: DataContractConfigV0 > for dpp_data_contract_config_v0_DataContractConfigV0 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: config :: v0 :: DataContractConfigV0) -> * const dpp_data_contract_config_v0_DataContractConfigV0 { ferment :: boxed (dpp_data_contract_config_v0_DataContractConfigV0 { can_be_deleted : obj . can_be_deleted , readonly : obj . readonly , keeps_history : obj . keeps_history , documents_keep_history_contract_default : obj . documents_keep_history_contract_default , documents_mutable_contract_default : obj . documents_mutable_contract_default , documents_can_be_deleted_contract_default : obj . documents_can_be_deleted_contract_default , requires_identity_encryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionTo < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_to_opt (obj . requires_identity_encryption_bounded_key) , requires_identity_decryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionTo < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_to_opt (obj . requires_identity_decryption_bounded_key) }) } } impl Drop for dpp_data_contract_config_v0_DataContractConfigV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ; ; ; ; ferment :: unbox_any_opt (ffi_ref . requires_identity_encryption_bounded_key) ; ferment :: unbox_any_opt (ffi_ref . requires_identity_decryption_bounded_key) ; } } } } pub mod v1 { use crate as example_platform ; # [doc = "FFI-representation of the [`DataContractConfigV1`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_config_v1_DataContractConfigV1 { pub can_be_deleted : bool , pub readonly : bool , pub keeps_history : bool , pub documents_keep_history_contract_default : bool , pub documents_mutable_contract_default : bool , pub documents_can_be_deleted_contract_default : bool , pub requires_identity_encryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements , pub requires_identity_decryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements , pub sized_integer_types : bool } impl ferment :: FFIConversionFrom < dpp :: data_contract :: config :: v1 :: DataContractConfigV1 > for dpp_data_contract_config_v1_DataContractConfigV1 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_config_v1_DataContractConfigV1) -> dpp :: data_contract :: config :: v1 :: DataContractConfigV1 { let ffi_ref = & * ffi ; dpp :: data_contract :: config :: v1 :: DataContractConfigV1 { can_be_deleted : ffi_ref . can_be_deleted , readonly : ffi_ref . readonly , keeps_history : ffi_ref . keeps_history , documents_keep_history_contract_default : ffi_ref . documents_keep_history_contract_default , documents_mutable_contract_default : ffi_ref . documents_mutable_contract_default , documents_can_be_deleted_contract_default : ffi_ref . documents_can_be_deleted_contract_default , requires_identity_encryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionFrom < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_from_opt (ffi_ref . requires_identity_encryption_bounded_key) , requires_identity_decryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionFrom < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_from_opt (ffi_ref . requires_identity_decryption_bounded_key) , sized_integer_types : ffi_ref . sized_integer_types } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: config :: v1 :: DataContractConfigV1 > for dpp_data_contract_config_v1_DataContractConfigV1 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: config :: v1 :: DataContractConfigV1) -> * const dpp_data_contract_config_v1_DataContractConfigV1 { ferment :: boxed (dpp_data_contract_config_v1_DataContractConfigV1 { can_be_deleted : obj . can_be_deleted , readonly : obj . readonly , keeps_history : obj . keeps_history , documents_keep_history_contract_default : obj . documents_keep_history_contract_default , documents_mutable_contract_default : obj . documents_mutable_contract_default , documents_can_be_deleted_contract_default : obj . documents_can_be_deleted_contract_default , requires_identity_encryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionTo < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_to_opt (obj . requires_identity_encryption_bounded_key) , requires_identity_decryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionTo < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_to_opt (obj . requires_identity_decryption_bounded_key) , sized_integer_types : obj . sized_integer_types }) } } impl Drop for dpp_data_contract_config_v1_DataContractConfigV1 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ; ; ; ; ferment :: unbox_any_opt (ffi_ref . requires_identity_encryption_bounded_key) ; ferment :: unbox_any_opt (ffi_ref . requires_identity_decryption_bounded_key) ; ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DataContractConfig`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_config_DataContractConfig { V0 (* mut crate :: fermented :: types :: dpp :: data_contract :: config :: v0 :: dpp_data_contract_config_v0_DataContractConfigV0) , V1 (* mut crate :: fermented :: types :: dpp :: data_contract :: config :: v1 :: dpp_data_contract_config_v1_DataContractConfigV1) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: config :: DataContractConfig > for dpp_data_contract_config_DataContractConfig { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_config_DataContractConfig) -> dpp :: data_contract :: config :: DataContractConfig { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_config_DataContractConfig :: V0 (o_0) => dpp :: data_contract :: config :: DataContractConfig :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: config :: v0 :: dpp_data_contract_config_v0_DataContractConfigV0 as ferment :: FFIConversionFrom < dpp :: data_contract :: config :: v0 :: DataContractConfigV0 >> :: ffi_from (* o_0)) , dpp_data_contract_config_DataContractConfig :: V1 (o_0) => dpp :: data_contract :: config :: DataContractConfig :: V1 (< crate :: fermented :: types :: dpp :: data_contract :: config :: v1 :: dpp_data_contract_config_v1_DataContractConfigV1 as ferment :: FFIConversionFrom < dpp :: data_contract :: config :: v1 :: DataContractConfigV1 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: config :: DataContractConfig > for dpp_data_contract_config_DataContractConfig { unsafe fn ffi_to_const (obj : dpp :: data_contract :: config :: DataContractConfig) -> * const dpp_data_contract_config_DataContractConfig { ferment :: boxed (match obj { dpp :: data_contract :: config :: DataContractConfig :: V0 (o_0) => dpp_data_contract_config_DataContractConfig :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: config :: v0 :: dpp_data_contract_config_v0_DataContractConfigV0 as ferment :: FFIConversionTo < dpp :: data_contract :: config :: v0 :: DataContractConfigV0 >> :: ffi_to (o_0)) , dpp :: data_contract :: config :: DataContractConfig :: V1 (o_0) => dpp_data_contract_config_DataContractConfig :: V1 (< crate :: fermented :: types :: dpp :: data_contract :: config :: v1 :: dpp_data_contract_config_v1_DataContractConfigV1 as ferment :: FFIConversionTo < dpp :: data_contract :: config :: v1 :: DataContractConfigV1 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_config_DataContractConfig { fn drop (& mut self) { unsafe { match self { dpp_data_contract_config_DataContractConfig :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_config_DataContractConfig :: V1 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod group { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`GroupV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_group_v0_GroupV0 { pub members : * mut crate :: fermented :: generics :: std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower , pub required_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower } impl ferment :: FFIConversionFrom < dpp :: data_contract :: group :: v0 :: GroupV0 > for dpp_data_contract_group_v0_GroupV0 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_group_v0_GroupV0) -> dpp :: data_contract :: group :: v0 :: GroupV0 { let ffi_ref = & * ffi ; dpp :: data_contract :: group :: v0 :: GroupV0 { members : < crate :: fermented :: generics :: std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , dpp :: data_contract :: group :: GroupMemberPower > >> :: ffi_from (ffi_ref . members) , required_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupRequiredPower >> :: ffi_from (ffi_ref . required_power) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: group :: v0 :: GroupV0 > for dpp_data_contract_group_v0_GroupV0 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: group :: v0 :: GroupV0) -> * const dpp_data_contract_group_v0_GroupV0 { ferment :: boxed (dpp_data_contract_group_v0_GroupV0 { members : < crate :: fermented :: generics :: std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionTo < std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , dpp :: data_contract :: group :: GroupMemberPower > >> :: ffi_to (obj . members) , required_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupRequiredPower >> :: ffi_to (obj . required_power) }) } } impl Drop for dpp_data_contract_group_v0_GroupV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . members) ; ferment :: unbox_any (ffi_ref . required_power) ; } } } } # [doc = "FFI-representation of the [`GroupMemberPower`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_group_GroupMemberPower (u32) ; impl ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupMemberPower > for dpp_data_contract_group_GroupMemberPower { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_group_GroupMemberPower) -> dpp :: data_contract :: group :: GroupMemberPower { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupMemberPower > for dpp_data_contract_group_GroupMemberPower { unsafe fn ffi_to_const (obj : dpp :: data_contract :: group :: GroupMemberPower) -> * const dpp_data_contract_group_GroupMemberPower { ferment :: boxed (dpp_data_contract_group_GroupMemberPower (obj)) } } # [doc = "FFI-representation of the [`GroupSumPower`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_group_GroupSumPower (u32) ; impl ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupSumPower > for dpp_data_contract_group_GroupSumPower { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_group_GroupSumPower) -> dpp :: data_contract :: group :: GroupSumPower { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupSumPower > for dpp_data_contract_group_GroupSumPower { unsafe fn ffi_to_const (obj : dpp :: data_contract :: group :: GroupSumPower) -> * const dpp_data_contract_group_GroupSumPower { ferment :: boxed (dpp_data_contract_group_GroupSumPower (obj)) } } # [doc = "FFI-representation of the [`GroupRequiredPower`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_group_GroupRequiredPower (u32) ; impl ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupRequiredPower > for dpp_data_contract_group_GroupRequiredPower { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_group_GroupRequiredPower) -> dpp :: data_contract :: group :: GroupRequiredPower { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupRequiredPower > for dpp_data_contract_group_GroupRequiredPower { unsafe fn ffi_to_const (obj : dpp :: data_contract :: group :: GroupRequiredPower) -> * const dpp_data_contract_group_GroupRequiredPower { ferment :: boxed (dpp_data_contract_group_GroupRequiredPower (obj)) } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`Group`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_group_Group { V0 (* mut crate :: fermented :: types :: dpp :: data_contract :: group :: v0 :: dpp_data_contract_group_v0_GroupV0) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: group :: Group > for dpp_data_contract_group_Group { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_group_Group) -> dpp :: data_contract :: group :: Group { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_group_Group :: V0 (o_0) => dpp :: data_contract :: group :: Group :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: group :: v0 :: dpp_data_contract_group_v0_GroupV0 as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: v0 :: GroupV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: group :: Group > for dpp_data_contract_group_Group { unsafe fn ffi_to_const (obj : dpp :: data_contract :: group :: Group) -> * const dpp_data_contract_group_Group { ferment :: boxed (match obj { dpp :: data_contract :: group :: Group :: V0 (o_0) => dpp_data_contract_group_Group :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: group :: v0 :: dpp_data_contract_group_v0_GroupV0 as ferment :: FFIConversionTo < dpp :: data_contract :: group :: v0 :: GroupV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_group_Group { fn drop (& mut self) { unsafe { match self { dpp_data_contract_group_Group :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod storage_requirements { pub mod keys_for_document_type { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`StorageKeyRequirements`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { Unique = 0 , Multiple = 1 , MultipleReferenceToLatest = 2 } impl ferment :: FFIConversionFrom < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements > for dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements) -> dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: Unique => dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements :: Unique , dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: Multiple => dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements :: Multiple , dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: MultipleReferenceToLatest => dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements :: MultipleReferenceToLatest } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements > for dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { unsafe fn ffi_to_const (obj : dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements) -> * const dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { ferment :: boxed (match obj { dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements :: Unique => dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: Unique , dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements :: Multiple => dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: Multiple , dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements :: MultipleReferenceToLatest => dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: MultipleReferenceToLatest , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { fn drop (& mut self) { unsafe { match self { dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: Unique => { } , dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: Multiple => { } , dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: MultipleReferenceToLatest => { } , _ => unreachable ! ("This is unreachable") } ; } } } } } # [doc = "FFI-representation of the [`JsonSchema`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_JsonSchema (* mut crate :: fermented :: types :: platform_value :: platform_value_Value) ; impl ferment :: FFIConversionFrom < dpp :: data_contract :: JsonSchema > for dpp_data_contract_JsonSchema { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_JsonSchema) -> dpp :: data_contract :: JsonSchema { let ffi_ref = & * ffi ; < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (ffi_ref . 0) } } impl ferment :: FFIConversionTo < dpp :: data_contract :: JsonSchema > for dpp_data_contract_JsonSchema { unsafe fn ffi_to_const (obj : dpp :: data_contract :: JsonSchema) -> * const dpp_data_contract_JsonSchema { ferment :: boxed (dpp_data_contract_JsonSchema (< crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (obj))) } } impl Drop for dpp_data_contract_JsonSchema { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [doc = "FFI-representation of the [`DefinitionName`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_DefinitionName (* mut std :: os :: raw :: c_char) ; impl ferment :: FFIConversionFrom < dpp :: data_contract :: DefinitionName > for dpp_data_contract_DefinitionName { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_DefinitionName) -> dpp :: data_contract :: DefinitionName { let ffi_ref = & * ffi ; < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . 0) } } impl ferment :: FFIConversionTo < dpp :: data_contract :: DefinitionName > for dpp_data_contract_DefinitionName { unsafe fn ffi_to_const (obj : dpp :: data_contract :: DefinitionName) -> * const dpp_data_contract_DefinitionName { ferment :: boxed (dpp_data_contract_DefinitionName (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj))) } } impl Drop for dpp_data_contract_DefinitionName { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . 0) ; } } } # [doc = "FFI-representation of the [`DocumentName`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_DocumentName (* mut std :: os :: raw :: c_char) ; impl ferment :: FFIConversionFrom < dpp :: data_contract :: DocumentName > for dpp_data_contract_DocumentName { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_DocumentName) -> dpp :: data_contract :: DocumentName { let ffi_ref = & * ffi ; < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . 0) } } impl ferment :: FFIConversionTo < dpp :: data_contract :: DocumentName > for dpp_data_contract_DocumentName { unsafe fn ffi_to_const (obj : dpp :: data_contract :: DocumentName) -> * const dpp_data_contract_DocumentName { ferment :: boxed (dpp_data_contract_DocumentName (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj))) } } impl Drop for dpp_data_contract_DocumentName { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . 0) ; } } } # [doc = "FFI-representation of the [`GroupContractPosition`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_GroupContractPosition (u16) ; impl ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition > for dpp_data_contract_GroupContractPosition { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_GroupContractPosition) -> dpp :: data_contract :: GroupContractPosition { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition > for dpp_data_contract_GroupContractPosition { unsafe fn ffi_to_const (obj : dpp :: data_contract :: GroupContractPosition) -> * const dpp_data_contract_GroupContractPosition { ferment :: boxed (dpp_data_contract_GroupContractPosition (obj)) } } # [doc = "FFI-representation of the [`TokenContractPosition`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_TokenContractPosition (u16) ; impl ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition > for dpp_data_contract_TokenContractPosition { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_TokenContractPosition) -> dpp :: data_contract :: TokenContractPosition { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition > for dpp_data_contract_TokenContractPosition { unsafe fn ffi_to_const (obj : dpp :: data_contract :: TokenContractPosition) -> * const dpp_data_contract_TokenContractPosition { ferment :: boxed (dpp_data_contract_TokenContractPosition (obj)) } } # [doc = "FFI-representation of the [`PropertyPath`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_PropertyPath (* mut std :: os :: raw :: c_char) ; impl ferment :: FFIConversionFrom < dpp :: data_contract :: PropertyPath > for dpp_data_contract_PropertyPath { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_PropertyPath) -> dpp :: data_contract :: PropertyPath { let ffi_ref = & * ffi ; < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . 0) } } impl ferment :: FFIConversionTo < dpp :: data_contract :: PropertyPath > for dpp_data_contract_PropertyPath { unsafe fn ffi_to_const (obj : dpp :: data_contract :: PropertyPath) -> * const dpp_data_contract_PropertyPath { ferment :: boxed (dpp_data_contract_PropertyPath (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj))) } } impl Drop for dpp_data_contract_PropertyPath { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . 0) ; } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DataContract`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_DataContract { V0 (* mut crate :: fermented :: types :: dpp :: data_contract :: v0 :: data_contract :: dpp_data_contract_v0_data_contract_DataContractV0) , V1 (* mut crate :: fermented :: types :: dpp :: data_contract :: v1 :: data_contract :: dpp_data_contract_v1_data_contract_DataContractV1) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: DataContract > for dpp_data_contract_DataContract { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_DataContract) -> dpp :: data_contract :: DataContract { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_DataContract :: V0 (o_0) => dpp :: data_contract :: DataContract :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: v0 :: data_contract :: dpp_data_contract_v0_data_contract_DataContractV0 as ferment :: FFIConversionFrom < dpp :: data_contract :: v0 :: data_contract :: DataContractV0 >> :: ffi_from (* o_0)) , dpp_data_contract_DataContract :: V1 (o_0) => dpp :: data_contract :: DataContract :: V1 (< crate :: fermented :: types :: dpp :: data_contract :: v1 :: data_contract :: dpp_data_contract_v1_data_contract_DataContractV1 as ferment :: FFIConversionFrom < dpp :: data_contract :: v1 :: data_contract :: DataContractV1 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: DataContract > for dpp_data_contract_DataContract { unsafe fn ffi_to_const (obj : dpp :: data_contract :: DataContract) -> * const dpp_data_contract_DataContract { ferment :: boxed (match obj { dpp :: data_contract :: DataContract :: V0 (o_0) => dpp_data_contract_DataContract :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: v0 :: data_contract :: dpp_data_contract_v0_data_contract_DataContractV0 as ferment :: FFIConversionTo < dpp :: data_contract :: v0 :: data_contract :: DataContractV0 >> :: ffi_to (o_0)) , dpp :: data_contract :: DataContract :: V1 (o_0) => dpp_data_contract_DataContract :: V1 (< crate :: fermented :: types :: dpp :: data_contract :: v1 :: data_contract :: dpp_data_contract_v1_data_contract_DataContractV1 as ferment :: FFIConversionTo < dpp :: data_contract :: v1 :: data_contract :: DataContractV1 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_DataContract { fn drop (& mut self) { unsafe { match self { dpp_data_contract_DataContract :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_DataContract :: V1 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod document { use crate as example_platform ; pub mod errors { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_document_errors_DocumentError { # [cfg (feature = "state-transitions")] DocumentAlreadyExistsError { document_transition : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition } , # [cfg (feature = "state-transitions")] DocumentNotProvidedError { document_transition : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition } , InvalidActionError (u8) , InvalidActionNameError { actions : * mut crate :: fermented :: generics :: Vec_String } , # [cfg (feature = "state-transitions")] InvalidDocumentActionError { document_transition : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition } , InvalidDocumentError { errors : * mut crate :: fermented :: generics :: Vec_dpp_errors_consensus_consensus_error_ConsensusError , raw_document : * mut crate :: fermented :: types :: platform_value :: platform_value_Value } , InvalidInitialRevisionError { document : * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document } , RevisionAbsentError { document : * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document } , TryingToReplaceImmutableDocument { document : * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document } , TryingToDeleteIndelibleDocument { document : * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document } , MismatchOwnerIdsError { documents : * mut crate :: fermented :: generics :: Vec_dpp_document_Document } , DocumentNoRevisionError { document : * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document } , NoDocumentsSuppliedError } impl ferment :: FFIConversionFrom < dpp :: document :: errors :: DocumentError > for dpp_document_errors_DocumentError { unsafe fn ffi_from_const (ffi : * const dpp_document_errors_DocumentError) -> dpp :: document :: errors :: DocumentError { let ffi_ref = & * ffi ; match ffi_ref { # [cfg (feature = "state-transitions")] dpp_document_errors_DocumentError :: DocumentAlreadyExistsError { document_transition } => dpp :: document :: errors :: DocumentError :: DocumentAlreadyExistsError { document_transition : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition >> :: ffi_from (* document_transition) } , # [cfg (feature = "state-transitions")] dpp_document_errors_DocumentError :: DocumentNotProvidedError { document_transition } => dpp :: document :: errors :: DocumentError :: DocumentNotProvidedError { document_transition : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition >> :: ffi_from (* document_transition) } , dpp_document_errors_DocumentError :: InvalidActionError (o_0) => dpp :: document :: errors :: DocumentError :: InvalidActionError (* o_0) , dpp_document_errors_DocumentError :: InvalidActionNameError { actions } => dpp :: document :: errors :: DocumentError :: InvalidActionNameError { actions : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionFrom < Vec < String > >> :: ffi_from (* actions) } , # [cfg (feature = "state-transitions")] dpp_document_errors_DocumentError :: InvalidDocumentActionError { document_transition } => dpp :: document :: errors :: DocumentError :: InvalidDocumentActionError { document_transition : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition >> :: ffi_from (* document_transition) } , dpp_document_errors_DocumentError :: InvalidDocumentError { errors , raw_document } => dpp :: document :: errors :: DocumentError :: InvalidDocumentError { errors : < crate :: fermented :: generics :: Vec_dpp_errors_consensus_consensus_error_ConsensusError as ferment :: FFIConversionFrom < Vec < dpp :: errors :: consensus :: consensus_error :: ConsensusError > >> :: ffi_from (* errors) , raw_document : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (* raw_document) } , dpp_document_errors_DocumentError :: InvalidInitialRevisionError { document } => dpp :: document :: errors :: DocumentError :: InvalidInitialRevisionError { document : Box :: new (< crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionFrom < dpp :: document :: Document >> :: ffi_from (* document)) } , dpp_document_errors_DocumentError :: RevisionAbsentError { document } => dpp :: document :: errors :: DocumentError :: RevisionAbsentError { document : Box :: new (< crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionFrom < dpp :: document :: Document >> :: ffi_from (* document)) } , dpp_document_errors_DocumentError :: TryingToReplaceImmutableDocument { document } => dpp :: document :: errors :: DocumentError :: TryingToReplaceImmutableDocument { document : Box :: new (< crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionFrom < dpp :: document :: Document >> :: ffi_from (* document)) } , dpp_document_errors_DocumentError :: TryingToDeleteIndelibleDocument { document } => dpp :: document :: errors :: DocumentError :: TryingToDeleteIndelibleDocument { document : Box :: new (< crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionFrom < dpp :: document :: Document >> :: ffi_from (* document)) } , dpp_document_errors_DocumentError :: MismatchOwnerIdsError { documents } => dpp :: document :: errors :: DocumentError :: MismatchOwnerIdsError { documents : < crate :: fermented :: generics :: Vec_dpp_document_Document as ferment :: FFIConversionFrom < Vec < dpp :: document :: Document > >> :: ffi_from (* documents) } , dpp_document_errors_DocumentError :: DocumentNoRevisionError { document } => dpp :: document :: errors :: DocumentError :: DocumentNoRevisionError { document : Box :: new (< crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionFrom < dpp :: document :: Document >> :: ffi_from (* document)) } , dpp_document_errors_DocumentError :: NoDocumentsSuppliedError => dpp :: document :: errors :: DocumentError :: NoDocumentsSuppliedError } } } impl ferment :: FFIConversionTo < dpp :: document :: errors :: DocumentError > for dpp_document_errors_DocumentError { unsafe fn ffi_to_const (obj : dpp :: document :: errors :: DocumentError) -> * const dpp_document_errors_DocumentError { ferment :: boxed (match obj { # [cfg (feature = "state-transitions")] dpp :: document :: errors :: DocumentError :: DocumentAlreadyExistsError { document_transition } => dpp_document_errors_DocumentError :: DocumentAlreadyExistsError { document_transition : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition >> :: ffi_to (document_transition) } , # [cfg (feature = "state-transitions")] dpp :: document :: errors :: DocumentError :: DocumentNotProvidedError { document_transition } => dpp_document_errors_DocumentError :: DocumentNotProvidedError { document_transition : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition >> :: ffi_to (document_transition) } , dpp :: document :: errors :: DocumentError :: InvalidActionError (o_0) => dpp_document_errors_DocumentError :: InvalidActionError (o_0) , dpp :: document :: errors :: DocumentError :: InvalidActionNameError { actions } => dpp_document_errors_DocumentError :: InvalidActionNameError { actions : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionTo < Vec < String > >> :: ffi_to (actions) } , # [cfg (feature = "state-transitions")] dpp :: document :: errors :: DocumentError :: InvalidDocumentActionError { document_transition } => dpp_document_errors_DocumentError :: InvalidDocumentActionError { document_transition : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition >> :: ffi_to (document_transition) } , dpp :: document :: errors :: DocumentError :: InvalidDocumentError { errors , raw_document } => dpp_document_errors_DocumentError :: InvalidDocumentError { errors : < crate :: fermented :: generics :: Vec_dpp_errors_consensus_consensus_error_ConsensusError as ferment :: FFIConversionTo < Vec < dpp :: errors :: consensus :: consensus_error :: ConsensusError > >> :: ffi_to (errors) , raw_document : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (raw_document) } , dpp :: document :: errors :: DocumentError :: InvalidInitialRevisionError { document } => dpp_document_errors_DocumentError :: InvalidInitialRevisionError { document : < crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionTo < dpp :: document :: Document >> :: ffi_to (* document) } , dpp :: document :: errors :: DocumentError :: RevisionAbsentError { document } => dpp_document_errors_DocumentError :: RevisionAbsentError { document : < crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionTo < dpp :: document :: Document >> :: ffi_to (* document) } , dpp :: document :: errors :: DocumentError :: TryingToReplaceImmutableDocument { document } => dpp_document_errors_DocumentError :: TryingToReplaceImmutableDocument { document : < crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionTo < dpp :: document :: Document >> :: ffi_to (* document) } , dpp :: document :: errors :: DocumentError :: TryingToDeleteIndelibleDocument { document } => dpp_document_errors_DocumentError :: TryingToDeleteIndelibleDocument { document : < crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionTo < dpp :: document :: Document >> :: ffi_to (* document) } , dpp :: document :: errors :: DocumentError :: MismatchOwnerIdsError { documents } => dpp_document_errors_DocumentError :: MismatchOwnerIdsError { documents : < crate :: fermented :: generics :: Vec_dpp_document_Document as ferment :: FFIConversionTo < Vec < dpp :: document :: Document > >> :: ffi_to (documents) } , dpp :: document :: errors :: DocumentError :: DocumentNoRevisionError { document } => dpp_document_errors_DocumentError :: DocumentNoRevisionError { document : < crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionTo < dpp :: document :: Document >> :: ffi_to (* document) } , dpp :: document :: errors :: DocumentError :: NoDocumentsSuppliedError => dpp_document_errors_DocumentError :: NoDocumentsSuppliedError , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_document_errors_DocumentError { fn drop (& mut self) { unsafe { match self { # [cfg (feature = "state-transitions")] dpp_document_errors_DocumentError :: DocumentAlreadyExistsError { document_transition } => { ferment :: unbox_any (* document_transition) ; } , # [cfg (feature = "state-transitions")] dpp_document_errors_DocumentError :: DocumentNotProvidedError { document_transition } => { ferment :: unbox_any (* document_transition) ; } , dpp_document_errors_DocumentError :: InvalidActionError (o_0) => { ; } , dpp_document_errors_DocumentError :: InvalidActionNameError { actions } => { ferment :: unbox_any (* actions) ; } , # [cfg (feature = "state-transitions")] dpp_document_errors_DocumentError :: InvalidDocumentActionError { document_transition } => { ferment :: unbox_any (* document_transition) ; } , dpp_document_errors_DocumentError :: InvalidDocumentError { errors , raw_document } => { ferment :: unbox_any (* errors) ; ; ferment :: unbox_any (* raw_document) ; } , dpp_document_errors_DocumentError :: InvalidInitialRevisionError { document } => { ferment :: unbox_any (* document) ; } , dpp_document_errors_DocumentError :: RevisionAbsentError { document } => { ferment :: unbox_any (* document) ; } , dpp_document_errors_DocumentError :: TryingToReplaceImmutableDocument { document } => { ferment :: unbox_any (* document) ; } , dpp_document_errors_DocumentError :: TryingToDeleteIndelibleDocument { document } => { ferment :: unbox_any (* document) ; } , dpp_document_errors_DocumentError :: MismatchOwnerIdsError { documents } => { ferment :: unbox_any (* documents) ; } , dpp_document_errors_DocumentError :: DocumentNoRevisionError { document } => { ferment :: unbox_any (* document) ; } , dpp_document_errors_DocumentError :: NoDocumentsSuppliedError => { } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod transfer { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`Transferable`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_document_transfer_Transferable { Never = 0 , Always = 1 } impl ferment :: FFIConversionFrom < dpp :: document :: transfer :: Transferable > for dpp_document_transfer_Transferable { unsafe fn ffi_from_const (ffi : * const dpp_document_transfer_Transferable) -> dpp :: document :: transfer :: Transferable { let ffi_ref = & * ffi ; match ffi_ref { dpp_document_transfer_Transferable :: Never => dpp :: document :: transfer :: Transferable :: Never , dpp_document_transfer_Transferable :: Always => dpp :: document :: transfer :: Transferable :: Always } } } impl ferment :: FFIConversionTo < dpp :: document :: transfer :: Transferable > for dpp_document_transfer_Transferable { unsafe fn ffi_to_const (obj : dpp :: document :: transfer :: Transferable) -> * const dpp_document_transfer_Transferable { ferment :: boxed (match obj { dpp :: document :: transfer :: Transferable :: Never => dpp_document_transfer_Transferable :: Never , dpp :: document :: transfer :: Transferable :: Always => dpp_document_transfer_Transferable :: Always , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_document_transfer_Transferable { fn drop (& mut self) { unsafe { match self { dpp_document_transfer_Transferable :: Never => { } , dpp_document_transfer_Transferable :: Always => { } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`DocumentV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_document_v0_DocumentV0 { pub id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub owner_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub properties : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value , pub revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , pub created_at : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis , pub updated_at : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis , pub transferred_at : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis , pub created_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , pub updated_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , pub transferred_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , pub created_at_core_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight , pub updated_at_core_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight , pub transferred_at_core_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight } impl ferment :: FFIConversionFrom < dpp :: document :: v0 :: DocumentV0 > for dpp_document_v0_DocumentV0 { unsafe fn ffi_from_const (ffi : * const dpp_document_v0_DocumentV0) -> dpp :: document :: v0 :: DocumentV0 { let ffi_ref = & * ffi ; dpp :: document :: v0 :: DocumentV0 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . id) , owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . owner_id) , properties : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , platform_value :: Value > >> :: ffi_from (ffi_ref . properties) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from_opt (ffi_ref . revision) , created_at : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_from_opt (ffi_ref . created_at) , updated_at : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_from_opt (ffi_ref . updated_at) , transferred_at : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_from_opt (ffi_ref . transferred_at) , created_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: BlockHeight >> :: ffi_from_opt (ffi_ref . created_at_block_height) , updated_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: BlockHeight >> :: ffi_from_opt (ffi_ref . updated_at_block_height) , transferred_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: BlockHeight >> :: ffi_from_opt (ffi_ref . transferred_at_block_height) , created_at_core_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: CoreBlockHeight >> :: ffi_from_opt (ffi_ref . created_at_core_block_height) , updated_at_core_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: CoreBlockHeight >> :: ffi_from_opt (ffi_ref . updated_at_core_block_height) , transferred_at_core_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: CoreBlockHeight >> :: ffi_from_opt (ffi_ref . transferred_at_core_block_height) } } } impl ferment :: FFIConversionTo < dpp :: document :: v0 :: DocumentV0 > for dpp_document_v0_DocumentV0 { unsafe fn ffi_to_const (obj : dpp :: document :: v0 :: DocumentV0) -> * const dpp_document_v0_DocumentV0 { ferment :: boxed (dpp_document_v0_DocumentV0 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . id) , owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . owner_id) , properties : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value as ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , platform_value :: Value > >> :: ffi_to (obj . properties) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to_opt (obj . revision) , created_at : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_to_opt (obj . created_at) , updated_at : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_to_opt (obj . updated_at) , transferred_at : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_to_opt (obj . transferred_at) , created_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: BlockHeight >> :: ffi_to_opt (obj . created_at_block_height) , updated_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: BlockHeight >> :: ffi_to_opt (obj . updated_at_block_height) , transferred_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: BlockHeight >> :: ffi_to_opt (obj . transferred_at_block_height) , created_at_core_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: CoreBlockHeight >> :: ffi_to_opt (obj . created_at_core_block_height) , updated_at_core_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: CoreBlockHeight >> :: ffi_to_opt (obj . updated_at_core_block_height) , transferred_at_core_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: CoreBlockHeight >> :: ffi_to_opt (obj . transferred_at_core_block_height) }) } } impl Drop for dpp_document_v0_DocumentV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; ferment :: unbox_any (ffi_ref . owner_id) ; ferment :: unbox_any (ffi_ref . properties) ; ferment :: unbox_any_opt (ffi_ref . revision) ; ferment :: unbox_any_opt (ffi_ref . created_at) ; ferment :: unbox_any_opt (ffi_ref . updated_at) ; ferment :: unbox_any_opt (ffi_ref . transferred_at) ; ferment :: unbox_any_opt (ffi_ref . created_at_block_height) ; ferment :: unbox_any_opt (ffi_ref . updated_at_block_height) ; ferment :: unbox_any_opt (ffi_ref . transferred_at_block_height) ; ferment :: unbox_any_opt (ffi_ref . created_at_core_block_height) ; ferment :: unbox_any_opt (ffi_ref . updated_at_core_block_height) ; ferment :: unbox_any_opt (ffi_ref . transferred_at_core_block_height) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`Document`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_document_Document { V0 (* mut crate :: fermented :: types :: dpp :: document :: v0 :: dpp_document_v0_DocumentV0) } impl ferment :: FFIConversionFrom < dpp :: document :: Document > for dpp_document_Document { unsafe fn ffi_from_const (ffi : * const dpp_document_Document) -> dpp :: document :: Document { let ffi_ref = & * ffi ; match ffi_ref { dpp_document_Document :: V0 (o_0) => dpp :: document :: Document :: V0 (< crate :: fermented :: types :: dpp :: document :: v0 :: dpp_document_v0_DocumentV0 as ferment :: FFIConversionFrom < dpp :: document :: v0 :: DocumentV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: document :: Document > for dpp_document_Document { unsafe fn ffi_to_const (obj : dpp :: document :: Document) -> * const dpp_document_Document { ferment :: boxed (match obj { dpp :: document :: Document :: V0 (o_0) => dpp_document_Document :: V0 (< crate :: fermented :: types :: dpp :: document :: v0 :: dpp_document_v0_DocumentV0 as ferment :: FFIConversionTo < dpp :: document :: v0 :: DocumentV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_document_Document { fn drop (& mut self) { unsafe { match self { dpp_document_Document :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod identity { pub mod core_script { use crate as example_platform ; # [doc = "FFI-representation of the [`CoreScript`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_core_script_CoreScript (* mut crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf) ; impl ferment :: FFIConversionFrom < dpp :: identity :: core_script :: CoreScript > for dpp_identity_core_script_CoreScript { unsafe fn ffi_from_const (ffi : * const dpp_identity_core_script_CoreScript) -> dpp :: identity :: core_script :: CoreScript { let ffi_ref = & * ffi ; dpp :: identity :: core_script :: CoreScript (< crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf as ferment :: FFIConversionFrom < dashcore :: blockdata :: script :: owned :: ScriptBuf >> :: ffi_from (ffi_ref . 0)) } } impl ferment :: FFIConversionTo < dpp :: identity :: core_script :: CoreScript > for dpp_identity_core_script_CoreScript { unsafe fn ffi_to_const (obj : dpp :: identity :: core_script :: CoreScript) -> * const dpp_identity_core_script_CoreScript { ferment :: boxed (dpp_identity_core_script_CoreScript (< crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf as ferment :: FFIConversionTo < dashcore :: blockdata :: script :: owned :: ScriptBuf >> :: ffi_to (obj . 0))) } } impl Drop for dpp_identity_core_script_CoreScript { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } } pub mod identity { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`Identity`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_identity_identity_Identity { V0 (* mut crate :: fermented :: types :: dpp :: identity :: v0 :: dpp_identity_v0_IdentityV0) } impl ferment :: FFIConversionFrom < dpp :: identity :: identity :: Identity > for dpp_identity_identity_Identity { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_Identity) -> dpp :: identity :: identity :: Identity { let ffi_ref = & * ffi ; match ffi_ref { dpp_identity_identity_Identity :: V0 (o_0) => dpp :: identity :: identity :: Identity :: V0 (< crate :: fermented :: types :: dpp :: identity :: v0 :: dpp_identity_v0_IdentityV0 as ferment :: FFIConversionFrom < dpp :: identity :: v0 :: IdentityV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: identity :: identity :: Identity > for dpp_identity_identity_Identity { unsafe fn ffi_to_const (obj : dpp :: identity :: identity :: Identity) -> * const dpp_identity_identity_Identity { ferment :: boxed (match obj { dpp :: identity :: identity :: Identity :: V0 (o_0) => dpp_identity_identity_Identity :: V0 (< crate :: fermented :: types :: dpp :: identity :: v0 :: dpp_identity_v0_IdentityV0 as ferment :: FFIConversionTo < dpp :: identity :: v0 :: IdentityV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_identity_identity_Identity { fn drop (& mut self) { unsafe { match self { dpp_identity_identity_Identity :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [doc = "FFI-representation of the [`PartialIdentity`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_identity_PartialIdentity { pub id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub loaded_public_keys : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey , pub balance : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , pub revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , pub not_found_public_keys : * mut crate :: fermented :: generics :: std_collections_BTreeSet_dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < dpp :: identity :: identity :: PartialIdentity > for dpp_identity_identity_PartialIdentity { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_PartialIdentity) -> dpp :: identity :: identity :: PartialIdentity { let ffi_ref = & * ffi ; dpp :: identity :: identity :: PartialIdentity { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . id) , loaded_public_keys : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: identity :: identity_public_key :: KeyID , dpp :: identity :: identity_public_key :: IdentityPublicKey > >> :: ffi_from (ffi_ref . loaded_public_keys) , balance : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from_opt (ffi_ref . balance) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from_opt (ffi_ref . revision) , not_found_public_keys : < crate :: fermented :: generics :: std_collections_BTreeSet_dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < dpp :: identity :: identity_public_key :: KeyID > >> :: ffi_from (ffi_ref . not_found_public_keys) } } } impl ferment :: FFIConversionTo < dpp :: identity :: identity :: PartialIdentity > for dpp_identity_identity_PartialIdentity { unsafe fn ffi_to_const (obj : dpp :: identity :: identity :: PartialIdentity) -> * const dpp_identity_identity_PartialIdentity { ferment :: boxed (dpp_identity_identity_PartialIdentity { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . id) , loaded_public_keys : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: identity :: identity_public_key :: KeyID , dpp :: identity :: identity_public_key :: IdentityPublicKey > >> :: ffi_to (obj . loaded_public_keys) , balance : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to_opt (obj . balance) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to_opt (obj . revision) , not_found_public_keys : < crate :: fermented :: generics :: std_collections_BTreeSet_dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < std :: collections :: BTreeSet < dpp :: identity :: identity_public_key :: KeyID > >> :: ffi_to (obj . not_found_public_keys) }) } } impl Drop for dpp_identity_identity_PartialIdentity { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; ferment :: unbox_any (ffi_ref . loaded_public_keys) ; ferment :: unbox_any_opt (ffi_ref . balance) ; ferment :: unbox_any_opt (ffi_ref . revision) ; ferment :: unbox_any (ffi_ref . not_found_public_keys) ; } } } } pub mod identity_public_key { use crate as example_platform ; pub mod key_type { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`KeyType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_identity_identity_public_key_key_type_KeyType { ECDSA_SECP256K1 = 0 , BLS12_381 = 1 , ECDSA_HASH160 = 2 , BIP13_SCRIPT_HASH = 3 , EDDSA_25519_HASH160 = 4 } impl ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: key_type :: KeyType > for dpp_identity_identity_public_key_key_type_KeyType { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_public_key_key_type_KeyType) -> dpp :: identity :: identity_public_key :: key_type :: KeyType { let ffi_ref = & * ffi ; match ffi_ref { dpp_identity_identity_public_key_key_type_KeyType :: ECDSA_SECP256K1 => dpp :: identity :: identity_public_key :: key_type :: KeyType :: ECDSA_SECP256K1 , dpp_identity_identity_public_key_key_type_KeyType :: BLS12_381 => dpp :: identity :: identity_public_key :: key_type :: KeyType :: BLS12_381 , dpp_identity_identity_public_key_key_type_KeyType :: ECDSA_HASH160 => dpp :: identity :: identity_public_key :: key_type :: KeyType :: ECDSA_HASH160 , dpp_identity_identity_public_key_key_type_KeyType :: BIP13_SCRIPT_HASH => dpp :: identity :: identity_public_key :: key_type :: KeyType :: BIP13_SCRIPT_HASH , dpp_identity_identity_public_key_key_type_KeyType :: EDDSA_25519_HASH160 => dpp :: identity :: identity_public_key :: key_type :: KeyType :: EDDSA_25519_HASH160 } } } impl ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: key_type :: KeyType > for dpp_identity_identity_public_key_key_type_KeyType { unsafe fn ffi_to_const (obj : dpp :: identity :: identity_public_key :: key_type :: KeyType) -> * const dpp_identity_identity_public_key_key_type_KeyType { ferment :: boxed (match obj { dpp :: identity :: identity_public_key :: key_type :: KeyType :: ECDSA_SECP256K1 => dpp_identity_identity_public_key_key_type_KeyType :: ECDSA_SECP256K1 , dpp :: identity :: identity_public_key :: key_type :: KeyType :: BLS12_381 => dpp_identity_identity_public_key_key_type_KeyType :: BLS12_381 , dpp :: identity :: identity_public_key :: key_type :: KeyType :: ECDSA_HASH160 => dpp_identity_identity_public_key_key_type_KeyType :: ECDSA_HASH160 , dpp :: identity :: identity_public_key :: key_type :: KeyType :: BIP13_SCRIPT_HASH => dpp_identity_identity_public_key_key_type_KeyType :: BIP13_SCRIPT_HASH , dpp :: identity :: identity_public_key :: key_type :: KeyType :: EDDSA_25519_HASH160 => dpp_identity_identity_public_key_key_type_KeyType :: EDDSA_25519_HASH160 , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_identity_identity_public_key_key_type_KeyType { fn drop (& mut self) { unsafe { match self { dpp_identity_identity_public_key_key_type_KeyType :: ECDSA_SECP256K1 => { } , dpp_identity_identity_public_key_key_type_KeyType :: BLS12_381 => { } , dpp_identity_identity_public_key_key_type_KeyType :: ECDSA_HASH160 => { } , dpp_identity_identity_public_key_key_type_KeyType :: BIP13_SCRIPT_HASH => { } , dpp_identity_identity_public_key_key_type_KeyType :: EDDSA_25519_HASH160 => { } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod purpose { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`Purpose`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_identity_identity_public_key_purpose_Purpose { AUTHENTICATION = 0 , ENCRYPTION = 1 , DECRYPTION = 2 , TRANSFER = 3 , SYSTEM = 4 , VOTING = 5 , OWNER = 6 } impl ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: purpose :: Purpose > for dpp_identity_identity_public_key_purpose_Purpose { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_public_key_purpose_Purpose) -> dpp :: identity :: identity_public_key :: purpose :: Purpose { let ffi_ref = & * ffi ; match ffi_ref { dpp_identity_identity_public_key_purpose_Purpose :: AUTHENTICATION => dpp :: identity :: identity_public_key :: purpose :: Purpose :: AUTHENTICATION , dpp_identity_identity_public_key_purpose_Purpose :: ENCRYPTION => dpp :: identity :: identity_public_key :: purpose :: Purpose :: ENCRYPTION , dpp_identity_identity_public_key_purpose_Purpose :: DECRYPTION => dpp :: identity :: identity_public_key :: purpose :: Purpose :: DECRYPTION , dpp_identity_identity_public_key_purpose_Purpose :: TRANSFER => dpp :: identity :: identity_public_key :: purpose :: Purpose :: TRANSFER , dpp_identity_identity_public_key_purpose_Purpose :: SYSTEM => dpp :: identity :: identity_public_key :: purpose :: Purpose :: SYSTEM , dpp_identity_identity_public_key_purpose_Purpose :: VOTING => dpp :: identity :: identity_public_key :: purpose :: Purpose :: VOTING , dpp_identity_identity_public_key_purpose_Purpose :: OWNER => dpp :: identity :: identity_public_key :: purpose :: Purpose :: OWNER } } } impl ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: purpose :: Purpose > for dpp_identity_identity_public_key_purpose_Purpose { unsafe fn ffi_to_const (obj : dpp :: identity :: identity_public_key :: purpose :: Purpose) -> * const dpp_identity_identity_public_key_purpose_Purpose { ferment :: boxed (match obj { dpp :: identity :: identity_public_key :: purpose :: Purpose :: AUTHENTICATION => dpp_identity_identity_public_key_purpose_Purpose :: AUTHENTICATION , dpp :: identity :: identity_public_key :: purpose :: Purpose :: ENCRYPTION => dpp_identity_identity_public_key_purpose_Purpose :: ENCRYPTION , dpp :: identity :: identity_public_key :: purpose :: Purpose :: DECRYPTION => dpp_identity_identity_public_key_purpose_Purpose :: DECRYPTION , dpp :: identity :: identity_public_key :: purpose :: Purpose :: TRANSFER => dpp_identity_identity_public_key_purpose_Purpose :: TRANSFER , dpp :: identity :: identity_public_key :: purpose :: Purpose :: SYSTEM => dpp_identity_identity_public_key_purpose_Purpose :: SYSTEM , dpp :: identity :: identity_public_key :: purpose :: Purpose :: VOTING => dpp_identity_identity_public_key_purpose_Purpose :: VOTING , dpp :: identity :: identity_public_key :: purpose :: Purpose :: OWNER => dpp_identity_identity_public_key_purpose_Purpose :: OWNER , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_identity_identity_public_key_purpose_Purpose { fn drop (& mut self) { unsafe { match self { dpp_identity_identity_public_key_purpose_Purpose :: AUTHENTICATION => { } , dpp_identity_identity_public_key_purpose_Purpose :: ENCRYPTION => { } , dpp_identity_identity_public_key_purpose_Purpose :: DECRYPTION => { } , dpp_identity_identity_public_key_purpose_Purpose :: TRANSFER => { } , dpp_identity_identity_public_key_purpose_Purpose :: SYSTEM => { } , dpp_identity_identity_public_key_purpose_Purpose :: VOTING => { } , dpp_identity_identity_public_key_purpose_Purpose :: OWNER => { } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod security_level { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`SecurityLevel`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_identity_identity_public_key_security_level_SecurityLevel { MASTER = 0 , CRITICAL = 1 , HIGH = 2 , MEDIUM = 3 } impl ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel > for dpp_identity_identity_public_key_security_level_SecurityLevel { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_public_key_security_level_SecurityLevel) -> dpp :: identity :: identity_public_key :: security_level :: SecurityLevel { let ffi_ref = & * ffi ; match ffi_ref { dpp_identity_identity_public_key_security_level_SecurityLevel :: MASTER => dpp :: identity :: identity_public_key :: security_level :: SecurityLevel :: MASTER , dpp_identity_identity_public_key_security_level_SecurityLevel :: CRITICAL => dpp :: identity :: identity_public_key :: security_level :: SecurityLevel :: CRITICAL , dpp_identity_identity_public_key_security_level_SecurityLevel :: HIGH => dpp :: identity :: identity_public_key :: security_level :: SecurityLevel :: HIGH , dpp_identity_identity_public_key_security_level_SecurityLevel :: MEDIUM => dpp :: identity :: identity_public_key :: security_level :: SecurityLevel :: MEDIUM } } } impl ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel > for dpp_identity_identity_public_key_security_level_SecurityLevel { unsafe fn ffi_to_const (obj : dpp :: identity :: identity_public_key :: security_level :: SecurityLevel) -> * const dpp_identity_identity_public_key_security_level_SecurityLevel { ferment :: boxed (match obj { dpp :: identity :: identity_public_key :: security_level :: SecurityLevel :: MASTER => dpp_identity_identity_public_key_security_level_SecurityLevel :: MASTER , dpp :: identity :: identity_public_key :: security_level :: SecurityLevel :: CRITICAL => dpp_identity_identity_public_key_security_level_SecurityLevel :: CRITICAL , dpp :: identity :: identity_public_key :: security_level :: SecurityLevel :: HIGH => dpp_identity_identity_public_key_security_level_SecurityLevel :: HIGH , dpp :: identity :: identity_public_key :: security_level :: SecurityLevel :: MEDIUM => dpp_identity_identity_public_key_security_level_SecurityLevel :: MEDIUM , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_identity_identity_public_key_security_level_SecurityLevel { fn drop (& mut self) { unsafe { match self { dpp_identity_identity_public_key_security_level_SecurityLevel :: MASTER => { } , dpp_identity_identity_public_key_security_level_SecurityLevel :: CRITICAL => { } , dpp_identity_identity_public_key_security_level_SecurityLevel :: HIGH => { } , dpp_identity_identity_public_key_security_level_SecurityLevel :: MEDIUM => { } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityPublicKeyV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 { pub id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , pub purpose : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose , pub security_level : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel , pub contract_bounds : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: contract_bounds :: dpp_identity_identity_public_key_contract_bounds_ContractBounds , pub key_type : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType , pub read_only : bool , pub data : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData , pub disabled_at : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis } impl ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: v0 :: IdentityPublicKeyV0 > for dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) -> dpp :: identity :: identity_public_key :: v0 :: IdentityPublicKeyV0 { let ffi_ref = & * ffi ; dpp :: identity :: identity_public_key :: v0 :: IdentityPublicKeyV0 { id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . id) , purpose : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: purpose :: Purpose >> :: ffi_from (ffi_ref . purpose) , security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_from (ffi_ref . security_level) , contract_bounds : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: contract_bounds :: dpp_identity_identity_public_key_contract_bounds_ContractBounds as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds >> :: ffi_from_opt (ffi_ref . contract_bounds) , key_type : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: key_type :: KeyType >> :: ffi_from (ffi_ref . key_type) , read_only : ffi_ref . read_only , data : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionFrom < platform_value :: types :: binary_data :: BinaryData >> :: ffi_from (ffi_ref . data) , disabled_at : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_from_opt (ffi_ref . disabled_at) } } } impl ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: v0 :: IdentityPublicKeyV0 > for dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 { unsafe fn ffi_to_const (obj : dpp :: identity :: identity_public_key :: v0 :: IdentityPublicKeyV0) -> * const dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 { ferment :: boxed (dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 { id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . id) , purpose : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: purpose :: Purpose >> :: ffi_to (obj . purpose) , security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_to (obj . security_level) , contract_bounds : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: contract_bounds :: dpp_identity_identity_public_key_contract_bounds_ContractBounds as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds >> :: ffi_to_opt (obj . contract_bounds) , key_type : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: key_type :: KeyType >> :: ffi_to (obj . key_type) , read_only : obj . read_only , data : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionTo < platform_value :: types :: binary_data :: BinaryData >> :: ffi_to (obj . data) , disabled_at : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_to_opt (obj . disabled_at) }) } } impl Drop for dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; ferment :: unbox_any (ffi_ref . purpose) ; ferment :: unbox_any (ffi_ref . security_level) ; ferment :: unbox_any_opt (ffi_ref . contract_bounds) ; ferment :: unbox_any (ffi_ref . key_type) ; ; ferment :: unbox_any (ffi_ref . data) ; ferment :: unbox_any_opt (ffi_ref . disabled_at) ; } } } } pub mod contract_bounds { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ContractBounds`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_identity_identity_public_key_contract_bounds_ContractBounds { SingleContract { id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } , SingleContractDocumentType { id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , document_type_name : * mut std :: os :: raw :: c_char } } impl ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds > for dpp_identity_identity_public_key_contract_bounds_ContractBounds { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_public_key_contract_bounds_ContractBounds) -> dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds { let ffi_ref = & * ffi ; match ffi_ref { dpp_identity_identity_public_key_contract_bounds_ContractBounds :: SingleContract { id } => dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds :: SingleContract { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (* id) } , dpp_identity_identity_public_key_contract_bounds_ContractBounds :: SingleContractDocumentType { id , document_type_name } => dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds :: SingleContractDocumentType { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (* id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* document_type_name) } } } } impl ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds > for dpp_identity_identity_public_key_contract_bounds_ContractBounds { unsafe fn ffi_to_const (obj : dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds) -> * const dpp_identity_identity_public_key_contract_bounds_ContractBounds { ferment :: boxed (match obj { dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds :: SingleContract { id } => dpp_identity_identity_public_key_contract_bounds_ContractBounds :: SingleContract { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (id) } , dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds :: SingleContractDocumentType { id , document_type_name } => dpp_identity_identity_public_key_contract_bounds_ContractBounds :: SingleContractDocumentType { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (document_type_name) } , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_identity_identity_public_key_contract_bounds_ContractBounds { fn drop (& mut self) { unsafe { match self { dpp_identity_identity_public_key_contract_bounds_ContractBounds :: SingleContract { id } => { ferment :: unbox_any (* id) ; } , dpp_identity_identity_public_key_contract_bounds_ContractBounds :: SingleContractDocumentType { id , document_type_name } => { ferment :: unbox_any (* id) ; ; ferment :: unbox_string (* document_type_name) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } # [doc = "FFI-representation of the [`KeyID`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_identity_public_key_KeyID (u32) ; impl ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID > for dpp_identity_identity_public_key_KeyID { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_public_key_KeyID) -> dpp :: identity :: identity_public_key :: KeyID { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID > for dpp_identity_identity_public_key_KeyID { unsafe fn ffi_to_const (obj : dpp :: identity :: identity_public_key :: KeyID) -> * const dpp_identity_identity_public_key_KeyID { ferment :: boxed (dpp_identity_identity_public_key_KeyID (obj)) } } # [doc = "FFI-representation of the [`KeyCount`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_identity_public_key_KeyCount (* mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID) ; impl ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyCount > for dpp_identity_identity_public_key_KeyCount { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_public_key_KeyCount) -> dpp :: identity :: identity_public_key :: KeyCount { let ffi_ref = & * ffi ; < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . 0) } } impl ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyCount > for dpp_identity_identity_public_key_KeyCount { unsafe fn ffi_to_const (obj : dpp :: identity :: identity_public_key :: KeyCount) -> * const dpp_identity_identity_public_key_KeyCount { ferment :: boxed (dpp_identity_identity_public_key_KeyCount (< crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj))) } } impl Drop for dpp_identity_identity_public_key_KeyCount { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [doc = "FFI-representation of the [`TimestampMillis`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_identity_public_key_TimestampMillis (u64) ; impl ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: TimestampMillis > for dpp_identity_identity_public_key_TimestampMillis { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_public_key_TimestampMillis) -> dpp :: identity :: identity_public_key :: TimestampMillis { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: TimestampMillis > for dpp_identity_identity_public_key_TimestampMillis { unsafe fn ffi_to_const (obj : dpp :: identity :: identity_public_key :: TimestampMillis) -> * const dpp_identity_identity_public_key_TimestampMillis { ferment :: boxed (dpp_identity_identity_public_key_TimestampMillis (obj)) } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`IdentityPublicKey`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_identity_identity_public_key_IdentityPublicKey { V0 (* mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: v0 :: dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) } impl ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: IdentityPublicKey > for dpp_identity_identity_public_key_IdentityPublicKey { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_public_key_IdentityPublicKey) -> dpp :: identity :: identity_public_key :: IdentityPublicKey { let ffi_ref = & * ffi ; match ffi_ref { dpp_identity_identity_public_key_IdentityPublicKey :: V0 (o_0) => dpp :: identity :: identity_public_key :: IdentityPublicKey :: V0 (< crate :: fermented :: types :: dpp :: identity :: identity_public_key :: v0 :: dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: v0 :: IdentityPublicKeyV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: IdentityPublicKey > for dpp_identity_identity_public_key_IdentityPublicKey { unsafe fn ffi_to_const (obj : dpp :: identity :: identity_public_key :: IdentityPublicKey) -> * const dpp_identity_identity_public_key_IdentityPublicKey { ferment :: boxed (match obj { dpp :: identity :: identity_public_key :: IdentityPublicKey :: V0 (o_0) => dpp_identity_identity_public_key_IdentityPublicKey :: V0 (< crate :: fermented :: types :: dpp :: identity :: identity_public_key :: v0 :: dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: v0 :: IdentityPublicKeyV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_identity_identity_public_key_IdentityPublicKey { fn drop (& mut self) { unsafe { match self { dpp_identity_identity_public_key_IdentityPublicKey :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod state_transition { pub mod asset_lock_proof { use crate as example_platform ; pub mod chain { pub mod chain_asset_lock_proof { use crate as example_platform ; # [doc = "FFI-representation of the [`ChainAssetLockProof`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof { pub core_chain_locked_height : u32 , pub out_point : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint } impl ferment :: FFIConversionFrom < dpp :: identity :: state_transition :: asset_lock_proof :: chain :: chain_asset_lock_proof :: ChainAssetLockProof > for dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof { unsafe fn ffi_from_const (ffi : * const dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof) -> dpp :: identity :: state_transition :: asset_lock_proof :: chain :: chain_asset_lock_proof :: ChainAssetLockProof { let ffi_ref = & * ffi ; dpp :: identity :: state_transition :: asset_lock_proof :: chain :: chain_asset_lock_proof :: ChainAssetLockProof { core_chain_locked_height : ffi_ref . core_chain_locked_height , out_point : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: outpoint :: OutPoint >> :: ffi_from (ffi_ref . out_point) } } } impl ferment :: FFIConversionTo < dpp :: identity :: state_transition :: asset_lock_proof :: chain :: chain_asset_lock_proof :: ChainAssetLockProof > for dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof { unsafe fn ffi_to_const (obj : dpp :: identity :: state_transition :: asset_lock_proof :: chain :: chain_asset_lock_proof :: ChainAssetLockProof) -> * const dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof { ferment :: boxed (dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof { core_chain_locked_height : obj . core_chain_locked_height , out_point : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: outpoint :: OutPoint >> :: ffi_to (obj . out_point) }) } } impl Drop for dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . out_point) ; } } } } } pub mod instant { pub mod instant_asset_lock_proof { use crate as example_platform ; # [doc = "FFI-representation of the [`InstantAssetLockProof`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof { pub instant_lock : * mut crate :: fermented :: types :: dashcore :: ephemerealdata :: instant_lock :: dashcore_ephemerealdata_instant_lock_InstantLock , pub transaction : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: dashcore_blockdata_transaction_Transaction , pub output_index : u32 } impl ferment :: FFIConversionFrom < dpp :: identity :: state_transition :: asset_lock_proof :: instant :: instant_asset_lock_proof :: InstantAssetLockProof > for dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof { unsafe fn ffi_from_const (ffi : * const dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof) -> dpp :: identity :: state_transition :: asset_lock_proof :: instant :: instant_asset_lock_proof :: InstantAssetLockProof { let ffi_ref = & * ffi ; dpp :: identity :: state_transition :: asset_lock_proof :: instant :: instant_asset_lock_proof :: InstantAssetLockProof { instant_lock : < crate :: fermented :: types :: dashcore :: ephemerealdata :: instant_lock :: dashcore_ephemerealdata_instant_lock_InstantLock as ferment :: FFIConversionFrom < dashcore :: ephemerealdata :: instant_lock :: InstantLock >> :: ffi_from (ffi_ref . instant_lock) , transaction : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: dashcore_blockdata_transaction_Transaction as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: Transaction >> :: ffi_from (ffi_ref . transaction) , output_index : ffi_ref . output_index } } } impl ferment :: FFIConversionTo < dpp :: identity :: state_transition :: asset_lock_proof :: instant :: instant_asset_lock_proof :: InstantAssetLockProof > for dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof { unsafe fn ffi_to_const (obj : dpp :: identity :: state_transition :: asset_lock_proof :: instant :: instant_asset_lock_proof :: InstantAssetLockProof) -> * const dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof { ferment :: boxed (dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof { instant_lock : < crate :: fermented :: types :: dashcore :: ephemerealdata :: instant_lock :: dashcore_ephemerealdata_instant_lock_InstantLock as ferment :: FFIConversionTo < dashcore :: ephemerealdata :: instant_lock :: InstantLock >> :: ffi_to (obj . instant_lock) , transaction : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: dashcore_blockdata_transaction_Transaction as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: Transaction >> :: ffi_to (obj . transaction) , output_index : obj . output_index }) } } impl Drop for dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . instant_lock) ; ferment :: unbox_any (ffi_ref . transaction) ; ; } } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`AssetLockProof`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_identity_state_transition_asset_lock_proof_AssetLockProof { Instant (* mut crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: instant :: instant_asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof) , Chain (* mut crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: chain :: chain_asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof) } impl ferment :: FFIConversionFrom < dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof > for dpp_identity_state_transition_asset_lock_proof_AssetLockProof { unsafe fn ffi_from_const (ffi : * const dpp_identity_state_transition_asset_lock_proof_AssetLockProof) -> dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof { let ffi_ref = & * ffi ; match ffi_ref { dpp_identity_state_transition_asset_lock_proof_AssetLockProof :: Instant (o_0) => dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof :: Instant (< crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: instant :: instant_asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof as ferment :: FFIConversionFrom < dpp :: identity :: state_transition :: asset_lock_proof :: instant :: instant_asset_lock_proof :: InstantAssetLockProof >> :: ffi_from (* o_0)) , dpp_identity_state_transition_asset_lock_proof_AssetLockProof :: Chain (o_0) => dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof :: Chain (< crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: chain :: chain_asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof as ferment :: FFIConversionFrom < dpp :: identity :: state_transition :: asset_lock_proof :: chain :: chain_asset_lock_proof :: ChainAssetLockProof >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof > for dpp_identity_state_transition_asset_lock_proof_AssetLockProof { unsafe fn ffi_to_const (obj : dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof) -> * const dpp_identity_state_transition_asset_lock_proof_AssetLockProof { ferment :: boxed (match obj { dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof :: Instant (o_0) => dpp_identity_state_transition_asset_lock_proof_AssetLockProof :: Instant (< crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: instant :: instant_asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof as ferment :: FFIConversionTo < dpp :: identity :: state_transition :: asset_lock_proof :: instant :: instant_asset_lock_proof :: InstantAssetLockProof >> :: ffi_to (o_0)) , dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof :: Chain (o_0) => dpp_identity_state_transition_asset_lock_proof_AssetLockProof :: Chain (< crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: chain :: chain_asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof as ferment :: FFIConversionTo < dpp :: identity :: state_transition :: asset_lock_proof :: chain :: chain_asset_lock_proof :: ChainAssetLockProof >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_identity_state_transition_asset_lock_proof_AssetLockProof { fn drop (& mut self) { unsafe { match self { dpp_identity_state_transition_asset_lock_proof_AssetLockProof :: Instant (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_identity_state_transition_asset_lock_proof_AssetLockProof :: Chain (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } } pub mod errors { pub mod asset_lock_output_not_found_error { use crate as example_platform ; # [doc = "FFI-representation of the [`AssetLockOutputNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError { } impl ferment :: FFIConversionFrom < dpp :: identity :: errors :: asset_lock_output_not_found_error :: AssetLockOutputNotFoundError > for dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError) -> dpp :: identity :: errors :: asset_lock_output_not_found_error :: AssetLockOutputNotFoundError { let ffi_ref = & * ffi ; dpp :: identity :: errors :: asset_lock_output_not_found_error :: AssetLockOutputNotFoundError { } } } impl ferment :: FFIConversionTo < dpp :: identity :: errors :: asset_lock_output_not_found_error :: AssetLockOutputNotFoundError > for dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError { unsafe fn ffi_to_const (obj : dpp :: identity :: errors :: asset_lock_output_not_found_error :: AssetLockOutputNotFoundError) -> * const dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError { ferment :: boxed (dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError { }) } } } pub mod asset_lock_transaction_is_not_found_error { use crate as example_platform ; # [doc = "FFI-representation of the [`AssetLockTransactionIsNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError { pub transaction_id : * mut dashcore :: hash_types :: Txid } impl ferment :: FFIConversionFrom < dpp :: identity :: errors :: asset_lock_transaction_is_not_found_error :: AssetLockTransactionIsNotFoundError > for dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError) -> dpp :: identity :: errors :: asset_lock_transaction_is_not_found_error :: AssetLockTransactionIsNotFoundError { let ffi_ref = & * ffi ; dpp :: identity :: errors :: asset_lock_transaction_is_not_found_error :: AssetLockTransactionIsNotFoundError { transaction_id : std :: ptr :: read (ffi_ref . transaction_id) } } } impl ferment :: FFIConversionTo < dpp :: identity :: errors :: asset_lock_transaction_is_not_found_error :: AssetLockTransactionIsNotFoundError > for dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError { unsafe fn ffi_to_const (obj : dpp :: identity :: errors :: asset_lock_transaction_is_not_found_error :: AssetLockTransactionIsNotFoundError) -> * const dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError { ferment :: boxed (dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError { transaction_id : ferment :: boxed (obj . transaction_id) }) } } impl Drop for dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . transaction_id) ; } } } } pub mod unknown_asset_lock_proof_type_error { use crate as example_platform ; # [doc = "FFI-representation of the [`UnknownAssetLockProofTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError { pub asset_lock_type : * mut u8 } impl ferment :: FFIConversionFrom < dpp :: identity :: errors :: unknown_asset_lock_proof_type_error :: UnknownAssetLockProofTypeError > for dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError { unsafe fn ffi_from_const (ffi : * const dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError) -> dpp :: identity :: errors :: unknown_asset_lock_proof_type_error :: UnknownAssetLockProofTypeError { let ffi_ref = & * ffi ; dpp :: identity :: errors :: unknown_asset_lock_proof_type_error :: UnknownAssetLockProofTypeError { asset_lock_type : ferment :: from_opt_primitive (ffi_ref . asset_lock_type) } } } impl ferment :: FFIConversionTo < dpp :: identity :: errors :: unknown_asset_lock_proof_type_error :: UnknownAssetLockProofTypeError > for dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError { unsafe fn ffi_to_const (obj : dpp :: identity :: errors :: unknown_asset_lock_proof_type_error :: UnknownAssetLockProofTypeError) -> * const dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError { ferment :: boxed (dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError { asset_lock_type : ferment :: to_opt_primitive (obj . asset_lock_type) }) } } impl Drop for dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any_opt (ffi_ref . asset_lock_type) ; } } } } } pub mod identity_nonce { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`MergeIdentityNonceResult`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_identity_identity_nonce_MergeIdentityNonceResult { InvalidNonce , NonceTooFarInFuture , NonceTooFarInPast , NonceAlreadyPresentAtTip , NonceAlreadyPresentInPast (u64) , MergeIdentityNonceSuccess (* mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce) } impl ferment :: FFIConversionFrom < dpp :: identity :: identity_nonce :: MergeIdentityNonceResult > for dpp_identity_identity_nonce_MergeIdentityNonceResult { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_nonce_MergeIdentityNonceResult) -> dpp :: identity :: identity_nonce :: MergeIdentityNonceResult { let ffi_ref = & * ffi ; match ffi_ref { dpp_identity_identity_nonce_MergeIdentityNonceResult :: InvalidNonce => dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: InvalidNonce , dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceTooFarInFuture => dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: NonceTooFarInFuture , dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceTooFarInPast => dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: NonceTooFarInPast , dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceAlreadyPresentAtTip => dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: NonceAlreadyPresentAtTip , dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceAlreadyPresentInPast (o_0) => dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: NonceAlreadyPresentInPast (* o_0) , dpp_identity_identity_nonce_MergeIdentityNonceResult :: MergeIdentityNonceSuccess (o_0) => dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: MergeIdentityNonceSuccess (< crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: identity :: identity_nonce :: MergeIdentityNonceResult > for dpp_identity_identity_nonce_MergeIdentityNonceResult { unsafe fn ffi_to_const (obj : dpp :: identity :: identity_nonce :: MergeIdentityNonceResult) -> * const dpp_identity_identity_nonce_MergeIdentityNonceResult { ferment :: boxed (match obj { dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: InvalidNonce => dpp_identity_identity_nonce_MergeIdentityNonceResult :: InvalidNonce , dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: NonceTooFarInFuture => dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceTooFarInFuture , dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: NonceTooFarInPast => dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceTooFarInPast , dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: NonceAlreadyPresentAtTip => dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceAlreadyPresentAtTip , dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: NonceAlreadyPresentInPast (o_0) => dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceAlreadyPresentInPast (o_0) , dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: MergeIdentityNonceSuccess (o_0) => dpp_identity_identity_nonce_MergeIdentityNonceResult :: MergeIdentityNonceSuccess (< crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_identity_identity_nonce_MergeIdentityNonceResult { fn drop (& mut self) { unsafe { match self { dpp_identity_identity_nonce_MergeIdentityNonceResult :: InvalidNonce => { } , dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceTooFarInFuture => { } , dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceTooFarInPast => { } , dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceAlreadyPresentAtTip => { } , dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceAlreadyPresentInPast (o_0) => { ; } , dpp_identity_identity_nonce_MergeIdentityNonceResult :: MergeIdentityNonceSuccess (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_v0_IdentityV0 { pub id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub public_keys : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey , pub balance : u64 , pub revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision } impl ferment :: FFIConversionFrom < dpp :: identity :: v0 :: IdentityV0 > for dpp_identity_v0_IdentityV0 { unsafe fn ffi_from_const (ffi : * const dpp_identity_v0_IdentityV0) -> dpp :: identity :: v0 :: IdentityV0 { let ffi_ref = & * ffi ; dpp :: identity :: v0 :: IdentityV0 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . id) , public_keys : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: identity :: identity_public_key :: KeyID , dpp :: identity :: identity_public_key :: IdentityPublicKey > >> :: ffi_from (ffi_ref . public_keys) , balance : ffi_ref . balance , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from (ffi_ref . revision) } } } impl ferment :: FFIConversionTo < dpp :: identity :: v0 :: IdentityV0 > for dpp_identity_v0_IdentityV0 { unsafe fn ffi_to_const (obj : dpp :: identity :: v0 :: IdentityV0) -> * const dpp_identity_v0_IdentityV0 { ferment :: boxed (dpp_identity_v0_IdentityV0 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . id) , public_keys : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: identity :: identity_public_key :: KeyID , dpp :: identity :: identity_public_key :: IdentityPublicKey > >> :: ffi_to (obj . public_keys) , balance : obj . balance , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to (obj . revision) }) } } impl Drop for dpp_identity_v0_IdentityV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; ferment :: unbox_any (ffi_ref . public_keys) ; ; ferment :: unbox_any (ffi_ref . revision) ; } } } } } pub mod metadata { use crate as example_platform ; # [doc = "FFI-representation of the [`Metadata`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_metadata_Metadata { pub block_height : u64 , pub core_chain_locked_height : u64 , pub time_ms : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis , pub protocol_version : * mut crate :: fermented :: types :: dpp :: util :: deserializer :: dpp_util_deserializer_ProtocolVersion } impl ferment :: FFIConversionFrom < dpp :: metadata :: Metadata > for dpp_metadata_Metadata { unsafe fn ffi_from_const (ffi : * const dpp_metadata_Metadata) -> dpp :: metadata :: Metadata { let ffi_ref = & * ffi ; dpp :: metadata :: Metadata { block_height : ffi_ref . block_height , core_chain_locked_height : ffi_ref . core_chain_locked_height , time_ms : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionFrom < dpp :: prelude :: TimestampMillis >> :: ffi_from (ffi_ref . time_ms) , protocol_version : < crate :: fermented :: types :: dpp :: util :: deserializer :: dpp_util_deserializer_ProtocolVersion as ferment :: FFIConversionFrom < dpp :: util :: deserializer :: ProtocolVersion >> :: ffi_from (ffi_ref . protocol_version) } } } impl ferment :: FFIConversionTo < dpp :: metadata :: Metadata > for dpp_metadata_Metadata { unsafe fn ffi_to_const (obj : dpp :: metadata :: Metadata) -> * const dpp_metadata_Metadata { ferment :: boxed (dpp_metadata_Metadata { block_height : obj . block_height , core_chain_locked_height : obj . core_chain_locked_height , time_ms : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionTo < dpp :: prelude :: TimestampMillis >> :: ffi_to (obj . time_ms) , protocol_version : < crate :: fermented :: types :: dpp :: util :: deserializer :: dpp_util_deserializer_ProtocolVersion as ferment :: FFIConversionTo < dpp :: util :: deserializer :: ProtocolVersion >> :: ffi_to (obj . protocol_version) }) } } impl Drop for dpp_metadata_Metadata { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ferment :: unbox_any (ffi_ref . time_ms) ; ferment :: unbox_any (ffi_ref . protocol_version) ; } } } } # [cfg (feature = "state-transitions")] pub mod state_transition { use crate as example_platform ; pub mod state_transition_types { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`StateTransitionType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transition_types_StateTransitionType { DataContractCreate = 0 , Batch = 1 , IdentityCreate = 2 , IdentityTopUp = 3 , DataContractUpdate = 4 , IdentityUpdate = 5 , IdentityCreditWithdrawal = 6 , IdentityCreditTransfer = 7 , MasternodeVote = 8 } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transition_types :: StateTransitionType > for dpp_state_transition_state_transition_types_StateTransitionType { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transition_types_StateTransitionType) -> dpp :: state_transition :: state_transition_types :: StateTransitionType { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transition_types_StateTransitionType :: DataContractCreate => dpp :: state_transition :: state_transition_types :: StateTransitionType :: DataContractCreate , dpp_state_transition_state_transition_types_StateTransitionType :: Batch => dpp :: state_transition :: state_transition_types :: StateTransitionType :: Batch , dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreate => dpp :: state_transition :: state_transition_types :: StateTransitionType :: IdentityCreate , dpp_state_transition_state_transition_types_StateTransitionType :: IdentityTopUp => dpp :: state_transition :: state_transition_types :: StateTransitionType :: IdentityTopUp , dpp_state_transition_state_transition_types_StateTransitionType :: DataContractUpdate => dpp :: state_transition :: state_transition_types :: StateTransitionType :: DataContractUpdate , dpp_state_transition_state_transition_types_StateTransitionType :: IdentityUpdate => dpp :: state_transition :: state_transition_types :: StateTransitionType :: IdentityUpdate , dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreditWithdrawal => dpp :: state_transition :: state_transition_types :: StateTransitionType :: IdentityCreditWithdrawal , dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreditTransfer => dpp :: state_transition :: state_transition_types :: StateTransitionType :: IdentityCreditTransfer , dpp_state_transition_state_transition_types_StateTransitionType :: MasternodeVote => dpp :: state_transition :: state_transition_types :: StateTransitionType :: MasternodeVote } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transition_types :: StateTransitionType > for dpp_state_transition_state_transition_types_StateTransitionType { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transition_types :: StateTransitionType) -> * const dpp_state_transition_state_transition_types_StateTransitionType { ferment :: boxed (match obj { dpp :: state_transition :: state_transition_types :: StateTransitionType :: DataContractCreate => dpp_state_transition_state_transition_types_StateTransitionType :: DataContractCreate , dpp :: state_transition :: state_transition_types :: StateTransitionType :: Batch => dpp_state_transition_state_transition_types_StateTransitionType :: Batch , dpp :: state_transition :: state_transition_types :: StateTransitionType :: IdentityCreate => dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreate , dpp :: state_transition :: state_transition_types :: StateTransitionType :: IdentityTopUp => dpp_state_transition_state_transition_types_StateTransitionType :: IdentityTopUp , dpp :: state_transition :: state_transition_types :: StateTransitionType :: DataContractUpdate => dpp_state_transition_state_transition_types_StateTransitionType :: DataContractUpdate , dpp :: state_transition :: state_transition_types :: StateTransitionType :: IdentityUpdate => dpp_state_transition_state_transition_types_StateTransitionType :: IdentityUpdate , dpp :: state_transition :: state_transition_types :: StateTransitionType :: IdentityCreditWithdrawal => dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreditWithdrawal , dpp :: state_transition :: state_transition_types :: StateTransitionType :: IdentityCreditTransfer => dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreditTransfer , dpp :: state_transition :: state_transition_types :: StateTransitionType :: MasternodeVote => dpp_state_transition_state_transition_types_StateTransitionType :: MasternodeVote , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transition_types_StateTransitionType { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transition_types_StateTransitionType :: DataContractCreate => { } , dpp_state_transition_state_transition_types_StateTransitionType :: Batch => { } , dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreate => { } , dpp_state_transition_state_transition_types_StateTransitionType :: IdentityTopUp => { } , dpp_state_transition_state_transition_types_StateTransitionType :: DataContractUpdate => { } , dpp_state_transition_state_transition_types_StateTransitionType :: IdentityUpdate => { } , dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreditWithdrawal => { } , dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreditTransfer => { } , dpp_state_transition_state_transition_types_StateTransitionType :: MasternodeVote => { } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod errors { # [cfg (any (feature = "state-transition-validation" , feature = "state-transition-signing"))] pub mod invalid_identity_public_key_type_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidIdentityPublicKeyTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { pub public_key_type : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType } impl ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError > for dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) -> dpp :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError { let ffi_ref = & * ffi ; dpp :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError { public_key_type : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: key_type :: KeyType >> :: ffi_from (ffi_ref . public_key_type) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError > for dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { unsafe fn ffi_to_const (obj : dpp :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError) -> * const dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { ferment :: boxed (dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { public_key_type : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: key_type :: KeyType >> :: ffi_to (obj . public_key_type) }) } } impl Drop for dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_type) ; } } } } # [cfg (any (feature = "state-transition-validation" , feature = "state-transition-signing"))] pub mod invalid_signature_public_key_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidSignaturePublicKeyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError { pub public_key : * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: invalid_signature_public_key_error :: InvalidSignaturePublicKeyError > for dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError) -> dpp :: state_transition :: errors :: invalid_signature_public_key_error :: InvalidSignaturePublicKeyError { let ffi_ref = & * ffi ; dpp :: state_transition :: errors :: invalid_signature_public_key_error :: InvalidSignaturePublicKeyError { public_key : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . public_key) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: errors :: invalid_signature_public_key_error :: InvalidSignaturePublicKeyError > for dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError { unsafe fn ffi_to_const (obj : dpp :: state_transition :: errors :: invalid_signature_public_key_error :: InvalidSignaturePublicKeyError) -> * const dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError { ferment :: boxed (dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError { public_key : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . public_key) }) } } impl Drop for dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key) ; } } } } # [cfg (feature = "state-transition-validation")] pub mod public_key_mismatch_error { use crate as example_platform ; # [doc = "FFI-representation of the [`PublicKeyMismatchError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError { pub public_key : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_IdentityPublicKey } impl ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: public_key_mismatch_error :: PublicKeyMismatchError > for dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError) -> dpp :: state_transition :: errors :: public_key_mismatch_error :: PublicKeyMismatchError { let ffi_ref = & * ffi ; dpp :: state_transition :: errors :: public_key_mismatch_error :: PublicKeyMismatchError { public_key : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_IdentityPublicKey as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: IdentityPublicKey >> :: ffi_from (ffi_ref . public_key) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: errors :: public_key_mismatch_error :: PublicKeyMismatchError > for dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError { unsafe fn ffi_to_const (obj : dpp :: state_transition :: errors :: public_key_mismatch_error :: PublicKeyMismatchError) -> * const dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError { ferment :: boxed (dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError { public_key : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_IdentityPublicKey as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: IdentityPublicKey >> :: ffi_to (obj . public_key) }) } } impl Drop for dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key) ; } } } } # [cfg (feature = "state-transition-validation")] pub mod public_key_security_level_not_met_error { use crate as example_platform ; # [doc = "FFI-representation of the [`PublicKeySecurityLevelNotMetError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { pub public_key_security_level : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel , pub required_security_level : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel } impl ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError > for dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError) -> dpp :: state_transition :: errors :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError { let ffi_ref = & * ffi ; dpp :: state_transition :: errors :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError { public_key_security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_from (ffi_ref . public_key_security_level) , required_security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_from (ffi_ref . required_security_level) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: errors :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError > for dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { unsafe fn ffi_to_const (obj : dpp :: state_transition :: errors :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError) -> * const dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { ferment :: boxed (dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { public_key_security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_to (obj . public_key_security_level) , required_security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_to (obj . required_security_level) }) } } impl Drop for dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_security_level) ; ferment :: unbox_any (ffi_ref . required_security_level) ; } } } } # [cfg (any (all (feature = "state-transitions" , feature = "validation") , feature = "state-transition-validation"))] pub mod state_transition_error { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`StateTransitionError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_errors_state_transition_error_StateTransitionError { InvalidStateTransitionError { errors : * mut crate :: fermented :: generics :: Vec_dpp_errors_consensus_consensus_error_ConsensusError , raw_state_transition : * mut crate :: fermented :: types :: platform_value :: platform_value_Value } , StateTransitionIsNotActiveError { state_transition_type : * mut std :: os :: raw :: c_char , active_version_range : * mut std :: ops :: RangeInclusive < dpp :: util :: deserializer :: ProtocolVersion > , current_protocol_version : * mut crate :: fermented :: types :: dpp :: util :: deserializer :: dpp_util_deserializer_ProtocolVersion } } impl ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: state_transition_error :: StateTransitionError > for dpp_state_transition_errors_state_transition_error_StateTransitionError { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_errors_state_transition_error_StateTransitionError) -> dpp :: state_transition :: errors :: state_transition_error :: StateTransitionError { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_errors_state_transition_error_StateTransitionError :: InvalidStateTransitionError { errors , raw_state_transition } => dpp :: state_transition :: errors :: state_transition_error :: StateTransitionError :: InvalidStateTransitionError { errors : < crate :: fermented :: generics :: Vec_dpp_errors_consensus_consensus_error_ConsensusError as ferment :: FFIConversionFrom < Vec < dpp :: errors :: consensus :: consensus_error :: ConsensusError > >> :: ffi_from (* errors) , raw_state_transition : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (* raw_state_transition) } , dpp_state_transition_errors_state_transition_error_StateTransitionError :: StateTransitionIsNotActiveError { state_transition_type , active_version_range , current_protocol_version } => dpp :: state_transition :: errors :: state_transition_error :: StateTransitionError :: StateTransitionIsNotActiveError { state_transition_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* state_transition_type) , active_version_range : std :: ptr :: read (* active_version_range) , current_protocol_version : < crate :: fermented :: types :: dpp :: util :: deserializer :: dpp_util_deserializer_ProtocolVersion as ferment :: FFIConversionFrom < dpp :: util :: deserializer :: ProtocolVersion >> :: ffi_from (* current_protocol_version) } } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: errors :: state_transition_error :: StateTransitionError > for dpp_state_transition_errors_state_transition_error_StateTransitionError { unsafe fn ffi_to_const (obj : dpp :: state_transition :: errors :: state_transition_error :: StateTransitionError) -> * const dpp_state_transition_errors_state_transition_error_StateTransitionError { ferment :: boxed (match obj { dpp :: state_transition :: errors :: state_transition_error :: StateTransitionError :: InvalidStateTransitionError { errors , raw_state_transition } => dpp_state_transition_errors_state_transition_error_StateTransitionError :: InvalidStateTransitionError { errors : < crate :: fermented :: generics :: Vec_dpp_errors_consensus_consensus_error_ConsensusError as ferment :: FFIConversionTo < Vec < dpp :: errors :: consensus :: consensus_error :: ConsensusError > >> :: ffi_to (errors) , raw_state_transition : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (raw_state_transition) } , dpp :: state_transition :: errors :: state_transition_error :: StateTransitionError :: StateTransitionIsNotActiveError { state_transition_type , active_version_range , current_protocol_version } => dpp_state_transition_errors_state_transition_error_StateTransitionError :: StateTransitionIsNotActiveError { state_transition_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (state_transition_type) , active_version_range : ferment :: boxed (active_version_range) , current_protocol_version : < crate :: fermented :: types :: dpp :: util :: deserializer :: dpp_util_deserializer_ProtocolVersion as ferment :: FFIConversionTo < dpp :: util :: deserializer :: ProtocolVersion >> :: ffi_to (current_protocol_version) } , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_errors_state_transition_error_StateTransitionError { fn drop (& mut self) { unsafe { match self { dpp_state_transition_errors_state_transition_error_StateTransitionError :: InvalidStateTransitionError { errors , raw_state_transition } => { ferment :: unbox_any (* errors) ; ; ferment :: unbox_any (* raw_state_transition) ; } , dpp_state_transition_errors_state_transition_error_StateTransitionError :: StateTransitionIsNotActiveError { state_transition_type , active_version_range , current_protocol_version } => { ferment :: unbox_string (* state_transition_type) ; ; ferment :: unbox_any (* active_version_range) ; ; ferment :: unbox_any (* current_protocol_version) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } # [cfg (feature = "state-transition-validation")] pub mod state_transition_is_not_signed_error { use crate as example_platform ; # [doc = "FFI-representation of the [`StateTransitionIsNotSignedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError { pub state_transition : * mut crate :: fermented :: types :: dpp :: state_transition :: dpp_state_transition_StateTransition } impl ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: state_transition_is_not_signed_error :: StateTransitionIsNotSignedError > for dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError) -> dpp :: state_transition :: errors :: state_transition_is_not_signed_error :: StateTransitionIsNotSignedError { let ffi_ref = & * ffi ; dpp :: state_transition :: errors :: state_transition_is_not_signed_error :: StateTransitionIsNotSignedError { state_transition : < crate :: fermented :: types :: dpp :: state_transition :: dpp_state_transition_StateTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: StateTransition >> :: ffi_from (ffi_ref . state_transition) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: errors :: state_transition_is_not_signed_error :: StateTransitionIsNotSignedError > for dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError { unsafe fn ffi_to_const (obj : dpp :: state_transition :: errors :: state_transition_is_not_signed_error :: StateTransitionIsNotSignedError) -> * const dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError { ferment :: boxed (dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError { state_transition : < crate :: fermented :: types :: dpp :: state_transition :: dpp_state_transition_StateTransition as ferment :: FFIConversionTo < dpp :: state_transition :: StateTransition >> :: ffi_to (obj . state_transition) }) } } impl Drop for dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . state_transition) ; } } } } # [cfg (any (all (feature = "state-transitions" , feature = "validation") , feature = "state-transition-validation" , feature = "state-transition-signing" , feature = "state-transition-validation"))] pub mod wrong_public_key_purpose_error { use crate as example_platform ; # [doc = "FFI-representation of the [`WrongPublicKeyPurposeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_errors_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { pub public_key_purpose : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose , pub allowed_key_purposes : * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_purpose_Purpose } impl ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError > for dpp_state_transition_errors_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_errors_wrong_public_key_purpose_error_WrongPublicKeyPurposeError) -> dpp :: state_transition :: errors :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError { let ffi_ref = & * ffi ; dpp :: state_transition :: errors :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError { public_key_purpose : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: purpose :: Purpose >> :: ffi_from (ffi_ref . public_key_purpose) , allowed_key_purposes : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionFrom < Vec < dpp :: identity :: identity_public_key :: purpose :: Purpose > >> :: ffi_from (ffi_ref . allowed_key_purposes) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: errors :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError > for dpp_state_transition_errors_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { unsafe fn ffi_to_const (obj : dpp :: state_transition :: errors :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError) -> * const dpp_state_transition_errors_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { ferment :: boxed (dpp_state_transition_errors_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { public_key_purpose : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: purpose :: Purpose >> :: ffi_to (obj . public_key_purpose) , allowed_key_purposes : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionTo < Vec < dpp :: identity :: identity_public_key :: purpose :: Purpose > >> :: ffi_to (obj . allowed_key_purposes) }) } } impl Drop for dpp_state_transition_errors_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_purpose) ; ferment :: unbox_any (ffi_ref . allowed_key_purposes) ; } } } } } pub mod proof_result { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`StateTransitionProofResult`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_proof_result_StateTransitionProofResult { VerifiedDataContract (* mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DataContract) , VerifiedIdentity (* mut crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_Identity) , VerifiedTokenBalanceAbsence (* mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) , VerifiedTokenBalance (* mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount) , VerifiedTokenIdentityInfo (* mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , * mut crate :: fermented :: types :: dpp :: tokens :: info :: dpp_tokens_info_IdentityTokenInfo) , VerifiedTokenPricingSchedule (* mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , * mut crate :: fermented :: types :: dpp :: tokens :: token_pricing_schedule :: dpp_tokens_token_pricing_schedule_TokenPricingSchedule) , VerifiedTokenStatus (* mut crate :: fermented :: types :: dpp :: tokens :: status :: dpp_tokens_status_TokenStatus) , VerifiedTokenIdentitiesBalances (* mut crate :: fermented :: generics :: std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount) , VerifiedPartialIdentity (* mut crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_PartialIdentity) , VerifiedBalanceTransfer (* mut crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_PartialIdentity , * mut crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_PartialIdentity) , VerifiedDocuments (* mut crate :: fermented :: generics :: std_collections_Map_keys_platform_value_types_identifier_Identifier_values_Option_dpp_document_Document) , VerifiedTokenActionWithDocument (* mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document) , VerifiedTokenGroupActionWithDocument (* mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupSumPower , * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document) , VerifiedTokenGroupActionWithTokenBalance (* mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupSumPower , * mut crate :: fermented :: types :: dpp :: group :: group_action_status :: dpp_group_group_action_status_GroupActionStatus , * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount) , VerifiedTokenGroupActionWithTokenIdentityInfo (* mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupSumPower , * mut crate :: fermented :: types :: dpp :: group :: group_action_status :: dpp_group_group_action_status_GroupActionStatus , * mut crate :: fermented :: types :: dpp :: tokens :: info :: dpp_tokens_info_IdentityTokenInfo) , VerifiedTokenGroupActionWithTokenPricingSchedule (* mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupSumPower , * mut crate :: fermented :: types :: dpp :: group :: group_action_status :: dpp_group_group_action_status_GroupActionStatus , * mut crate :: fermented :: types :: dpp :: tokens :: token_pricing_schedule :: dpp_tokens_token_pricing_schedule_TokenPricingSchedule) , VerifiedMasternodeVote (* mut crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote) , VerifiedNextDistribution (* mut crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: proof_result :: StateTransitionProofResult > for dpp_state_transition_proof_result_StateTransitionProofResult { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_proof_result_StateTransitionProofResult) -> dpp :: state_transition :: proof_result :: StateTransitionProofResult { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedDataContract (o_0) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedDataContract (< crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DataContract as ferment :: FFIConversionFrom < dpp :: data_contract :: DataContract >> :: ffi_from (* o_0)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedIdentity (o_0) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedIdentity (< crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_Identity as ferment :: FFIConversionFrom < dpp :: identity :: identity :: Identity >> :: ffi_from (* o_0)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenBalanceAbsence (o_0) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenBalanceAbsence (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (* o_0)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenBalance (o_0 , o_1) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenBalance (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (* o_0) , < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (* o_1)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenIdentityInfo (o_0 , o_1) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenIdentityInfo (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (* o_0) , < crate :: fermented :: types :: dpp :: tokens :: info :: dpp_tokens_info_IdentityTokenInfo as ferment :: FFIConversionFrom < dpp :: tokens :: info :: IdentityTokenInfo >> :: ffi_from (* o_1)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenPricingSchedule (o_0 , o_1) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenPricingSchedule (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (* o_0) , < crate :: fermented :: types :: dpp :: tokens :: token_pricing_schedule :: dpp_tokens_token_pricing_schedule_TokenPricingSchedule as ferment :: FFIConversionFrom < dpp :: tokens :: token_pricing_schedule :: TokenPricingSchedule >> :: ffi_from_opt (* o_1)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenStatus (o_0) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenStatus (< crate :: fermented :: types :: dpp :: tokens :: status :: dpp_tokens_status_TokenStatus as ferment :: FFIConversionFrom < dpp :: tokens :: status :: TokenStatus >> :: ffi_from (* o_0)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenIdentitiesBalances (o_0) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenIdentitiesBalances (< crate :: fermented :: generics :: std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , dpp :: balances :: credits :: TokenAmount > >> :: ffi_from (* o_0)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedPartialIdentity (o_0) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedPartialIdentity (< crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_PartialIdentity as ferment :: FFIConversionFrom < dpp :: identity :: identity :: PartialIdentity >> :: ffi_from (* o_0)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedBalanceTransfer (o_0 , o_1) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedBalanceTransfer (< crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_PartialIdentity as ferment :: FFIConversionFrom < dpp :: identity :: identity :: PartialIdentity >> :: ffi_from (* o_0) , < crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_PartialIdentity as ferment :: FFIConversionFrom < dpp :: identity :: identity :: PartialIdentity >> :: ffi_from (* o_1)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedDocuments (o_0) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedDocuments (< crate :: fermented :: generics :: std_collections_Map_keys_platform_value_types_identifier_Identifier_values_Option_dpp_document_Document as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , Option < dpp :: document :: Document > > >> :: ffi_from (* o_0)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenActionWithDocument (o_0) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenActionWithDocument (< crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionFrom < dpp :: document :: Document >> :: ffi_from (* o_0)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenGroupActionWithDocument (o_0 , o_1) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenGroupActionWithDocument (< crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupSumPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupSumPower >> :: ffi_from (* o_0) , < crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionFrom < dpp :: document :: Document >> :: ffi_from_opt (* o_1)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenBalance (o_0 , o_1 , o_2) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenBalance (< crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupSumPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupSumPower >> :: ffi_from (* o_0) , < crate :: fermented :: types :: dpp :: group :: group_action_status :: dpp_group_group_action_status_GroupActionStatus as ferment :: FFIConversionFrom < dpp :: group :: group_action_status :: GroupActionStatus >> :: ffi_from (* o_1) , < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from_opt (* o_2)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenIdentityInfo (o_0 , o_1 , o_2) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenIdentityInfo (< crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupSumPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupSumPower >> :: ffi_from (* o_0) , < crate :: fermented :: types :: dpp :: group :: group_action_status :: dpp_group_group_action_status_GroupActionStatus as ferment :: FFIConversionFrom < dpp :: group :: group_action_status :: GroupActionStatus >> :: ffi_from (* o_1) , < crate :: fermented :: types :: dpp :: tokens :: info :: dpp_tokens_info_IdentityTokenInfo as ferment :: FFIConversionFrom < dpp :: tokens :: info :: IdentityTokenInfo >> :: ffi_from_opt (* o_2)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenPricingSchedule (o_0 , o_1 , o_2) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenPricingSchedule (< crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupSumPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupSumPower >> :: ffi_from (* o_0) , < crate :: fermented :: types :: dpp :: group :: group_action_status :: dpp_group_group_action_status_GroupActionStatus as ferment :: FFIConversionFrom < dpp :: group :: group_action_status :: GroupActionStatus >> :: ffi_from (* o_1) , < crate :: fermented :: types :: dpp :: tokens :: token_pricing_schedule :: dpp_tokens_token_pricing_schedule_TokenPricingSchedule as ferment :: FFIConversionFrom < dpp :: tokens :: token_pricing_schedule :: TokenPricingSchedule >> :: ffi_from_opt (* o_2)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedMasternodeVote (o_0) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedMasternodeVote (< crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote as ferment :: FFIConversionFrom < dpp :: voting :: votes :: Vote >> :: ffi_from (* o_0)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedNextDistribution (o_0) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedNextDistribution (< crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote as ferment :: FFIConversionFrom < dpp :: voting :: votes :: Vote >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: proof_result :: StateTransitionProofResult > for dpp_state_transition_proof_result_StateTransitionProofResult { unsafe fn ffi_to_const (obj : dpp :: state_transition :: proof_result :: StateTransitionProofResult) -> * const dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (match obj { dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedDataContract (o_0) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedDataContract (< crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DataContract as ferment :: FFIConversionTo < dpp :: data_contract :: DataContract >> :: ffi_to (o_0)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedIdentity (o_0) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedIdentity (< crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_Identity as ferment :: FFIConversionTo < dpp :: identity :: identity :: Identity >> :: ffi_to (o_0)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenBalanceAbsence (o_0) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenBalanceAbsence (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (o_0)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenBalance (o_0 , o_1) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenBalance (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (o_0) , < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (o_1)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenIdentityInfo (o_0 , o_1) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenIdentityInfo (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (o_0) , < crate :: fermented :: types :: dpp :: tokens :: info :: dpp_tokens_info_IdentityTokenInfo as ferment :: FFIConversionTo < dpp :: tokens :: info :: IdentityTokenInfo >> :: ffi_to (o_1)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenPricingSchedule (o_0 , o_1) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenPricingSchedule (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (o_0) , < crate :: fermented :: types :: dpp :: tokens :: token_pricing_schedule :: dpp_tokens_token_pricing_schedule_TokenPricingSchedule as ferment :: FFIConversionTo < dpp :: tokens :: token_pricing_schedule :: TokenPricingSchedule >> :: ffi_to_opt (o_1)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenStatus (o_0) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenStatus (< crate :: fermented :: types :: dpp :: tokens :: status :: dpp_tokens_status_TokenStatus as ferment :: FFIConversionTo < dpp :: tokens :: status :: TokenStatus >> :: ffi_to (o_0)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenIdentitiesBalances (o_0) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenIdentitiesBalances (< crate :: fermented :: generics :: std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , dpp :: balances :: credits :: TokenAmount > >> :: ffi_to (o_0)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedPartialIdentity (o_0) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedPartialIdentity (< crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_PartialIdentity as ferment :: FFIConversionTo < dpp :: identity :: identity :: PartialIdentity >> :: ffi_to (o_0)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedBalanceTransfer (o_0 , o_1) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedBalanceTransfer (< crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_PartialIdentity as ferment :: FFIConversionTo < dpp :: identity :: identity :: PartialIdentity >> :: ffi_to (o_0) , < crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_PartialIdentity as ferment :: FFIConversionTo < dpp :: identity :: identity :: PartialIdentity >> :: ffi_to (o_1)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedDocuments (o_0) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedDocuments (< crate :: fermented :: generics :: std_collections_Map_keys_platform_value_types_identifier_Identifier_values_Option_dpp_document_Document as ferment :: FFIConversionTo < std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , Option < dpp :: document :: Document > > >> :: ffi_to (o_0)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenActionWithDocument (o_0) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenActionWithDocument (< crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionTo < dpp :: document :: Document >> :: ffi_to (o_0)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenGroupActionWithDocument (o_0 , o_1) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenGroupActionWithDocument (< crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupSumPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupSumPower >> :: ffi_to (o_0) , < crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionTo < dpp :: document :: Document >> :: ffi_to_opt (o_1)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenBalance (o_0 , o_1 , o_2) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenBalance (< crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupSumPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupSumPower >> :: ffi_to (o_0) , < crate :: fermented :: types :: dpp :: group :: group_action_status :: dpp_group_group_action_status_GroupActionStatus as ferment :: FFIConversionTo < dpp :: group :: group_action_status :: GroupActionStatus >> :: ffi_to (o_1) , < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to_opt (o_2)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenIdentityInfo (o_0 , o_1 , o_2) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenIdentityInfo (< crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupSumPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupSumPower >> :: ffi_to (o_0) , < crate :: fermented :: types :: dpp :: group :: group_action_status :: dpp_group_group_action_status_GroupActionStatus as ferment :: FFIConversionTo < dpp :: group :: group_action_status :: GroupActionStatus >> :: ffi_to (o_1) , < crate :: fermented :: types :: dpp :: tokens :: info :: dpp_tokens_info_IdentityTokenInfo as ferment :: FFIConversionTo < dpp :: tokens :: info :: IdentityTokenInfo >> :: ffi_to_opt (o_2)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenPricingSchedule (o_0 , o_1 , o_2) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenPricingSchedule (< crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupSumPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupSumPower >> :: ffi_to (o_0) , < crate :: fermented :: types :: dpp :: group :: group_action_status :: dpp_group_group_action_status_GroupActionStatus as ferment :: FFIConversionTo < dpp :: group :: group_action_status :: GroupActionStatus >> :: ffi_to (o_1) , < crate :: fermented :: types :: dpp :: tokens :: token_pricing_schedule :: dpp_tokens_token_pricing_schedule_TokenPricingSchedule as ferment :: FFIConversionTo < dpp :: tokens :: token_pricing_schedule :: TokenPricingSchedule >> :: ffi_to_opt (o_2)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedMasternodeVote (o_0) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedMasternodeVote (< crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote as ferment :: FFIConversionTo < dpp :: voting :: votes :: Vote >> :: ffi_to (o_0)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedNextDistribution (o_0) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedNextDistribution (< crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote as ferment :: FFIConversionTo < dpp :: voting :: votes :: Vote >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_proof_result_StateTransitionProofResult { fn drop (& mut self) { unsafe { match self { dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedDataContract (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedIdentity (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenBalanceAbsence (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenBalance (o_0 , o_1) => { ferment :: unbox_any (* o_0) ; ; ferment :: unbox_any (* o_1) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenIdentityInfo (o_0 , o_1) => { ferment :: unbox_any (* o_0) ; ; ferment :: unbox_any (* o_1) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenPricingSchedule (o_0 , o_1) => { ferment :: unbox_any (* o_0) ; ; ferment :: unbox_any_opt (* o_1) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenStatus (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenIdentitiesBalances (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedPartialIdentity (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedBalanceTransfer (o_0 , o_1) => { ferment :: unbox_any (* o_0) ; ; ferment :: unbox_any (* o_1) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedDocuments (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenActionWithDocument (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenGroupActionWithDocument (o_0 , o_1) => { ferment :: unbox_any (* o_0) ; ; ferment :: unbox_any_opt (* o_1) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenBalance (o_0 , o_1 , o_2) => { ferment :: unbox_any (* o_0) ; ; ferment :: unbox_any (* o_1) ; ; ferment :: unbox_any_opt (* o_2) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenIdentityInfo (o_0 , o_1 , o_2) => { ferment :: unbox_any (* o_0) ; ; ferment :: unbox_any (* o_1) ; ; ferment :: unbox_any_opt (* o_2) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenPricingSchedule (o_0 , o_1 , o_2) => { ferment :: unbox_any (* o_0) ; ; ferment :: unbox_any (* o_1) ; ; ferment :: unbox_any_opt (* o_2) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedMasternodeVote (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedNextDistribution (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod state_transitions { pub mod contract { pub mod data_contract_create_transition { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`DataContractCreateTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { pub data_contract : * mut crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: dpp_data_contract_serialized_version_DataContractInSerializationFormat , pub identity_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , pub signature_public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , pub signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0 > for dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0) -> dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0 { data_contract : < crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: dpp_data_contract_serialized_version_DataContractInSerializationFormat as ferment :: FFIConversionFrom < dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat >> :: ffi_from (ffi_ref . data_contract) , identity_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . identity_nonce) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease >> :: ffi_from (ffi_ref . user_fee_increase) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionFrom < platform_value :: types :: binary_data :: BinaryData >> :: ffi_from (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0 > for dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0) -> * const dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { data_contract : < crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: dpp_data_contract_serialized_version_DataContractInSerializationFormat as ferment :: FFIConversionTo < dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat >> :: ffi_to (obj . data_contract) , identity_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . identity_nonce) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease >> :: ffi_to (obj . user_fee_increase) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionTo < platform_value :: types :: binary_data :: BinaryData >> :: ffi_to (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract) ; ferment :: unbox_any (ffi_ref . identity_nonce) ; ferment :: unbox_any (ffi_ref . user_fee_increase) ; ferment :: unbox_any (ffi_ref . signature_public_key_id) ; ferment :: unbox_any (ffi_ref . signature) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DataContractCreateTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition > for dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition) -> dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition > for dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition) -> * const dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition :: V0 (o_0) => dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod data_contract_update_transition { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`DataContractUpdateTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0 { pub identity_contract_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub data_contract : * mut crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: dpp_data_contract_serialized_version_DataContractInSerializationFormat , pub user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , pub signature_public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , pub signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: v0 :: DataContractUpdateTransitionV0 > for dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0) -> dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: v0 :: DataContractUpdateTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: v0 :: DataContractUpdateTransitionV0 { identity_contract_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . identity_contract_nonce) , data_contract : < crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: dpp_data_contract_serialized_version_DataContractInSerializationFormat as ferment :: FFIConversionFrom < dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat >> :: ffi_from (ffi_ref . data_contract) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease >> :: ffi_from (ffi_ref . user_fee_increase) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionFrom < platform_value :: types :: binary_data :: BinaryData >> :: ffi_from (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: v0 :: DataContractUpdateTransitionV0 > for dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: v0 :: DataContractUpdateTransitionV0) -> * const dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0 { identity_contract_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . identity_contract_nonce) , data_contract : < crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: dpp_data_contract_serialized_version_DataContractInSerializationFormat as ferment :: FFIConversionTo < dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat >> :: ffi_to (obj . data_contract) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease >> :: ffi_to (obj . user_fee_increase) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionTo < platform_value :: types :: binary_data :: BinaryData >> :: ffi_to (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_contract_nonce) ; ferment :: unbox_any (ffi_ref . data_contract) ; ferment :: unbox_any (ffi_ref . user_fee_increase) ; ferment :: unbox_any (ffi_ref . signature_public_key_id) ; ferment :: unbox_any (ffi_ref . signature) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DataContractUpdateTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: v0 :: dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition > for dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition) -> dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: v0 :: dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: v0 :: DataContractUpdateTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition > for dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition) -> * const dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition :: V0 (o_0) => dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: v0 :: dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: v0 :: DataContractUpdateTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } } pub mod document { pub mod batch_transition { use crate as example_platform ; pub mod batched_transition { use crate as example_platform ; pub mod document_base_transition { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`DocumentBaseTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0 { pub id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub identity_contract_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub document_type_name : * mut std :: os :: raw :: c_char , pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v0 :: DocumentBaseTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v0 :: DocumentBaseTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v0 :: DocumentBaseTransitionV0 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . id) , identity_contract_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . identity_contract_nonce) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type_name) , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v0 :: DocumentBaseTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v0 :: DocumentBaseTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . id) , identity_contract_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . identity_contract_nonce) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type_name) , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; ferment :: unbox_any (ffi_ref . identity_contract_nonce) ; ferment :: unbox_string (ffi_ref . document_type_name) ; ferment :: unbox_any (ffi_ref . data_contract_id) ; } } } } pub mod v1 { use crate as example_platform ; # [doc = "FFI-representation of the [`DocumentBaseTransitionV1`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1 { pub id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub identity_contract_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub document_type_name : * mut std :: os :: raw :: c_char , pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub token_payment_info : * mut crate :: fermented :: types :: dpp :: tokens :: token_payment_info :: dpp_tokens_token_payment_info_TokenPaymentInfo } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v1 :: DocumentBaseTransitionV1 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v1 :: DocumentBaseTransitionV1 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v1 :: DocumentBaseTransitionV1 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . id) , identity_contract_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . identity_contract_nonce) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type_name) , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , token_payment_info : < crate :: fermented :: types :: dpp :: tokens :: token_payment_info :: dpp_tokens_token_payment_info_TokenPaymentInfo as ferment :: FFIConversionFrom < dpp :: tokens :: token_payment_info :: TokenPaymentInfo >> :: ffi_from_opt (ffi_ref . token_payment_info) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v1 :: DocumentBaseTransitionV1 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v1 :: DocumentBaseTransitionV1) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . id) , identity_contract_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . identity_contract_nonce) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type_name) , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , token_payment_info : < crate :: fermented :: types :: dpp :: tokens :: token_payment_info :: dpp_tokens_token_payment_info_TokenPaymentInfo as ferment :: FFIConversionTo < dpp :: tokens :: token_payment_info :: TokenPaymentInfo >> :: ffi_to_opt (obj . token_payment_info) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; ferment :: unbox_any (ffi_ref . identity_contract_nonce) ; ferment :: unbox_string (ffi_ref . document_type_name) ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any_opt (ffi_ref . token_payment_info) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentBaseTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0) , V1 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v1 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v0 :: DocumentBaseTransitionV0 >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition :: V1 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition :: V1 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v1 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v1 :: DocumentBaseTransitionV1 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v0 :: DocumentBaseTransitionV0 >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition :: V1 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition :: V1 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v1 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v1 :: DocumentBaseTransitionV1 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition :: V1 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod document_create_transition { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`DocumentCreateTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0 { pub base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition , pub entropy : * mut crate :: fermented :: generics :: Arr_u8_32 , pub data : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value , pub prefunded_voting_balance : * mut crate :: fermented :: generics :: Tuple_String_dpp_balances_credits_Credits } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: v0 :: DocumentCreateTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: v0 :: DocumentCreateTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: v0 :: DocumentCreateTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition >> :: ffi_from (ffi_ref . base) , entropy : < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (ffi_ref . entropy) , data : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , platform_value :: Value > >> :: ffi_from (ffi_ref . data) , prefunded_voting_balance : < crate :: fermented :: generics :: Tuple_String_dpp_balances_credits_Credits as ferment :: FFIConversionFrom < (String , dpp :: balances :: credits :: Credits) >> :: ffi_from_opt (ffi_ref . prefunded_voting_balance) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: v0 :: DocumentCreateTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: v0 :: DocumentCreateTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition >> :: ffi_to (obj . base) , entropy : < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (obj . entropy) , data : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value as ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , platform_value :: Value > >> :: ffi_to (obj . data) , prefunded_voting_balance : < crate :: fermented :: generics :: Tuple_String_dpp_balances_credits_Credits as ferment :: FFIConversionTo < (String , dpp :: balances :: credits :: Credits) >> :: ffi_to_opt (obj . prefunded_voting_balance) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . entropy) ; ferment :: unbox_any (ffi_ref . data) ; ferment :: unbox_any_opt (ffi_ref . prefunded_voting_balance) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentCreateTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: DocumentCreateTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: DocumentCreateTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: DocumentCreateTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: v0 :: DocumentCreateTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: DocumentCreateTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: DocumentCreateTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: DocumentCreateTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: v0 :: DocumentCreateTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod document_delete_transition { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`DocumentDeleteTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0 { pub base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: v0 :: DocumentDeleteTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: v0 :: DocumentDeleteTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: v0 :: DocumentDeleteTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition >> :: ffi_from (ffi_ref . base) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: v0 :: DocumentDeleteTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: v0 :: DocumentDeleteTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition >> :: ffi_to (obj . base) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentDeleteTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: DocumentDeleteTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: DocumentDeleteTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: DocumentDeleteTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: v0 :: DocumentDeleteTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: DocumentDeleteTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: DocumentDeleteTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: DocumentDeleteTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: v0 :: DocumentDeleteTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod document_purchase_transition { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`DocumentPurchaseTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0 { pub base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition , pub revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , pub price : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: v0 :: DocumentPurchaseTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: v0 :: DocumentPurchaseTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: v0 :: DocumentPurchaseTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition >> :: ffi_from (ffi_ref . base) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from (ffi_ref . revision) , price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . price) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: v0 :: DocumentPurchaseTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: v0 :: DocumentPurchaseTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition >> :: ffi_to (obj . base) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to (obj . revision) , price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . price) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . revision) ; ferment :: unbox_any (ffi_ref . price) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentPurchaseTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: DocumentPurchaseTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: DocumentPurchaseTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: DocumentPurchaseTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: v0 :: DocumentPurchaseTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: DocumentPurchaseTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: DocumentPurchaseTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: DocumentPurchaseTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: v0 :: DocumentPurchaseTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod document_replace_transition { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`DocumentReplaceTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0 { pub base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition , pub revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , pub data : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: v0 :: DocumentReplaceTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: v0 :: DocumentReplaceTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: v0 :: DocumentReplaceTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition >> :: ffi_from (ffi_ref . base) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from (ffi_ref . revision) , data : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , platform_value :: Value > >> :: ffi_from (ffi_ref . data) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: v0 :: DocumentReplaceTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: v0 :: DocumentReplaceTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition >> :: ffi_to (obj . base) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to (obj . revision) , data : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value as ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , platform_value :: Value > >> :: ffi_to (obj . data) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . revision) ; ferment :: unbox_any (ffi_ref . data) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentReplaceTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: DocumentReplaceTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: DocumentReplaceTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: DocumentReplaceTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: v0 :: DocumentReplaceTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: DocumentReplaceTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: DocumentReplaceTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: DocumentReplaceTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: v0 :: DocumentReplaceTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod document_transfer_transition { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`DocumentTransferTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0 { pub base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition , pub revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , pub recipient_owner_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: v0 :: DocumentTransferTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: v0 :: DocumentTransferTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: v0 :: DocumentTransferTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition >> :: ffi_from (ffi_ref . base) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from (ffi_ref . revision) , recipient_owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . recipient_owner_id) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: v0 :: DocumentTransferTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: v0 :: DocumentTransferTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition >> :: ffi_to (obj . base) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to (obj . revision) , recipient_owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . recipient_owner_id) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . revision) ; ferment :: unbox_any (ffi_ref . recipient_owner_id) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentTransferTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: DocumentTransferTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: DocumentTransferTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: DocumentTransferTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: v0 :: DocumentTransferTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: DocumentTransferTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: DocumentTransferTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: DocumentTransferTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: v0 :: DocumentTransferTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod document_transition { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { Create (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition) , Replace (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition) , Delete (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition) , Transfer (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition) , UpdatePrice (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition) , Purchase (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Create (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: Create (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: DocumentCreateTransition >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Replace (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: Replace (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: DocumentReplaceTransition >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Delete (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: Delete (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: DocumentDeleteTransition >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Transfer (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: Transfer (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: DocumentTransferTransition >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: UpdatePrice (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: UpdatePrice (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: DocumentUpdatePriceTransition >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Purchase (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: Purchase (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: DocumentPurchaseTransition >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: Create (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Create (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: DocumentCreateTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: Replace (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Replace (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: DocumentReplaceTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: Delete (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Delete (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: DocumentDeleteTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: Transfer (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Transfer (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: DocumentTransferTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: UpdatePrice (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: UpdatePrice (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: DocumentUpdatePriceTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: Purchase (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Purchase (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: DocumentPurchaseTransition >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Create (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Replace (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Delete (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Transfer (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: UpdatePrice (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Purchase (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod document_transition_action_type { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentTransitionActionType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType { Create , Replace , Delete , Transfer , Purchase , UpdatePrice , IgnoreWhileBumpingRevision } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Create => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: Create , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Replace => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: Replace , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Delete => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: Delete , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Transfer => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: Transfer , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Purchase => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: Purchase , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: UpdatePrice => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: UpdatePrice , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: IgnoreWhileBumpingRevision => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: IgnoreWhileBumpingRevision } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: Create => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Create , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: Replace => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Replace , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: Delete => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Delete , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: Transfer => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Transfer , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: Purchase => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Purchase , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: UpdatePrice => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: UpdatePrice , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: IgnoreWhileBumpingRevision => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: IgnoreWhileBumpingRevision , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Create => { } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Replace => { } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Delete => { } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Transfer => { } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Purchase => { } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: UpdatePrice => { } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: IgnoreWhileBumpingRevision => { } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod document_update_price_transition { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`DocumentUpdatePriceTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0 { pub base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition , pub revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , pub price : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: v0 :: DocumentUpdatePriceTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: v0 :: DocumentUpdatePriceTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: v0 :: DocumentUpdatePriceTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition >> :: ffi_from (ffi_ref . base) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from (ffi_ref . revision) , price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . price) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: v0 :: DocumentUpdatePriceTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: v0 :: DocumentUpdatePriceTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition >> :: ffi_to (obj . base) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to (obj . revision) , price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . price) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . revision) ; ferment :: unbox_any (ffi_ref . price) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentUpdatePriceTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: DocumentUpdatePriceTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: DocumentUpdatePriceTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: DocumentUpdatePriceTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: v0 :: DocumentUpdatePriceTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: DocumentUpdatePriceTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: DocumentUpdatePriceTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: DocumentUpdatePriceTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: v0 :: DocumentUpdatePriceTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod token_base_transition { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`TokenBaseTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0 { pub identity_contract_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub token_contract_position : u16 , pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub using_group_info : * mut crate :: fermented :: types :: dpp :: group :: dpp_group_GroupStateTransitionInfo } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: v0 :: TokenBaseTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: v0 :: TokenBaseTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: v0 :: TokenBaseTransitionV0 { identity_contract_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . identity_contract_nonce) , token_contract_position : ffi_ref . token_contract_position , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , using_group_info : < crate :: fermented :: types :: dpp :: group :: dpp_group_GroupStateTransitionInfo as ferment :: FFIConversionFrom < dpp :: group :: GroupStateTransitionInfo >> :: ffi_from_opt (ffi_ref . using_group_info) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: v0 :: TokenBaseTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: v0 :: TokenBaseTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0 { identity_contract_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . identity_contract_nonce) , token_contract_position : obj . token_contract_position , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , using_group_info : < crate :: fermented :: types :: dpp :: group :: dpp_group_GroupStateTransitionInfo as ferment :: FFIConversionTo < dpp :: group :: GroupStateTransitionInfo >> :: ffi_to_opt (obj . using_group_info) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_contract_nonce) ; ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_any_opt (ffi_ref . using_group_info) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenBaseTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: v0 :: TokenBaseTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: v0 :: TokenBaseTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod token_burn_transition { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`TokenBurnTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0 { pub base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition , pub burn_amount : u64 , pub public_note : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: v0 :: TokenBurnTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: v0 :: TokenBurnTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: v0 :: TokenBurnTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_from (ffi_ref . base) , burn_amount : ffi_ref . burn_amount , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . public_note) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: v0 :: TokenBurnTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: v0 :: TokenBurnTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_to (obj . base) , burn_amount : obj . burn_amount , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . public_note) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ; ferment :: unbox_any_opt (ffi_ref . public_note) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenBurnTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: TokenBurnTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: TokenBurnTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: TokenBurnTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: v0 :: TokenBurnTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: TokenBurnTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: TokenBurnTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: TokenBurnTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: v0 :: TokenBurnTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod token_claim_transition { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`TokenClaimTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0 { pub base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition , pub distribution_type : * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_distribution_key :: dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType , pub public_note : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: v0 :: TokenClaimTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: v0 :: TokenClaimTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: v0 :: TokenClaimTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_from (ffi_ref . base) , distribution_type : < crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_distribution_key :: dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType as ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_distribution_key :: TokenDistributionType >> :: ffi_from (ffi_ref . distribution_type) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . public_note) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: v0 :: TokenClaimTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: v0 :: TokenClaimTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_to (obj . base) , distribution_type : < crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_distribution_key :: dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType as ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_distribution_key :: TokenDistributionType >> :: ffi_to (obj . distribution_type) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . public_note) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . distribution_type) ; ferment :: unbox_any_opt (ffi_ref . public_note) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenClaimTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: TokenClaimTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: TokenClaimTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: TokenClaimTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: v0 :: TokenClaimTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: TokenClaimTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: TokenClaimTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: TokenClaimTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: v0 :: TokenClaimTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod token_config_update_transition { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`TokenConfigUpdateTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0 { pub base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition , pub update_token_configuration_item : * mut dpp :: data_contract :: associated_token :: token_configuration_item :: TokenConfigurationChangeItem , pub public_note : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: v0 :: TokenConfigUpdateTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: v0 :: TokenConfigUpdateTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: v0 :: TokenConfigUpdateTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_from (ffi_ref . base) , update_token_configuration_item : std :: ptr :: read (ffi_ref . update_token_configuration_item) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . public_note) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: v0 :: TokenConfigUpdateTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: v0 :: TokenConfigUpdateTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_to (obj . base) , update_token_configuration_item : ferment :: boxed (obj . update_token_configuration_item) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . public_note) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . update_token_configuration_item) ; ferment :: unbox_any_opt (ffi_ref . public_note) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenConfigUpdateTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: TokenConfigUpdateTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: TokenConfigUpdateTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: TokenConfigUpdateTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: v0 :: TokenConfigUpdateTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: TokenConfigUpdateTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: TokenConfigUpdateTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: TokenConfigUpdateTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: v0 :: TokenConfigUpdateTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod token_destroy_frozen_funds_transition { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`TokenDestroyFrozenFundsTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0 { pub base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition , pub frozen_identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub public_note : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: v0 :: TokenDestroyFrozenFundsTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: v0 :: TokenDestroyFrozenFundsTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: v0 :: TokenDestroyFrozenFundsTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_from (ffi_ref . base) , frozen_identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . frozen_identity_id) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . public_note) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: v0 :: TokenDestroyFrozenFundsTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: v0 :: TokenDestroyFrozenFundsTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_to (obj . base) , frozen_identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . frozen_identity_id) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . public_note) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . frozen_identity_id) ; ferment :: unbox_any_opt (ffi_ref . public_note) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenDestroyFrozenFundsTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: TokenDestroyFrozenFundsTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: TokenDestroyFrozenFundsTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: TokenDestroyFrozenFundsTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: v0 :: TokenDestroyFrozenFundsTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: TokenDestroyFrozenFundsTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: TokenDestroyFrozenFundsTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: TokenDestroyFrozenFundsTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: v0 :: TokenDestroyFrozenFundsTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod token_direct_purchase_transition { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`TokenDirectPurchaseTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0 { pub base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition , pub token_count : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , pub total_agreed_price : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: v0 :: TokenDirectPurchaseTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: v0 :: TokenDirectPurchaseTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: v0 :: TokenDirectPurchaseTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_from (ffi_ref . base) , token_count : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (ffi_ref . token_count) , total_agreed_price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . total_agreed_price) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: v0 :: TokenDirectPurchaseTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: v0 :: TokenDirectPurchaseTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_to (obj . base) , token_count : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (obj . token_count) , total_agreed_price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . total_agreed_price) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . token_count) ; ferment :: unbox_any (ffi_ref . total_agreed_price) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenDirectPurchaseTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_TokenDirectPurchaseTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: TokenDirectPurchaseTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_TokenDirectPurchaseTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_TokenDirectPurchaseTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: TokenDirectPurchaseTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_TokenDirectPurchaseTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: TokenDirectPurchaseTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: v0 :: TokenDirectPurchaseTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: TokenDirectPurchaseTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_TokenDirectPurchaseTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: TokenDirectPurchaseTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_TokenDirectPurchaseTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: TokenDirectPurchaseTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_TokenDirectPurchaseTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: v0 :: TokenDirectPurchaseTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_TokenDirectPurchaseTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_TokenDirectPurchaseTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod token_emergency_action_transition { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`TokenEmergencyActionTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0 { pub base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition , pub emergency_action : * mut crate :: fermented :: types :: dpp :: tokens :: emergency_action :: dpp_tokens_emergency_action_TokenEmergencyAction , pub public_note : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: v0 :: TokenEmergencyActionTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: v0 :: TokenEmergencyActionTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: v0 :: TokenEmergencyActionTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_from (ffi_ref . base) , emergency_action : < crate :: fermented :: types :: dpp :: tokens :: emergency_action :: dpp_tokens_emergency_action_TokenEmergencyAction as ferment :: FFIConversionFrom < dpp :: tokens :: emergency_action :: TokenEmergencyAction >> :: ffi_from (ffi_ref . emergency_action) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . public_note) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: v0 :: TokenEmergencyActionTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: v0 :: TokenEmergencyActionTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_to (obj . base) , emergency_action : < crate :: fermented :: types :: dpp :: tokens :: emergency_action :: dpp_tokens_emergency_action_TokenEmergencyAction as ferment :: FFIConversionTo < dpp :: tokens :: emergency_action :: TokenEmergencyAction >> :: ffi_to (obj . emergency_action) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . public_note) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . emergency_action) ; ferment :: unbox_any_opt (ffi_ref . public_note) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenEmergencyActionTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: TokenEmergencyActionTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: TokenEmergencyActionTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: TokenEmergencyActionTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: v0 :: TokenEmergencyActionTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: TokenEmergencyActionTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: TokenEmergencyActionTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: TokenEmergencyActionTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: v0 :: TokenEmergencyActionTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod token_freeze_transition { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`TokenFreezeTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0 { pub base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition , pub identity_to_freeze_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub public_note : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: v0 :: TokenFreezeTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: v0 :: TokenFreezeTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: v0 :: TokenFreezeTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_from (ffi_ref . base) , identity_to_freeze_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_to_freeze_id) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . public_note) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: v0 :: TokenFreezeTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: v0 :: TokenFreezeTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_to (obj . base) , identity_to_freeze_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_to_freeze_id) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . public_note) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . identity_to_freeze_id) ; ferment :: unbox_any_opt (ffi_ref . public_note) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenFreezeTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: TokenFreezeTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: TokenFreezeTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: TokenFreezeTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: v0 :: TokenFreezeTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: TokenFreezeTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: TokenFreezeTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: TokenFreezeTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: v0 :: TokenFreezeTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod token_mint_transition { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`TokenMintTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0 { pub base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition , pub issued_to_identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub amount : u64 , pub public_note : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: v0 :: TokenMintTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: v0 :: TokenMintTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: v0 :: TokenMintTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_from (ffi_ref . base) , issued_to_identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from_opt (ffi_ref . issued_to_identity_id) , amount : ffi_ref . amount , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . public_note) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: v0 :: TokenMintTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: v0 :: TokenMintTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_to (obj . base) , issued_to_identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to_opt (obj . issued_to_identity_id) , amount : obj . amount , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . public_note) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any_opt (ffi_ref . issued_to_identity_id) ; ; ferment :: unbox_any_opt (ffi_ref . public_note) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenMintTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: TokenMintTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: TokenMintTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: TokenMintTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: v0 :: TokenMintTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: TokenMintTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: TokenMintTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: TokenMintTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: v0 :: TokenMintTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod token_set_price_for_direct_purchase_transition { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`TokenSetPriceForDirectPurchaseTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0 { pub base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition , pub price : * mut crate :: fermented :: types :: dpp :: tokens :: token_pricing_schedule :: dpp_tokens_token_pricing_schedule_TokenPricingSchedule , pub public_note : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: v0 :: TokenSetPriceForDirectPurchaseTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: v0 :: TokenSetPriceForDirectPurchaseTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: v0 :: TokenSetPriceForDirectPurchaseTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_from (ffi_ref . base) , price : < crate :: fermented :: types :: dpp :: tokens :: token_pricing_schedule :: dpp_tokens_token_pricing_schedule_TokenPricingSchedule as ferment :: FFIConversionFrom < dpp :: tokens :: token_pricing_schedule :: TokenPricingSchedule >> :: ffi_from_opt (ffi_ref . price) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . public_note) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: v0 :: TokenSetPriceForDirectPurchaseTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: v0 :: TokenSetPriceForDirectPurchaseTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_to (obj . base) , price : < crate :: fermented :: types :: dpp :: tokens :: token_pricing_schedule :: dpp_tokens_token_pricing_schedule_TokenPricingSchedule as ferment :: FFIConversionTo < dpp :: tokens :: token_pricing_schedule :: TokenPricingSchedule >> :: ffi_to_opt (obj . price) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . public_note) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any_opt (ffi_ref . price) ; ferment :: unbox_any_opt (ffi_ref . public_note) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenSetPriceForDirectPurchaseTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_TokenSetPriceForDirectPurchaseTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: TokenSetPriceForDirectPurchaseTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_TokenSetPriceForDirectPurchaseTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_TokenSetPriceForDirectPurchaseTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: TokenSetPriceForDirectPurchaseTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_TokenSetPriceForDirectPurchaseTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: TokenSetPriceForDirectPurchaseTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: v0 :: TokenSetPriceForDirectPurchaseTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: TokenSetPriceForDirectPurchaseTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_TokenSetPriceForDirectPurchaseTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: TokenSetPriceForDirectPurchaseTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_TokenSetPriceForDirectPurchaseTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: TokenSetPriceForDirectPurchaseTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_TokenSetPriceForDirectPurchaseTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: v0 :: TokenSetPriceForDirectPurchaseTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_TokenSetPriceForDirectPurchaseTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_TokenSetPriceForDirectPurchaseTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod token_transfer_transition { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`TokenTransferTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0 { pub base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition , pub amount : u64 , pub recipient_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub public_note : * mut std :: os :: raw :: c_char , pub shared_encrypted_note : * mut crate :: fermented :: types :: dpp :: tokens :: dpp_tokens_SharedEncryptedNote , pub private_encrypted_note : * mut crate :: fermented :: types :: dpp :: tokens :: dpp_tokens_PrivateEncryptedNote } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: v0 :: TokenTransferTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: v0 :: TokenTransferTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: v0 :: TokenTransferTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_from (ffi_ref . base) , amount : ffi_ref . amount , recipient_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . recipient_id) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . public_note) , shared_encrypted_note : < crate :: fermented :: types :: dpp :: tokens :: dpp_tokens_SharedEncryptedNote as ferment :: FFIConversionFrom < dpp :: tokens :: SharedEncryptedNote >> :: ffi_from_opt (ffi_ref . shared_encrypted_note) , private_encrypted_note : < crate :: fermented :: types :: dpp :: tokens :: dpp_tokens_PrivateEncryptedNote as ferment :: FFIConversionFrom < dpp :: tokens :: PrivateEncryptedNote >> :: ffi_from_opt (ffi_ref . private_encrypted_note) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: v0 :: TokenTransferTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: v0 :: TokenTransferTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_to (obj . base) , amount : obj . amount , recipient_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . recipient_id) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . public_note) , shared_encrypted_note : < crate :: fermented :: types :: dpp :: tokens :: dpp_tokens_SharedEncryptedNote as ferment :: FFIConversionTo < dpp :: tokens :: SharedEncryptedNote >> :: ffi_to_opt (obj . shared_encrypted_note) , private_encrypted_note : < crate :: fermented :: types :: dpp :: tokens :: dpp_tokens_PrivateEncryptedNote as ferment :: FFIConversionTo < dpp :: tokens :: PrivateEncryptedNote >> :: ffi_to_opt (obj . private_encrypted_note) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ; ferment :: unbox_any (ffi_ref . recipient_id) ; ferment :: unbox_any_opt (ffi_ref . public_note) ; ferment :: unbox_any_opt (ffi_ref . shared_encrypted_note) ; ferment :: unbox_any_opt (ffi_ref . private_encrypted_note) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenTransferTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: TokenTransferTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: TokenTransferTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: TokenTransferTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: v0 :: TokenTransferTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: TokenTransferTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: TokenTransferTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: TokenTransferTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: v0 :: TokenTransferTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod token_transition { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { Burn (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition) , Mint (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition) , Transfer (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition) , Freeze (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition) , Unfreeze (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition) , DestroyFrozenFunds (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition) , Claim (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition) , EmergencyAction (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition) , ConfigUpdate (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition) , DirectPurchase (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_TokenDirectPurchaseTransition) , SetPriceForDirectPurchase (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_TokenSetPriceForDirectPurchaseTransition) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Burn (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Burn (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: TokenBurnTransition >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Mint (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Mint (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: TokenMintTransition >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Transfer (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Transfer (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: TokenTransferTransition >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Freeze (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Freeze (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: TokenFreezeTransition >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Unfreeze (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Unfreeze (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: TokenUnfreezeTransition >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: DestroyFrozenFunds (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: DestroyFrozenFunds (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: TokenDestroyFrozenFundsTransition >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Claim (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Claim (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: TokenClaimTransition >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: EmergencyAction (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: EmergencyAction (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: TokenEmergencyActionTransition >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: ConfigUpdate (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: ConfigUpdate (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: TokenConfigUpdateTransition >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: DirectPurchase (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: DirectPurchase (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_TokenDirectPurchaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: TokenDirectPurchaseTransition >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: SetPriceForDirectPurchase (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: SetPriceForDirectPurchase (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_TokenSetPriceForDirectPurchaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: TokenSetPriceForDirectPurchaseTransition >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Burn (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Burn (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: TokenBurnTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Mint (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Mint (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: TokenMintTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Transfer (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Transfer (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: TokenTransferTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Freeze (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Freeze (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: TokenFreezeTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Unfreeze (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Unfreeze (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: TokenUnfreezeTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: DestroyFrozenFunds (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: DestroyFrozenFunds (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: TokenDestroyFrozenFundsTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Claim (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Claim (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: TokenClaimTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: EmergencyAction (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: EmergencyAction (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: TokenEmergencyActionTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: ConfigUpdate (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: ConfigUpdate (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: TokenConfigUpdateTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: DirectPurchase (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: DirectPurchase (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_TokenDirectPurchaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: TokenDirectPurchaseTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: SetPriceForDirectPurchase (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: SetPriceForDirectPurchase (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_TokenSetPriceForDirectPurchaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: TokenSetPriceForDirectPurchaseTransition >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Burn (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Mint (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Transfer (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Freeze (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Unfreeze (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: DestroyFrozenFunds (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Claim (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: EmergencyAction (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: ConfigUpdate (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: DirectPurchase (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: SetPriceForDirectPurchase (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod token_unfreeze_transition { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`TokenUnfreezeTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0 { pub base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition , pub frozen_identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub public_note : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: v0 :: TokenUnfreezeTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: v0 :: TokenUnfreezeTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: v0 :: TokenUnfreezeTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_from (ffi_ref . base) , frozen_identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . frozen_identity_id) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . public_note) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: v0 :: TokenUnfreezeTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: v0 :: TokenUnfreezeTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_to (obj . base) , frozen_identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . frozen_identity_id) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . public_note) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . frozen_identity_id) ; ferment :: unbox_any_opt (ffi_ref . public_note) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenUnfreezeTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: TokenUnfreezeTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: TokenUnfreezeTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: TokenUnfreezeTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: v0 :: TokenUnfreezeTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: TokenUnfreezeTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: TokenUnfreezeTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: TokenUnfreezeTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: v0 :: TokenUnfreezeTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`BatchedTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { Document (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition) , Token (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition :: Document (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition :: Document (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition :: Token (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition :: Token (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition :: Document (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition :: Document (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition :: Token (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition :: Token (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition :: Document (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition :: Token (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`BatchTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0 { pub owner_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub transitions : * mut crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition , pub user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , pub signature_public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , pub signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: v0 :: BatchTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: v0 :: BatchTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: v0 :: BatchTransitionV0 { owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . owner_id) , transitions : < crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionFrom < Vec < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition > >> :: ffi_from (ffi_ref . transitions) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease >> :: ffi_from (ffi_ref . user_fee_increase) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionFrom < platform_value :: types :: binary_data :: BinaryData >> :: ffi_from (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: v0 :: BatchTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: v0 :: BatchTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0 { owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . owner_id) , transitions : < crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionTo < Vec < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition > >> :: ffi_to (obj . transitions) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease >> :: ffi_to (obj . user_fee_increase) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionTo < platform_value :: types :: binary_data :: BinaryData >> :: ffi_to (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . owner_id) ; ferment :: unbox_any (ffi_ref . transitions) ; ferment :: unbox_any (ffi_ref . user_fee_increase) ; ferment :: unbox_any (ffi_ref . signature_public_key_id) ; ferment :: unbox_any (ffi_ref . signature) ; } } } } pub mod v1 { use crate as example_platform ; # [doc = "FFI-representation of the [`BatchTransitionV1`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1 { pub owner_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub transitions : * mut crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition , pub user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , pub signature_public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , pub signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: v1 :: BatchTransitionV1 > for dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: v1 :: BatchTransitionV1 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: v1 :: BatchTransitionV1 { owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . owner_id) , transitions : < crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition as ferment :: FFIConversionFrom < Vec < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition > >> :: ffi_from (ffi_ref . transitions) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease >> :: ffi_from (ffi_ref . user_fee_increase) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionFrom < platform_value :: types :: binary_data :: BinaryData >> :: ffi_from (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: v1 :: BatchTransitionV1 > for dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: v1 :: BatchTransitionV1) -> * const dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1 { owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . owner_id) , transitions : < crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition as ferment :: FFIConversionTo < Vec < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition > >> :: ffi_to (obj . transitions) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease >> :: ffi_to (obj . user_fee_increase) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionTo < platform_value :: types :: binary_data :: BinaryData >> :: ffi_to (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . owner_id) ; ferment :: unbox_any (ffi_ref . transitions) ; ferment :: unbox_any (ffi_ref . user_fee_increase) ; ferment :: unbox_any (ffi_ref . signature_public_key_id) ; ferment :: unbox_any (ffi_ref . signature) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`BatchTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_BatchTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0) , V1 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: v1 :: dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: BatchTransition > for dpp_state_transition_state_transitions_document_batch_transition_BatchTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_BatchTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: BatchTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_BatchTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: BatchTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: v0 :: BatchTransitionV0 >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_BatchTransition :: V1 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: BatchTransition :: V1 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: v1 :: dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: v1 :: BatchTransitionV1 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: BatchTransition > for dpp_state_transition_state_transitions_document_batch_transition_BatchTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: BatchTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_BatchTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: BatchTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_BatchTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: v0 :: BatchTransitionV0 >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: BatchTransition :: V1 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_BatchTransition :: V1 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: v1 :: dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: v1 :: BatchTransitionV1 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_BatchTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_BatchTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_BatchTransition :: V1 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } } pub mod identity { pub mod identity_create_transition { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityCreateTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0 { pub public_keys : * mut crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation , pub asset_lock_proof : * mut crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_AssetLockProof , pub user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , pub signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData , pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: v0 :: IdentityCreateTransitionV0 > for dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0) -> dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: v0 :: IdentityCreateTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: v0 :: IdentityCreateTransitionV0 { public_keys : < crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation as ferment :: FFIConversionFrom < Vec < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation > >> :: ffi_from (ffi_ref . public_keys) , asset_lock_proof : < crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_AssetLockProof as ferment :: FFIConversionFrom < dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof >> :: ffi_from (ffi_ref . asset_lock_proof) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease >> :: ffi_from (ffi_ref . user_fee_increase) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionFrom < platform_value :: types :: binary_data :: BinaryData >> :: ffi_from (ffi_ref . signature) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: v0 :: IdentityCreateTransitionV0 > for dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: v0 :: IdentityCreateTransitionV0) -> * const dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0 { public_keys : < crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation as ferment :: FFIConversionTo < Vec < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation > >> :: ffi_to (obj . public_keys) , asset_lock_proof : < crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_AssetLockProof as ferment :: FFIConversionTo < dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof >> :: ffi_to (obj . asset_lock_proof) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease >> :: ffi_to (obj . user_fee_increase) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionTo < platform_value :: types :: binary_data :: BinaryData >> :: ffi_to (obj . signature) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_keys) ; ferment :: unbox_any (ffi_ref . asset_lock_proof) ; ferment :: unbox_any (ffi_ref . user_fee_increase) ; ferment :: unbox_any (ffi_ref . signature) ; ferment :: unbox_any (ffi_ref . identity_id) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`IdentityCreateTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: IdentityCreateTransition > for dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition) -> dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: IdentityCreateTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: IdentityCreateTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: v0 :: IdentityCreateTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: IdentityCreateTransition > for dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: IdentityCreateTransition) -> * const dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: IdentityCreateTransition :: V0 (o_0) => dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: v0 :: IdentityCreateTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod identity_credit_transfer_transition { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityCreditTransferTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub recipient_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub amount : u64 , pub nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , pub signature_public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , pub signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: v0 :: IdentityCreditTransferTransitionV0 > for dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0) -> dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: v0 :: IdentityCreditTransferTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: v0 :: IdentityCreditTransferTransitionV0 { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , recipient_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . recipient_id) , amount : ffi_ref . amount , nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . nonce) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease >> :: ffi_from (ffi_ref . user_fee_increase) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionFrom < platform_value :: types :: binary_data :: BinaryData >> :: ffi_from (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: v0 :: IdentityCreditTransferTransitionV0 > for dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: v0 :: IdentityCreditTransferTransitionV0) -> * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , recipient_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . recipient_id) , amount : obj . amount , nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . nonce) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease >> :: ffi_to (obj . user_fee_increase) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionTo < platform_value :: types :: binary_data :: BinaryData >> :: ffi_to (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_any (ffi_ref . recipient_id) ; ; ferment :: unbox_any (ffi_ref . nonce) ; ferment :: unbox_any (ffi_ref . user_fee_increase) ; ferment :: unbox_any (ffi_ref . signature_public_key_id) ; ferment :: unbox_any (ffi_ref . signature) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`IdentityCreditTransferTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: IdentityCreditTransferTransition > for dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition) -> dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: IdentityCreditTransferTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: IdentityCreditTransferTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: v0 :: IdentityCreditTransferTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: IdentityCreditTransferTransition > for dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: IdentityCreditTransferTransition) -> * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: IdentityCreditTransferTransition :: V0 (o_0) => dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: v0 :: IdentityCreditTransferTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod identity_credit_withdrawal_transition { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityCreditWithdrawalTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub amount : u64 , pub core_fee_per_byte : u32 , pub pooling : * mut crate :: fermented :: types :: dpp :: withdrawal :: dpp_withdrawal_Pooling , pub output_script : * mut example_platform :: custom :: dpp :: CoreScriptFFI , pub nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , pub signature_public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , pub signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v0 :: IdentityCreditWithdrawalTransitionV0 > for dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) -> dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v0 :: IdentityCreditWithdrawalTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v0 :: IdentityCreditWithdrawalTransitionV0 { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , amount : ffi_ref . amount , core_fee_per_byte : ffi_ref . core_fee_per_byte , pooling : < crate :: fermented :: types :: dpp :: withdrawal :: dpp_withdrawal_Pooling as ferment :: FFIConversionFrom < dpp :: withdrawal :: Pooling >> :: ffi_from (ffi_ref . pooling) , output_script : < example_platform :: custom :: dpp :: CoreScriptFFI as ferment :: FFIConversionFrom < dpp :: identity :: core_script :: CoreScript >> :: ffi_from (ffi_ref . output_script) , nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . nonce) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease >> :: ffi_from (ffi_ref . user_fee_increase) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionFrom < platform_value :: types :: binary_data :: BinaryData >> :: ffi_from (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v0 :: IdentityCreditWithdrawalTransitionV0 > for dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v0 :: IdentityCreditWithdrawalTransitionV0) -> * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , amount : obj . amount , core_fee_per_byte : obj . core_fee_per_byte , pooling : < crate :: fermented :: types :: dpp :: withdrawal :: dpp_withdrawal_Pooling as ferment :: FFIConversionTo < dpp :: withdrawal :: Pooling >> :: ffi_to (obj . pooling) , output_script : < example_platform :: custom :: dpp :: CoreScriptFFI as ferment :: FFIConversionTo < dpp :: identity :: core_script :: CoreScript >> :: ffi_to (obj . output_script) , nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . nonce) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease >> :: ffi_to (obj . user_fee_increase) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionTo < platform_value :: types :: binary_data :: BinaryData >> :: ffi_to (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; ; ; ferment :: unbox_any (ffi_ref . pooling) ; ferment :: unbox_any (ffi_ref . output_script) ; ferment :: unbox_any (ffi_ref . nonce) ; ferment :: unbox_any (ffi_ref . user_fee_increase) ; ferment :: unbox_any (ffi_ref . signature_public_key_id) ; ferment :: unbox_any (ffi_ref . signature) ; } } } } pub mod v1 { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityCreditWithdrawalTransitionV1`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub amount : u64 , pub core_fee_per_byte : u32 , pub pooling : * mut crate :: fermented :: types :: dpp :: withdrawal :: dpp_withdrawal_Pooling , pub output_script : * mut example_platform :: custom :: dpp :: CoreScriptFFI , pub nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , pub signature_public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , pub signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v1 :: IdentityCreditWithdrawalTransitionV1 > for dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) -> dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v1 :: IdentityCreditWithdrawalTransitionV1 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v1 :: IdentityCreditWithdrawalTransitionV1 { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , amount : ffi_ref . amount , core_fee_per_byte : ffi_ref . core_fee_per_byte , pooling : < crate :: fermented :: types :: dpp :: withdrawal :: dpp_withdrawal_Pooling as ferment :: FFIConversionFrom < dpp :: withdrawal :: Pooling >> :: ffi_from (ffi_ref . pooling) , output_script : < example_platform :: custom :: dpp :: CoreScriptFFI as ferment :: FFIConversionFrom < dpp :: identity :: core_script :: CoreScript >> :: ffi_from_opt (ffi_ref . output_script) , nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . nonce) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease >> :: ffi_from (ffi_ref . user_fee_increase) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionFrom < platform_value :: types :: binary_data :: BinaryData >> :: ffi_from (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v1 :: IdentityCreditWithdrawalTransitionV1 > for dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v1 :: IdentityCreditWithdrawalTransitionV1) -> * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , amount : obj . amount , core_fee_per_byte : obj . core_fee_per_byte , pooling : < crate :: fermented :: types :: dpp :: withdrawal :: dpp_withdrawal_Pooling as ferment :: FFIConversionTo < dpp :: withdrawal :: Pooling >> :: ffi_to (obj . pooling) , output_script : < example_platform :: custom :: dpp :: CoreScriptFFI as ferment :: FFIConversionTo < dpp :: identity :: core_script :: CoreScript >> :: ffi_to_opt (obj . output_script) , nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . nonce) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease >> :: ffi_to (obj . user_fee_increase) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionTo < platform_value :: types :: binary_data :: BinaryData >> :: ffi_to (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; ; ; ferment :: unbox_any (ffi_ref . pooling) ; ferment :: unbox_any_opt (ffi_ref . output_script) ; ferment :: unbox_any (ffi_ref . nonce) ; ferment :: unbox_any (ffi_ref . user_fee_increase) ; ferment :: unbox_any (ffi_ref . signature_public_key_id) ; ferment :: unbox_any (ffi_ref . signature) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`IdentityCreditWithdrawalTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) , V1 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v1 :: dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: IdentityCreditWithdrawalTransition > for dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition) -> dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: IdentityCreditWithdrawalTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: IdentityCreditWithdrawalTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v0 :: IdentityCreditWithdrawalTransitionV0 >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition :: V1 (o_0) => dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: IdentityCreditWithdrawalTransition :: V1 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v1 :: dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v1 :: IdentityCreditWithdrawalTransitionV1 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: IdentityCreditWithdrawalTransition > for dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: IdentityCreditWithdrawalTransition) -> * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: IdentityCreditWithdrawalTransition :: V0 (o_0) => dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v0 :: IdentityCreditWithdrawalTransitionV0 >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: IdentityCreditWithdrawalTransition :: V1 (o_0) => dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition :: V1 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v1 :: dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v1 :: IdentityCreditWithdrawalTransitionV1 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition :: V1 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod identity_topup_transition { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityTopUpTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0 { pub asset_lock_proof : * mut crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_AssetLockProof , pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , pub signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: v0 :: IdentityTopUpTransitionV0 > for dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0) -> dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: v0 :: IdentityTopUpTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: v0 :: IdentityTopUpTransitionV0 { asset_lock_proof : < crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_AssetLockProof as ferment :: FFIConversionFrom < dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof >> :: ffi_from (ffi_ref . asset_lock_proof) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease >> :: ffi_from (ffi_ref . user_fee_increase) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionFrom < platform_value :: types :: binary_data :: BinaryData >> :: ffi_from (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: v0 :: IdentityTopUpTransitionV0 > for dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: v0 :: IdentityTopUpTransitionV0) -> * const dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0 { asset_lock_proof : < crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_AssetLockProof as ferment :: FFIConversionTo < dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof >> :: ffi_to (obj . asset_lock_proof) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease >> :: ffi_to (obj . user_fee_increase) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionTo < platform_value :: types :: binary_data :: BinaryData >> :: ffi_to (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . asset_lock_proof) ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_any (ffi_ref . user_fee_increase) ; ferment :: unbox_any (ffi_ref . signature) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`IdentityTopUpTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: IdentityTopUpTransition > for dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition) -> dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: IdentityTopUpTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: IdentityTopUpTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: v0 :: IdentityTopUpTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: IdentityTopUpTransition > for dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: IdentityTopUpTransition) -> * const dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: IdentityTopUpTransition :: V0 (o_0) => dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: v0 :: IdentityTopUpTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod identity_update_transition { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityUpdateTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , pub nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub add_public_keys : * mut crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation , pub disable_public_keys : * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID , pub user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , pub signature_public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , pub signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: v0 :: IdentityUpdateTransitionV0 > for dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0) -> dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: v0 :: IdentityUpdateTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: v0 :: IdentityUpdateTransitionV0 { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from (ffi_ref . revision) , nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . nonce) , add_public_keys : < crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation as ferment :: FFIConversionFrom < Vec < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation > >> :: ffi_from (ffi_ref . add_public_keys) , disable_public_keys : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < Vec < dpp :: identity :: identity_public_key :: KeyID > >> :: ffi_from (ffi_ref . disable_public_keys) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease >> :: ffi_from (ffi_ref . user_fee_increase) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionFrom < platform_value :: types :: binary_data :: BinaryData >> :: ffi_from (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: v0 :: IdentityUpdateTransitionV0 > for dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: v0 :: IdentityUpdateTransitionV0) -> * const dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to (obj . revision) , nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . nonce) , add_public_keys : < crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation as ferment :: FFIConversionTo < Vec < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation > >> :: ffi_to (obj . add_public_keys) , disable_public_keys : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < Vec < dpp :: identity :: identity_public_key :: KeyID > >> :: ffi_to (obj . disable_public_keys) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease >> :: ffi_to (obj . user_fee_increase) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionTo < platform_value :: types :: binary_data :: BinaryData >> :: ffi_to (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_any (ffi_ref . revision) ; ferment :: unbox_any (ffi_ref . nonce) ; ferment :: unbox_any (ffi_ref . add_public_keys) ; ferment :: unbox_any (ffi_ref . disable_public_keys) ; ferment :: unbox_any (ffi_ref . user_fee_increase) ; ferment :: unbox_any (ffi_ref . signature_public_key_id) ; ferment :: unbox_any (ffi_ref . signature) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`IdentityUpdateTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: IdentityUpdateTransition > for dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition) -> dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: IdentityUpdateTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: IdentityUpdateTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: v0 :: IdentityUpdateTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: IdentityUpdateTransition > for dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: IdentityUpdateTransition) -> * const dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: IdentityUpdateTransition :: V0 (o_0) => dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: v0 :: IdentityUpdateTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod masternode_vote_transition { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`MasternodeVoteTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0 { pub pro_tx_hash : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub voter_identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub vote : * mut crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote , pub nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub signature_public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , pub signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: v0 :: MasternodeVoteTransitionV0 > for dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0) -> dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: v0 :: MasternodeVoteTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: v0 :: MasternodeVoteTransitionV0 { pro_tx_hash : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . pro_tx_hash) , voter_identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . voter_identity_id) , vote : < crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote as ferment :: FFIConversionFrom < dpp :: voting :: votes :: Vote >> :: ffi_from (ffi_ref . vote) , nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . nonce) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionFrom < platform_value :: types :: binary_data :: BinaryData >> :: ffi_from (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: v0 :: MasternodeVoteTransitionV0 > for dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: v0 :: MasternodeVoteTransitionV0) -> * const dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0 { pro_tx_hash : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . pro_tx_hash) , voter_identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . voter_identity_id) , vote : < crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote as ferment :: FFIConversionTo < dpp :: voting :: votes :: Vote >> :: ffi_to (obj . vote) , nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . nonce) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionTo < platform_value :: types :: binary_data :: BinaryData >> :: ffi_to (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . pro_tx_hash) ; ferment :: unbox_any (ffi_ref . voter_identity_id) ; ferment :: unbox_any (ffi_ref . vote) ; ferment :: unbox_any (ffi_ref . nonce) ; ferment :: unbox_any (ffi_ref . signature_public_key_id) ; ferment :: unbox_any (ffi_ref . signature) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`MasternodeVoteTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: v0 :: dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: MasternodeVoteTransition > for dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition) -> dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: MasternodeVoteTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: MasternodeVoteTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: v0 :: dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: v0 :: MasternodeVoteTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: MasternodeVoteTransition > for dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: MasternodeVoteTransition) -> * const dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: MasternodeVoteTransition :: V0 (o_0) => dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: v0 :: dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: v0 :: MasternodeVoteTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod public_key_in_creation { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityPublicKeyInCreationV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 { pub id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , pub key_type : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType , pub purpose : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose , pub security_level : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel , pub contract_bounds : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: contract_bounds :: dpp_identity_identity_public_key_contract_bounds_ContractBounds , pub read_only : bool , pub data : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData , pub signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: v0 :: IdentityPublicKeyInCreationV0 > for dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0) -> dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: v0 :: IdentityPublicKeyInCreationV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: v0 :: IdentityPublicKeyInCreationV0 { id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . id) , key_type : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: key_type :: KeyType >> :: ffi_from (ffi_ref . key_type) , purpose : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: purpose :: Purpose >> :: ffi_from (ffi_ref . purpose) , security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_from (ffi_ref . security_level) , contract_bounds : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: contract_bounds :: dpp_identity_identity_public_key_contract_bounds_ContractBounds as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds >> :: ffi_from_opt (ffi_ref . contract_bounds) , read_only : ffi_ref . read_only , data : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionFrom < platform_value :: types :: binary_data :: BinaryData >> :: ffi_from (ffi_ref . data) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionFrom < platform_value :: types :: binary_data :: BinaryData >> :: ffi_from (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: v0 :: IdentityPublicKeyInCreationV0 > for dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: v0 :: IdentityPublicKeyInCreationV0) -> * const dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 { id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . id) , key_type : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: key_type :: KeyType >> :: ffi_to (obj . key_type) , purpose : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: purpose :: Purpose >> :: ffi_to (obj . purpose) , security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_to (obj . security_level) , contract_bounds : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: contract_bounds :: dpp_identity_identity_public_key_contract_bounds_ContractBounds as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds >> :: ffi_to_opt (obj . contract_bounds) , read_only : obj . read_only , data : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionTo < platform_value :: types :: binary_data :: BinaryData >> :: ffi_to (obj . data) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionTo < platform_value :: types :: binary_data :: BinaryData >> :: ffi_to (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; ferment :: unbox_any (ffi_ref . key_type) ; ferment :: unbox_any (ffi_ref . purpose) ; ferment :: unbox_any (ffi_ref . security_level) ; ferment :: unbox_any_opt (ffi_ref . contract_bounds) ; ; ferment :: unbox_any (ffi_ref . data) ; ferment :: unbox_any (ffi_ref . signature) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`IdentityPublicKeyInCreation`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: v0 :: dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation > for dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation) -> dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation :: V0 (o_0) => dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: v0 :: dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: v0 :: IdentityPublicKeyInCreationV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation > for dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation) -> * const dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation :: V0 (o_0) => dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: v0 :: dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: v0 :: IdentityPublicKeyInCreationV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`StateTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_StateTransition { DataContractCreate (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition) , DataContractUpdate (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition) , Batch (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: dpp_state_transition_state_transitions_document_batch_transition_BatchTransition) , IdentityCreate (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition) , IdentityTopUp (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition) , IdentityCreditWithdrawal (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition) , IdentityUpdate (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition) , IdentityCreditTransfer (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition) , MasternodeVote (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: StateTransition > for dpp_state_transition_StateTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_StateTransition) -> dpp :: state_transition :: StateTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_StateTransition :: DataContractCreate (o_0) => dpp :: state_transition :: StateTransition :: DataContractCreate (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition >> :: ffi_from (* o_0)) , dpp_state_transition_StateTransition :: DataContractUpdate (o_0) => dpp :: state_transition :: StateTransition :: DataContractUpdate (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition >> :: ffi_from (* o_0)) , dpp_state_transition_StateTransition :: Batch (o_0) => dpp :: state_transition :: StateTransition :: Batch (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: dpp_state_transition_state_transitions_document_batch_transition_BatchTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: BatchTransition >> :: ffi_from (* o_0)) , dpp_state_transition_StateTransition :: IdentityCreate (o_0) => dpp :: state_transition :: StateTransition :: IdentityCreate (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: IdentityCreateTransition >> :: ffi_from (* o_0)) , dpp_state_transition_StateTransition :: IdentityTopUp (o_0) => dpp :: state_transition :: StateTransition :: IdentityTopUp (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: IdentityTopUpTransition >> :: ffi_from (* o_0)) , dpp_state_transition_StateTransition :: IdentityCreditWithdrawal (o_0) => dpp :: state_transition :: StateTransition :: IdentityCreditWithdrawal (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: IdentityCreditWithdrawalTransition >> :: ffi_from (* o_0)) , dpp_state_transition_StateTransition :: IdentityUpdate (o_0) => dpp :: state_transition :: StateTransition :: IdentityUpdate (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: IdentityUpdateTransition >> :: ffi_from (* o_0)) , dpp_state_transition_StateTransition :: IdentityCreditTransfer (o_0) => dpp :: state_transition :: StateTransition :: IdentityCreditTransfer (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: IdentityCreditTransferTransition >> :: ffi_from (* o_0)) , dpp_state_transition_StateTransition :: MasternodeVote (o_0) => dpp :: state_transition :: StateTransition :: MasternodeVote (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: MasternodeVoteTransition >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: StateTransition > for dpp_state_transition_StateTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: StateTransition) -> * const dpp_state_transition_StateTransition { ferment :: boxed (match obj { dpp :: state_transition :: StateTransition :: DataContractCreate (o_0) => dpp_state_transition_StateTransition :: DataContractCreate (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: StateTransition :: DataContractUpdate (o_0) => dpp_state_transition_StateTransition :: DataContractUpdate (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: StateTransition :: Batch (o_0) => dpp_state_transition_StateTransition :: Batch (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: dpp_state_transition_state_transitions_document_batch_transition_BatchTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: BatchTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: StateTransition :: IdentityCreate (o_0) => dpp_state_transition_StateTransition :: IdentityCreate (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: IdentityCreateTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: StateTransition :: IdentityTopUp (o_0) => dpp_state_transition_StateTransition :: IdentityTopUp (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: IdentityTopUpTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: StateTransition :: IdentityCreditWithdrawal (o_0) => dpp_state_transition_StateTransition :: IdentityCreditWithdrawal (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: IdentityCreditWithdrawalTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: StateTransition :: IdentityUpdate (o_0) => dpp_state_transition_StateTransition :: IdentityUpdate (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: IdentityUpdateTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: StateTransition :: IdentityCreditTransfer (o_0) => dpp_state_transition_StateTransition :: IdentityCreditTransfer (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: IdentityCreditTransferTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: StateTransition :: MasternodeVote (o_0) => dpp_state_transition_StateTransition :: MasternodeVote (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: MasternodeVoteTransition >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_StateTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_StateTransition :: DataContractCreate (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_StateTransition :: DataContractUpdate (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_StateTransition :: Batch (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_StateTransition :: IdentityCreate (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_StateTransition :: IdentityTopUp (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_StateTransition :: IdentityCreditWithdrawal (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_StateTransition :: IdentityUpdate (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_StateTransition :: IdentityCreditTransfer (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_StateTransition :: MasternodeVote (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod util { pub mod deserializer { use crate as example_platform ; # [doc = "FFI-representation of the [`ProtocolVersion`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_util_deserializer_ProtocolVersion (u32) ; impl ferment :: FFIConversionFrom < dpp :: util :: deserializer :: ProtocolVersion > for dpp_util_deserializer_ProtocolVersion { unsafe fn ffi_from_const (ffi : * const dpp_util_deserializer_ProtocolVersion) -> dpp :: util :: deserializer :: ProtocolVersion { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: util :: deserializer :: ProtocolVersion > for dpp_util_deserializer_ProtocolVersion { unsafe fn ffi_to_const (obj : dpp :: util :: deserializer :: ProtocolVersion) -> * const dpp_util_deserializer_ProtocolVersion { ferment :: boxed (dpp_util_deserializer_ProtocolVersion (obj)) } } } } pub mod errors { pub mod compatible_protocol_version_is_not_defined_error { use crate as example_platform ; # [doc = "FFI-representation of the [`CompatibleProtocolVersionIsNotDefinedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError { pub current_protocol_version : u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: compatible_protocol_version_is_not_defined_error :: CompatibleProtocolVersionIsNotDefinedError > for dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError) -> dpp :: errors :: compatible_protocol_version_is_not_defined_error :: CompatibleProtocolVersionIsNotDefinedError { let ffi_ref = & * ffi ; dpp :: errors :: compatible_protocol_version_is_not_defined_error :: CompatibleProtocolVersionIsNotDefinedError { current_protocol_version : ffi_ref . current_protocol_version } } } impl ferment :: FFIConversionTo < dpp :: errors :: compatible_protocol_version_is_not_defined_error :: CompatibleProtocolVersionIsNotDefinedError > for dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError { unsafe fn ffi_to_const (obj : dpp :: errors :: compatible_protocol_version_is_not_defined_error :: CompatibleProtocolVersionIsNotDefinedError) -> * const dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError { ferment :: boxed (dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError { current_protocol_version : obj . current_protocol_version }) } } } pub mod consensus { pub mod basic { pub mod data_contract { pub mod contested_unique_index_on_mutable_document_type_error { use crate as example_platform ; # [doc = "FFI-representation of the [`ContestedUniqueIndexOnMutableDocumentTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError { pub document_type : * mut std :: os :: raw :: c_char , pub contested_unique_index_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_on_mutable_document_type_error :: ContestedUniqueIndexOnMutableDocumentTypeError > for dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError) -> dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_on_mutable_document_type_error :: ContestedUniqueIndexOnMutableDocumentTypeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_on_mutable_document_type_error :: ContestedUniqueIndexOnMutableDocumentTypeError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , contested_unique_index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . contested_unique_index_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_on_mutable_document_type_error :: ContestedUniqueIndexOnMutableDocumentTypeError > for dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_on_mutable_document_type_error :: ContestedUniqueIndexOnMutableDocumentTypeError) -> * const dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , contested_unique_index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . contested_unique_index_name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . contested_unique_index_name) ; } } } } pub mod contested_unique_index_with_unique_index_error { use crate as example_platform ; # [doc = "FFI-representation of the [`ContestedUniqueIndexWithUniqueIndexError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError { pub document_type : * mut std :: os :: raw :: c_char , pub contested_unique_index_name : * mut std :: os :: raw :: c_char , pub unique_index_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_with_unique_index_error :: ContestedUniqueIndexWithUniqueIndexError > for dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError) -> dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_with_unique_index_error :: ContestedUniqueIndexWithUniqueIndexError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_with_unique_index_error :: ContestedUniqueIndexWithUniqueIndexError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , contested_unique_index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . contested_unique_index_name) , unique_index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . unique_index_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_with_unique_index_error :: ContestedUniqueIndexWithUniqueIndexError > for dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_with_unique_index_error :: ContestedUniqueIndexWithUniqueIndexError) -> * const dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , contested_unique_index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . contested_unique_index_name) , unique_index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . unique_index_name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . contested_unique_index_name) ; ferment :: unbox_string (ffi_ref . unique_index_name) ; } } } } pub mod data_contract_have_new_unique_index_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DataContractHaveNewUniqueIndexError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError { pub document_type : * mut std :: os :: raw :: c_char , pub index_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_have_new_unique_index_error :: DataContractHaveNewUniqueIndexError > for dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError) -> dpp :: errors :: consensus :: basic :: data_contract :: data_contract_have_new_unique_index_error :: DataContractHaveNewUniqueIndexError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: data_contract_have_new_unique_index_error :: DataContractHaveNewUniqueIndexError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . index_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_have_new_unique_index_error :: DataContractHaveNewUniqueIndexError > for dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: data_contract_have_new_unique_index_error :: DataContractHaveNewUniqueIndexError) -> * const dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . index_name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . index_name) ; } } } } pub mod data_contract_immutable_properties_update_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DataContractImmutablePropertiesUpdateError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError { pub operation : * mut std :: os :: raw :: c_char , pub field_path : * mut std :: os :: raw :: c_char , pub old_value : * mut crate :: fermented :: types :: platform_value :: platform_value_Value , pub new_value : * mut crate :: fermented :: types :: platform_value :: platform_value_Value } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_immutable_properties_update_error :: DataContractImmutablePropertiesUpdateError > for dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError) -> dpp :: errors :: consensus :: basic :: data_contract :: data_contract_immutable_properties_update_error :: DataContractImmutablePropertiesUpdateError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: data_contract_immutable_properties_update_error :: DataContractImmutablePropertiesUpdateError { operation : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . operation) , field_path : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . field_path) , old_value : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (ffi_ref . old_value) , new_value : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (ffi_ref . new_value) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_immutable_properties_update_error :: DataContractImmutablePropertiesUpdateError > for dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: data_contract_immutable_properties_update_error :: DataContractImmutablePropertiesUpdateError) -> * const dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError { operation : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . operation) , field_path : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . field_path) , old_value : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (obj . old_value) , new_value : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (obj . new_value) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . operation) ; ferment :: unbox_string (ffi_ref . field_path) ; ferment :: unbox_any (ffi_ref . old_value) ; ferment :: unbox_any (ffi_ref . new_value) ; } } } } pub mod data_contract_invalid_index_definition_update_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DataContractInvalidIndexDefinitionUpdateError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError { pub document_type : * mut std :: os :: raw :: c_char , pub index_path : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_invalid_index_definition_update_error :: DataContractInvalidIndexDefinitionUpdateError > for dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError) -> dpp :: errors :: consensus :: basic :: data_contract :: data_contract_invalid_index_definition_update_error :: DataContractInvalidIndexDefinitionUpdateError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: data_contract_invalid_index_definition_update_error :: DataContractInvalidIndexDefinitionUpdateError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_path : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . index_path) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_invalid_index_definition_update_error :: DataContractInvalidIndexDefinitionUpdateError > for dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: data_contract_invalid_index_definition_update_error :: DataContractInvalidIndexDefinitionUpdateError) -> * const dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_path : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . index_path) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . index_path) ; } } } } pub mod data_contract_max_depth_exceed_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DataContractMaxDepthExceedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError { pub max_depth : usize } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_max_depth_exceed_error :: DataContractMaxDepthExceedError > for dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError) -> dpp :: errors :: consensus :: basic :: data_contract :: data_contract_max_depth_exceed_error :: DataContractMaxDepthExceedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: data_contract_max_depth_exceed_error :: DataContractMaxDepthExceedError { max_depth : ffi_ref . max_depth } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_max_depth_exceed_error :: DataContractMaxDepthExceedError > for dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: data_contract_max_depth_exceed_error :: DataContractMaxDepthExceedError) -> * const dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError { max_depth : obj . max_depth }) } } } pub mod data_contract_token_configuration_update_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DataContractTokenConfigurationUpdateError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError { pub operation : * mut std :: os :: raw :: c_char , pub field_path : * mut std :: os :: raw :: c_char , pub old_config : * mut dpp :: data_contract :: associated_token :: token_configuration :: TokenConfiguration , pub new_config : * mut dpp :: data_contract :: associated_token :: token_configuration :: TokenConfiguration } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_token_configuration_update_error :: DataContractTokenConfigurationUpdateError > for dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError) -> dpp :: errors :: consensus :: basic :: data_contract :: data_contract_token_configuration_update_error :: DataContractTokenConfigurationUpdateError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: data_contract_token_configuration_update_error :: DataContractTokenConfigurationUpdateError { operation : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . operation) , field_path : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . field_path) , old_config : std :: ptr :: read (ffi_ref . old_config) , new_config : std :: ptr :: read (ffi_ref . new_config) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_token_configuration_update_error :: DataContractTokenConfigurationUpdateError > for dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: data_contract_token_configuration_update_error :: DataContractTokenConfigurationUpdateError) -> * const dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError { operation : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . operation) , field_path : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . field_path) , old_config : ferment :: boxed (obj . old_config) , new_config : ferment :: boxed (obj . new_config) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . operation) ; ferment :: unbox_string (ffi_ref . field_path) ; ferment :: unbox_any (ffi_ref . old_config) ; ferment :: unbox_any (ffi_ref . new_config) ; } } } } pub mod data_contract_unique_indices_changed_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DataContractUniqueIndicesChangedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError { pub document_type : * mut std :: os :: raw :: c_char , pub index_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_unique_indices_changed_error :: DataContractUniqueIndicesChangedError > for dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError) -> dpp :: errors :: consensus :: basic :: data_contract :: data_contract_unique_indices_changed_error :: DataContractUniqueIndicesChangedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: data_contract_unique_indices_changed_error :: DataContractUniqueIndicesChangedError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . index_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_unique_indices_changed_error :: DataContractUniqueIndicesChangedError > for dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: data_contract_unique_indices_changed_error :: DataContractUniqueIndicesChangedError) -> * const dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . index_name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . index_name) ; } } } } pub mod document_types_are_missing_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DocumentTypesAreMissingError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: document_types_are_missing_error :: DocumentTypesAreMissingError > for dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError) -> dpp :: errors :: consensus :: basic :: data_contract :: document_types_are_missing_error :: DocumentTypesAreMissingError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: document_types_are_missing_error :: DocumentTypesAreMissingError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: document_types_are_missing_error :: DocumentTypesAreMissingError > for dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: document_types_are_missing_error :: DocumentTypesAreMissingError) -> * const dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; } } } } pub mod duplicate_index_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DuplicateIndexError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError { pub document_type : * mut std :: os :: raw :: c_char , pub index_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_error :: DuplicateIndexError > for dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError) -> dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_error :: DuplicateIndexError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_error :: DuplicateIndexError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . index_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_error :: DuplicateIndexError > for dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_error :: DuplicateIndexError) -> * const dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . index_name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . index_name) ; } } } } pub mod duplicate_index_name_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DuplicateIndexNameError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError { pub document_type : * mut std :: os :: raw :: c_char , pub duplicate_index_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_name_error :: DuplicateIndexNameError > for dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError) -> dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_name_error :: DuplicateIndexNameError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_name_error :: DuplicateIndexNameError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , duplicate_index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . duplicate_index_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_name_error :: DuplicateIndexNameError > for dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_name_error :: DuplicateIndexNameError) -> * const dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , duplicate_index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . duplicate_index_name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . duplicate_index_name) ; } } } } pub mod duplicate_keywords_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DuplicateKeywordsError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_duplicate_keywords_error_DuplicateKeywordsError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub keyword : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: duplicate_keywords_error :: DuplicateKeywordsError > for dpp_errors_consensus_basic_data_contract_duplicate_keywords_error_DuplicateKeywordsError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_duplicate_keywords_error_DuplicateKeywordsError) -> dpp :: errors :: consensus :: basic :: data_contract :: duplicate_keywords_error :: DuplicateKeywordsError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: duplicate_keywords_error :: DuplicateKeywordsError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , keyword : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . keyword) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: duplicate_keywords_error :: DuplicateKeywordsError > for dpp_errors_consensus_basic_data_contract_duplicate_keywords_error_DuplicateKeywordsError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: duplicate_keywords_error :: DuplicateKeywordsError) -> * const dpp_errors_consensus_basic_data_contract_duplicate_keywords_error_DuplicateKeywordsError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_duplicate_keywords_error_DuplicateKeywordsError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , keyword : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . keyword) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_duplicate_keywords_error_DuplicateKeywordsError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_string (ffi_ref . keyword) ; } } } } pub mod group_exceeds_max_members_error { use crate as example_platform ; # [doc = "FFI-representation of the [`GroupExceedsMaxMembersError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError { pub max_members : u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_exceeds_max_members_error :: GroupExceedsMaxMembersError > for dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError) -> dpp :: errors :: consensus :: basic :: data_contract :: group_exceeds_max_members_error :: GroupExceedsMaxMembersError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: group_exceeds_max_members_error :: GroupExceedsMaxMembersError { max_members : ffi_ref . max_members } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_exceeds_max_members_error :: GroupExceedsMaxMembersError > for dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: group_exceeds_max_members_error :: GroupExceedsMaxMembersError) -> * const dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError { max_members : obj . max_members }) } } } pub mod group_member_has_power_of_zero_error { use crate as example_platform ; # [doc = "FFI-representation of the [`GroupMemberHasPowerOfZeroError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError { pub member_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_of_zero_error :: GroupMemberHasPowerOfZeroError > for dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError) -> dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_of_zero_error :: GroupMemberHasPowerOfZeroError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_of_zero_error :: GroupMemberHasPowerOfZeroError { member_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . member_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_of_zero_error :: GroupMemberHasPowerOfZeroError > for dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_of_zero_error :: GroupMemberHasPowerOfZeroError) -> * const dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError { member_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . member_id) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . member_id) ; } } } } pub mod group_member_has_power_over_limit_error { use crate as example_platform ; # [doc = "FFI-representation of the [`GroupMemberHasPowerOverLimitError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError { pub member_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower , pub max_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_over_limit_error :: GroupMemberHasPowerOverLimitError > for dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError) -> dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_over_limit_error :: GroupMemberHasPowerOverLimitError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_over_limit_error :: GroupMemberHasPowerOverLimitError { member_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . member_id) , power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_from (ffi_ref . power) , max_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_from (ffi_ref . max_power) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_over_limit_error :: GroupMemberHasPowerOverLimitError > for dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_over_limit_error :: GroupMemberHasPowerOverLimitError) -> * const dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError { member_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . member_id) , power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_to (obj . power) , max_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_to (obj . max_power) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . member_id) ; ferment :: unbox_any (ffi_ref . power) ; ferment :: unbox_any (ffi_ref . max_power) ; } } } } pub mod group_non_unilateral_member_power_has_less_than_required_power_error { use crate as example_platform ; # [doc = "FFI-representation of the [`GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError { pub total_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower , pub required_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_non_unilateral_member_power_has_less_than_required_power_error :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError > for dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError) -> dpp :: errors :: consensus :: basic :: data_contract :: group_non_unilateral_member_power_has_less_than_required_power_error :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: group_non_unilateral_member_power_has_less_than_required_power_error :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError { total_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_from (ffi_ref . total_power) , required_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_from (ffi_ref . required_power) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_non_unilateral_member_power_has_less_than_required_power_error :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError > for dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: group_non_unilateral_member_power_has_less_than_required_power_error :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError) -> * const dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError { total_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_to (obj . total_power) , required_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_to (obj . required_power) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . total_power) ; ferment :: unbox_any (ffi_ref . required_power) ; } } } } pub mod group_position_does_not_exist_error { use crate as example_platform ; # [doc = "FFI-representation of the [`GroupPositionDoesNotExistError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError { pub missing_group_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_position_does_not_exist_error :: GroupPositionDoesNotExistError > for dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError) -> dpp :: errors :: consensus :: basic :: data_contract :: group_position_does_not_exist_error :: GroupPositionDoesNotExistError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: group_position_does_not_exist_error :: GroupPositionDoesNotExistError { missing_group_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (ffi_ref . missing_group_position) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_position_does_not_exist_error :: GroupPositionDoesNotExistError > for dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: group_position_does_not_exist_error :: GroupPositionDoesNotExistError) -> * const dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError { missing_group_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (obj . missing_group_position) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . missing_group_position) ; } } } } pub mod group_required_power_is_invalid_error { use crate as example_platform ; # [doc = "FFI-representation of the [`GroupRequiredPowerIsInvalidError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_group_required_power_is_invalid_error_GroupRequiredPowerIsInvalidError { pub required_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower , pub max_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_required_power_is_invalid_error :: GroupRequiredPowerIsInvalidError > for dpp_errors_consensus_basic_data_contract_group_required_power_is_invalid_error_GroupRequiredPowerIsInvalidError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_group_required_power_is_invalid_error_GroupRequiredPowerIsInvalidError) -> dpp :: errors :: consensus :: basic :: data_contract :: group_required_power_is_invalid_error :: GroupRequiredPowerIsInvalidError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: group_required_power_is_invalid_error :: GroupRequiredPowerIsInvalidError { required_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupRequiredPower >> :: ffi_from (ffi_ref . required_power) , max_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupRequiredPower >> :: ffi_from (ffi_ref . max_power) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_required_power_is_invalid_error :: GroupRequiredPowerIsInvalidError > for dpp_errors_consensus_basic_data_contract_group_required_power_is_invalid_error_GroupRequiredPowerIsInvalidError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: group_required_power_is_invalid_error :: GroupRequiredPowerIsInvalidError) -> * const dpp_errors_consensus_basic_data_contract_group_required_power_is_invalid_error_GroupRequiredPowerIsInvalidError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_required_power_is_invalid_error_GroupRequiredPowerIsInvalidError { required_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupRequiredPower >> :: ffi_to (obj . required_power) , max_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupRequiredPower >> :: ffi_to (obj . max_power) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_group_required_power_is_invalid_error_GroupRequiredPowerIsInvalidError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . required_power) ; ferment :: unbox_any (ffi_ref . max_power) ; } } } } pub mod group_total_power_has_less_than_required_power_error { use crate as example_platform ; # [doc = "FFI-representation of the [`GroupTotalPowerLessThanRequiredError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError { pub total_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower , pub required_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_total_power_has_less_than_required_power_error :: GroupTotalPowerLessThanRequiredError > for dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError) -> dpp :: errors :: consensus :: basic :: data_contract :: group_total_power_has_less_than_required_power_error :: GroupTotalPowerLessThanRequiredError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: group_total_power_has_less_than_required_power_error :: GroupTotalPowerLessThanRequiredError { total_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_from (ffi_ref . total_power) , required_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_from (ffi_ref . required_power) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_total_power_has_less_than_required_power_error :: GroupTotalPowerLessThanRequiredError > for dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: group_total_power_has_less_than_required_power_error :: GroupTotalPowerLessThanRequiredError) -> * const dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError { total_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_to (obj . total_power) , required_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_to (obj . required_power) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . total_power) ; ferment :: unbox_any (ffi_ref . required_power) ; } } } } pub mod incompatible_data_contract_schema_error { use crate as example_platform ; # [doc = "FFI-representation of the [`IncompatibleDataContractSchemaError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub operation : * mut std :: os :: raw :: c_char , pub field_path : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: incompatible_data_contract_schema_error :: IncompatibleDataContractSchemaError > for dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError) -> dpp :: errors :: consensus :: basic :: data_contract :: incompatible_data_contract_schema_error :: IncompatibleDataContractSchemaError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: incompatible_data_contract_schema_error :: IncompatibleDataContractSchemaError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , operation : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . operation) , field_path : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . field_path) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: incompatible_data_contract_schema_error :: IncompatibleDataContractSchemaError > for dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: incompatible_data_contract_schema_error :: IncompatibleDataContractSchemaError) -> * const dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , operation : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . operation) , field_path : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . field_path) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_string (ffi_ref . operation) ; ferment :: unbox_string (ffi_ref . field_path) ; } } } } pub mod incompatible_document_type_schema_error { use crate as example_platform ; # [doc = "FFI-representation of the [`IncompatibleDocumentTypeSchemaError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError { pub document_type_name : * mut std :: os :: raw :: c_char , pub operation : * mut std :: os :: raw :: c_char , pub property_path : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: incompatible_document_type_schema_error :: IncompatibleDocumentTypeSchemaError > for dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError) -> dpp :: errors :: consensus :: basic :: data_contract :: incompatible_document_type_schema_error :: IncompatibleDocumentTypeSchemaError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: incompatible_document_type_schema_error :: IncompatibleDocumentTypeSchemaError { document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type_name) , operation : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . operation) , property_path : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . property_path) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: incompatible_document_type_schema_error :: IncompatibleDocumentTypeSchemaError > for dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: incompatible_document_type_schema_error :: IncompatibleDocumentTypeSchemaError) -> * const dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError { document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type_name) , operation : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . operation) , property_path : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . property_path) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type_name) ; ferment :: unbox_string (ffi_ref . operation) ; ferment :: unbox_string (ffi_ref . property_path) ; } } } } pub mod incompatible_re2_pattern_error { use crate as example_platform ; # [doc = "FFI-representation of the [`IncompatibleRe2PatternError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError { pub pattern : * mut std :: os :: raw :: c_char , pub path : * mut std :: os :: raw :: c_char , pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: incompatible_re2_pattern_error :: IncompatibleRe2PatternError > for dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError) -> dpp :: errors :: consensus :: basic :: data_contract :: incompatible_re2_pattern_error :: IncompatibleRe2PatternError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: incompatible_re2_pattern_error :: IncompatibleRe2PatternError { pattern : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . pattern) , path : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . path) , message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: incompatible_re2_pattern_error :: IncompatibleRe2PatternError > for dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: incompatible_re2_pattern_error :: IncompatibleRe2PatternError) -> * const dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError { pattern : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . pattern) , path : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . path) , message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . pattern) ; ferment :: unbox_string (ffi_ref . path) ; ferment :: unbox_string (ffi_ref . message) ; } } } } pub mod invalid_compound_index_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidCompoundIndexError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError { pub document_type : * mut std :: os :: raw :: c_char , pub index_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_compound_index_error :: InvalidCompoundIndexError > for dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_compound_index_error :: InvalidCompoundIndexError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_compound_index_error :: InvalidCompoundIndexError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . index_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_compound_index_error :: InvalidCompoundIndexError > for dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_compound_index_error :: InvalidCompoundIndexError) -> * const dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . index_name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . index_name) ; } } } } pub mod invalid_data_contract_id_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidDataContractIdError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError { pub expected_id : * mut crate :: fermented :: generics :: Vec_u8 , pub invalid_id : * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_id_error :: InvalidDataContractIdError > for dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_id_error :: InvalidDataContractIdError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_id_error :: InvalidDataContractIdError { expected_id : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . expected_id) , invalid_id : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . invalid_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_id_error :: InvalidDataContractIdError > for dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_id_error :: InvalidDataContractIdError) -> * const dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError { expected_id : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . expected_id) , invalid_id : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . invalid_id) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . expected_id) ; ferment :: unbox_any (ffi_ref . invalid_id) ; } } } } pub mod invalid_data_contract_version_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidDataContractVersionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError { pub expected_version : u32 , pub version : u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_version_error :: InvalidDataContractVersionError > for dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_version_error :: InvalidDataContractVersionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_version_error :: InvalidDataContractVersionError { expected_version : ffi_ref . expected_version , version : ffi_ref . version } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_version_error :: InvalidDataContractVersionError > for dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_version_error :: InvalidDataContractVersionError) -> * const dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError { expected_version : obj . expected_version , version : obj . version }) } } } pub mod invalid_description_length_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidDescriptionLengthError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_description_length_error_InvalidDescriptionLengthError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub description : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_description_length_error :: InvalidDescriptionLengthError > for dpp_errors_consensus_basic_data_contract_invalid_description_length_error_InvalidDescriptionLengthError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_description_length_error_InvalidDescriptionLengthError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_description_length_error :: InvalidDescriptionLengthError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_description_length_error :: InvalidDescriptionLengthError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , description : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . description) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_description_length_error :: InvalidDescriptionLengthError > for dpp_errors_consensus_basic_data_contract_invalid_description_length_error_InvalidDescriptionLengthError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_description_length_error :: InvalidDescriptionLengthError) -> * const dpp_errors_consensus_basic_data_contract_invalid_description_length_error_InvalidDescriptionLengthError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_description_length_error_InvalidDescriptionLengthError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , description : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . description) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_description_length_error_InvalidDescriptionLengthError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_string (ffi_ref . description) ; } } } } pub mod invalid_document_type_name_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidDocumentTypeNameError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError { pub name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_name_error :: InvalidDocumentTypeNameError > for dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_name_error :: InvalidDocumentTypeNameError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_name_error :: InvalidDocumentTypeNameError { name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_name_error :: InvalidDocumentTypeNameError > for dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_name_error :: InvalidDocumentTypeNameError) -> * const dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError { name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . name) ; } } } } pub mod invalid_document_type_required_security_level { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidDocumentTypeRequiredSecurityLevelError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError { pub security_level : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel , pub contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub document_type_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_required_security_level :: InvalidDocumentTypeRequiredSecurityLevelError > for dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_required_security_level :: InvalidDocumentTypeRequiredSecurityLevelError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_required_security_level :: InvalidDocumentTypeRequiredSecurityLevelError { security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_from (ffi_ref . security_level) , contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . contract_id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_required_security_level :: InvalidDocumentTypeRequiredSecurityLevelError > for dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_required_security_level :: InvalidDocumentTypeRequiredSecurityLevelError) -> * const dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError { security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_to (obj . security_level) , contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . contract_id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type_name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . security_level) ; ferment :: unbox_any (ffi_ref . contract_id) ; ferment :: unbox_string (ffi_ref . document_type_name) ; } } } } pub mod invalid_index_property_type_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidIndexPropertyTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError { pub document_type : * mut std :: os :: raw :: c_char , pub index_name : * mut std :: os :: raw :: c_char , pub property_name : * mut std :: os :: raw :: c_char , pub property_type : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_index_property_type_error :: InvalidIndexPropertyTypeError > for dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_index_property_type_error :: InvalidIndexPropertyTypeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_index_property_type_error :: InvalidIndexPropertyTypeError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . index_name) , property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . property_name) , property_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . property_type) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_index_property_type_error :: InvalidIndexPropertyTypeError > for dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_index_property_type_error :: InvalidIndexPropertyTypeError) -> * const dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . index_name) , property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . property_name) , property_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . property_type) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . index_name) ; ferment :: unbox_string (ffi_ref . property_name) ; ferment :: unbox_string (ffi_ref . property_type) ; } } } } pub mod invalid_indexed_property_constraint_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidIndexedPropertyConstraintError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError { pub document_type : * mut std :: os :: raw :: c_char , pub index_name : * mut std :: os :: raw :: c_char , pub property_name : * mut std :: os :: raw :: c_char , pub constraint_name : * mut std :: os :: raw :: c_char , pub reason : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_indexed_property_constraint_error :: InvalidIndexedPropertyConstraintError > for dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_indexed_property_constraint_error :: InvalidIndexedPropertyConstraintError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_indexed_property_constraint_error :: InvalidIndexedPropertyConstraintError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . index_name) , property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . property_name) , constraint_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . constraint_name) , reason : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . reason) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_indexed_property_constraint_error :: InvalidIndexedPropertyConstraintError > for dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_indexed_property_constraint_error :: InvalidIndexedPropertyConstraintError) -> * const dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . index_name) , property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . property_name) , constraint_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . constraint_name) , reason : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . reason) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . index_name) ; ferment :: unbox_string (ffi_ref . property_name) ; ferment :: unbox_string (ffi_ref . constraint_name) ; ferment :: unbox_string (ffi_ref . reason) ; } } } } pub mod invalid_json_schema_ref_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidJsonSchemaRefError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_json_schema_ref_error :: InvalidJsonSchemaRefError > for dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_json_schema_ref_error :: InvalidJsonSchemaRefError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_json_schema_ref_error :: InvalidJsonSchemaRefError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_json_schema_ref_error :: InvalidJsonSchemaRefError > for dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_json_schema_ref_error :: InvalidJsonSchemaRefError) -> * const dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } } pub mod invalid_keyword_character_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidKeywordCharacterError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_keyword_character_error_InvalidKeywordCharacterError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub keyword : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_keyword_character_error :: InvalidKeywordCharacterError > for dpp_errors_consensus_basic_data_contract_invalid_keyword_character_error_InvalidKeywordCharacterError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_keyword_character_error_InvalidKeywordCharacterError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_keyword_character_error :: InvalidKeywordCharacterError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_keyword_character_error :: InvalidKeywordCharacterError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , keyword : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . keyword) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_keyword_character_error :: InvalidKeywordCharacterError > for dpp_errors_consensus_basic_data_contract_invalid_keyword_character_error_InvalidKeywordCharacterError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_keyword_character_error :: InvalidKeywordCharacterError) -> * const dpp_errors_consensus_basic_data_contract_invalid_keyword_character_error_InvalidKeywordCharacterError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_keyword_character_error_InvalidKeywordCharacterError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , keyword : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . keyword) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_keyword_character_error_InvalidKeywordCharacterError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_string (ffi_ref . keyword) ; } } } } pub mod invalid_keyword_length_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidKeywordLengthError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_keyword_length_error_InvalidKeywordLengthError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub keyword : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_keyword_length_error :: InvalidKeywordLengthError > for dpp_errors_consensus_basic_data_contract_invalid_keyword_length_error_InvalidKeywordLengthError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_keyword_length_error_InvalidKeywordLengthError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_keyword_length_error :: InvalidKeywordLengthError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_keyword_length_error :: InvalidKeywordLengthError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , keyword : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . keyword) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_keyword_length_error :: InvalidKeywordLengthError > for dpp_errors_consensus_basic_data_contract_invalid_keyword_length_error_InvalidKeywordLengthError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_keyword_length_error :: InvalidKeywordLengthError) -> * const dpp_errors_consensus_basic_data_contract_invalid_keyword_length_error_InvalidKeywordLengthError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_keyword_length_error_InvalidKeywordLengthError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , keyword : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . keyword) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_keyword_length_error_InvalidKeywordLengthError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_string (ffi_ref . keyword) ; } } } } pub mod invalid_token_base_supply_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidTokenBaseSupplyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError { pub base_supply : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_base_supply_error :: InvalidTokenBaseSupplyError > for dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_base_supply_error :: InvalidTokenBaseSupplyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_base_supply_error :: InvalidTokenBaseSupplyError { base_supply : ffi_ref . base_supply } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_base_supply_error :: InvalidTokenBaseSupplyError > for dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_base_supply_error :: InvalidTokenBaseSupplyError) -> * const dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError { base_supply : obj . base_supply }) } } } pub mod invalid_token_distribution_function_divide_by_zero_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidTokenDistributionFunctionDivideByZeroError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError { pub distribution_function : * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_divide_by_zero_error :: InvalidTokenDistributionFunctionDivideByZeroError > for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_divide_by_zero_error :: InvalidTokenDistributionFunctionDivideByZeroError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_divide_by_zero_error :: InvalidTokenDistributionFunctionDivideByZeroError { distribution_function : < crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction as ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction >> :: ffi_from (ffi_ref . distribution_function) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_divide_by_zero_error :: InvalidTokenDistributionFunctionDivideByZeroError > for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_divide_by_zero_error :: InvalidTokenDistributionFunctionDivideByZeroError) -> * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError { distribution_function : < crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction as ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction >> :: ffi_to (obj . distribution_function) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . distribution_function) ; } } } } pub mod invalid_token_distribution_function_incoherence_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidTokenDistributionFunctionIncoherenceError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_incoherence_error :: InvalidTokenDistributionFunctionIncoherenceError > for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_incoherence_error :: InvalidTokenDistributionFunctionIncoherenceError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_incoherence_error :: InvalidTokenDistributionFunctionIncoherenceError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_incoherence_error :: InvalidTokenDistributionFunctionIncoherenceError > for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_incoherence_error :: InvalidTokenDistributionFunctionIncoherenceError) -> * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } } pub mod invalid_token_distribution_function_invalid_parameter_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidTokenDistributionFunctionInvalidParameterError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError { pub parameter : * mut std :: os :: raw :: c_char , pub min : i64 , pub max : i64 , pub not_valid : * mut i64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_error :: InvalidTokenDistributionFunctionInvalidParameterError > for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_error :: InvalidTokenDistributionFunctionInvalidParameterError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_error :: InvalidTokenDistributionFunctionInvalidParameterError { parameter : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . parameter) , min : ffi_ref . min , max : ffi_ref . max , not_valid : ferment :: from_opt_primitive (ffi_ref . not_valid) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_error :: InvalidTokenDistributionFunctionInvalidParameterError > for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_error :: InvalidTokenDistributionFunctionInvalidParameterError) -> * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError { parameter : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . parameter) , min : obj . min , max : obj . max , not_valid : ferment :: to_opt_primitive (obj . not_valid) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . parameter) ; ; ; ferment :: unbox_any_opt (ffi_ref . not_valid) ; } } } } pub mod invalid_token_distribution_function_invalid_parameter_tuple_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidTokenDistributionFunctionInvalidParameterTupleError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError { pub first_parameter : * mut std :: os :: raw :: c_char , pub second_parameter : * mut std :: os :: raw :: c_char , pub relation : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_tuple_error :: InvalidTokenDistributionFunctionInvalidParameterTupleError > for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_tuple_error :: InvalidTokenDistributionFunctionInvalidParameterTupleError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_tuple_error :: InvalidTokenDistributionFunctionInvalidParameterTupleError { first_parameter : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . first_parameter) , second_parameter : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . second_parameter) , relation : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . relation) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_tuple_error :: InvalidTokenDistributionFunctionInvalidParameterTupleError > for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_tuple_error :: InvalidTokenDistributionFunctionInvalidParameterTupleError) -> * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError { first_parameter : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . first_parameter) , second_parameter : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . second_parameter) , relation : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . relation) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . first_parameter) ; ferment :: unbox_string (ffi_ref . second_parameter) ; ferment :: unbox_string (ffi_ref . relation) ; } } } } pub mod invalid_token_language_code_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidTokenLanguageCodeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_token_language_code_error_InvalidTokenLanguageCodeError { pub language_code : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_language_code_error :: InvalidTokenLanguageCodeError > for dpp_errors_consensus_basic_data_contract_invalid_token_language_code_error_InvalidTokenLanguageCodeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_token_language_code_error_InvalidTokenLanguageCodeError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_language_code_error :: InvalidTokenLanguageCodeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_language_code_error :: InvalidTokenLanguageCodeError { language_code : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . language_code) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_language_code_error :: InvalidTokenLanguageCodeError > for dpp_errors_consensus_basic_data_contract_invalid_token_language_code_error_InvalidTokenLanguageCodeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_language_code_error :: InvalidTokenLanguageCodeError) -> * const dpp_errors_consensus_basic_data_contract_invalid_token_language_code_error_InvalidTokenLanguageCodeError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_language_code_error_InvalidTokenLanguageCodeError { language_code : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . language_code) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_token_language_code_error_InvalidTokenLanguageCodeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . language_code) ; } } } } pub mod invalid_token_name_character_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidTokenNameCharacterError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_token_name_character_error_InvalidTokenNameCharacterError { pub form : * mut std :: os :: raw :: c_char , pub token_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_name_character_error :: InvalidTokenNameCharacterError > for dpp_errors_consensus_basic_data_contract_invalid_token_name_character_error_InvalidTokenNameCharacterError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_token_name_character_error_InvalidTokenNameCharacterError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_name_character_error :: InvalidTokenNameCharacterError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_name_character_error :: InvalidTokenNameCharacterError { form : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . form) , token_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . token_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_name_character_error :: InvalidTokenNameCharacterError > for dpp_errors_consensus_basic_data_contract_invalid_token_name_character_error_InvalidTokenNameCharacterError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_name_character_error :: InvalidTokenNameCharacterError) -> * const dpp_errors_consensus_basic_data_contract_invalid_token_name_character_error_InvalidTokenNameCharacterError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_name_character_error_InvalidTokenNameCharacterError { form : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . form) , token_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . token_name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_token_name_character_error_InvalidTokenNameCharacterError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . form) ; ferment :: unbox_string (ffi_ref . token_name) ; } } } } pub mod invalid_token_name_length_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidTokenNameLengthError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError { pub actual : usize , pub min : usize , pub max : usize , pub form : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_name_length_error :: InvalidTokenNameLengthError > for dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_name_length_error :: InvalidTokenNameLengthError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_name_length_error :: InvalidTokenNameLengthError { actual : ffi_ref . actual , min : ffi_ref . min , max : ffi_ref . max , form : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . form) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_name_length_error :: InvalidTokenNameLengthError > for dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_name_length_error :: InvalidTokenNameLengthError) -> * const dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError { actual : obj . actual , min : obj . min , max : obj . max , form : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . form) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ; ferment :: unbox_string (ffi_ref . form) ; } } } } pub mod keywords_over_limit { use crate as example_platform ; # [doc = "FFI-representation of the [`TooManyKeywordsError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_keywords_over_limit_TooManyKeywordsError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub keywords_len : u8 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: keywords_over_limit :: TooManyKeywordsError > for dpp_errors_consensus_basic_data_contract_keywords_over_limit_TooManyKeywordsError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_keywords_over_limit_TooManyKeywordsError) -> dpp :: errors :: consensus :: basic :: data_contract :: keywords_over_limit :: TooManyKeywordsError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: keywords_over_limit :: TooManyKeywordsError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , keywords_len : ffi_ref . keywords_len } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: keywords_over_limit :: TooManyKeywordsError > for dpp_errors_consensus_basic_data_contract_keywords_over_limit_TooManyKeywordsError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: keywords_over_limit :: TooManyKeywordsError) -> * const dpp_errors_consensus_basic_data_contract_keywords_over_limit_TooManyKeywordsError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_keywords_over_limit_TooManyKeywordsError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , keywords_len : obj . keywords_len }) } } impl Drop for dpp_errors_consensus_basic_data_contract_keywords_over_limit_TooManyKeywordsError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ; } } } } pub mod main_group_is_not_defined { use crate as example_platform ; # [doc = "FFI-representation of the [`MainGroupIsNotDefinedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_main_group_is_not_defined_MainGroupIsNotDefinedError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: main_group_is_not_defined :: MainGroupIsNotDefinedError > for dpp_errors_consensus_basic_data_contract_main_group_is_not_defined_MainGroupIsNotDefinedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_main_group_is_not_defined_MainGroupIsNotDefinedError) -> dpp :: errors :: consensus :: basic :: data_contract :: main_group_is_not_defined :: MainGroupIsNotDefinedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: main_group_is_not_defined :: MainGroupIsNotDefinedError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: main_group_is_not_defined :: MainGroupIsNotDefinedError > for dpp_errors_consensus_basic_data_contract_main_group_is_not_defined_MainGroupIsNotDefinedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: main_group_is_not_defined :: MainGroupIsNotDefinedError) -> * const dpp_errors_consensus_basic_data_contract_main_group_is_not_defined_MainGroupIsNotDefinedError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_main_group_is_not_defined_MainGroupIsNotDefinedError { }) } } } pub mod new_tokens_destination_identity_option_required_error { use crate as example_platform ; # [doc = "FFI-representation of the [`NewTokensDestinationIdentityOptionRequiredError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_new_tokens_destination_identity_option_required_error_NewTokensDestinationIdentityOptionRequiredError { pub contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub token_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: new_tokens_destination_identity_option_required_error :: NewTokensDestinationIdentityOptionRequiredError > for dpp_errors_consensus_basic_data_contract_new_tokens_destination_identity_option_required_error_NewTokensDestinationIdentityOptionRequiredError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_new_tokens_destination_identity_option_required_error_NewTokensDestinationIdentityOptionRequiredError) -> dpp :: errors :: consensus :: basic :: data_contract :: new_tokens_destination_identity_option_required_error :: NewTokensDestinationIdentityOptionRequiredError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: new_tokens_destination_identity_option_required_error :: NewTokensDestinationIdentityOptionRequiredError { contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . contract_id) , token_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from (ffi_ref . token_position) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: new_tokens_destination_identity_option_required_error :: NewTokensDestinationIdentityOptionRequiredError > for dpp_errors_consensus_basic_data_contract_new_tokens_destination_identity_option_required_error_NewTokensDestinationIdentityOptionRequiredError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: new_tokens_destination_identity_option_required_error :: NewTokensDestinationIdentityOptionRequiredError) -> * const dpp_errors_consensus_basic_data_contract_new_tokens_destination_identity_option_required_error_NewTokensDestinationIdentityOptionRequiredError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_new_tokens_destination_identity_option_required_error_NewTokensDestinationIdentityOptionRequiredError { contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . contract_id) , token_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition >> :: ffi_to (obj . token_position) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_new_tokens_destination_identity_option_required_error_NewTokensDestinationIdentityOptionRequiredError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . contract_id) ; ferment :: unbox_any (ffi_ref . token_position) ; } } } } pub mod non_contiguous_contract_group_positions_error { use crate as example_platform ; # [doc = "FFI-representation of the [`NonContiguousContractGroupPositionsError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError { pub missing_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , pub followed_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_group_positions_error :: NonContiguousContractGroupPositionsError > for dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError) -> dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_group_positions_error :: NonContiguousContractGroupPositionsError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_group_positions_error :: NonContiguousContractGroupPositionsError { missing_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (ffi_ref . missing_position) , followed_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (ffi_ref . followed_position) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_group_positions_error :: NonContiguousContractGroupPositionsError > for dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_group_positions_error :: NonContiguousContractGroupPositionsError) -> * const dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError { missing_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (obj . missing_position) , followed_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (obj . followed_position) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . missing_position) ; ferment :: unbox_any (ffi_ref . followed_position) ; } } } } pub mod non_contiguous_contract_token_positions_error { use crate as example_platform ; # [doc = "FFI-representation of the [`NonContiguousContractTokenPositionsError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError { pub missing_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , pub followed_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_token_positions_error :: NonContiguousContractTokenPositionsError > for dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError) -> dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_token_positions_error :: NonContiguousContractTokenPositionsError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_token_positions_error :: NonContiguousContractTokenPositionsError { missing_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from (ffi_ref . missing_position) , followed_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from (ffi_ref . followed_position) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_token_positions_error :: NonContiguousContractTokenPositionsError > for dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_token_positions_error :: NonContiguousContractTokenPositionsError) -> * const dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError { missing_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition >> :: ffi_to (obj . missing_position) , followed_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition >> :: ffi_to (obj . followed_position) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . missing_position) ; ferment :: unbox_any (ffi_ref . followed_position) ; } } } } pub mod redundant_document_paid_for_by_token_with_contract_id { use crate as example_platform ; # [doc = "FFI-representation of the [`RedundantDocumentPaidForByTokenWithContractId`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_redundant_document_paid_for_by_token_with_contract_id_RedundantDocumentPaidForByTokenWithContractId { pub contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: redundant_document_paid_for_by_token_with_contract_id :: RedundantDocumentPaidForByTokenWithContractId > for dpp_errors_consensus_basic_data_contract_redundant_document_paid_for_by_token_with_contract_id_RedundantDocumentPaidForByTokenWithContractId { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_redundant_document_paid_for_by_token_with_contract_id_RedundantDocumentPaidForByTokenWithContractId) -> dpp :: errors :: consensus :: basic :: data_contract :: redundant_document_paid_for_by_token_with_contract_id :: RedundantDocumentPaidForByTokenWithContractId { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: redundant_document_paid_for_by_token_with_contract_id :: RedundantDocumentPaidForByTokenWithContractId { contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . contract_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: redundant_document_paid_for_by_token_with_contract_id :: RedundantDocumentPaidForByTokenWithContractId > for dpp_errors_consensus_basic_data_contract_redundant_document_paid_for_by_token_with_contract_id_RedundantDocumentPaidForByTokenWithContractId { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: redundant_document_paid_for_by_token_with_contract_id :: RedundantDocumentPaidForByTokenWithContractId) -> * const dpp_errors_consensus_basic_data_contract_redundant_document_paid_for_by_token_with_contract_id_RedundantDocumentPaidForByTokenWithContractId { ferment :: boxed (dpp_errors_consensus_basic_data_contract_redundant_document_paid_for_by_token_with_contract_id_RedundantDocumentPaidForByTokenWithContractId { contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . contract_id) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_redundant_document_paid_for_by_token_with_contract_id_RedundantDocumentPaidForByTokenWithContractId { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . contract_id) ; } } } } pub mod system_property_index_already_present_error { use crate as example_platform ; # [doc = "FFI-representation of the [`SystemPropertyIndexAlreadyPresentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError { pub document_type : * mut std :: os :: raw :: c_char , pub index_name : * mut std :: os :: raw :: c_char , pub property_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: system_property_index_already_present_error :: SystemPropertyIndexAlreadyPresentError > for dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError) -> dpp :: errors :: consensus :: basic :: data_contract :: system_property_index_already_present_error :: SystemPropertyIndexAlreadyPresentError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: system_property_index_already_present_error :: SystemPropertyIndexAlreadyPresentError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . index_name) , property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . property_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: system_property_index_already_present_error :: SystemPropertyIndexAlreadyPresentError > for dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: system_property_index_already_present_error :: SystemPropertyIndexAlreadyPresentError) -> * const dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . index_name) , property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . property_name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . index_name) ; ferment :: unbox_string (ffi_ref . property_name) ; } } } } pub mod token_decimals_over_limit_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DecimalsOverLimitError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_token_decimals_over_limit_error_DecimalsOverLimitError { pub decimals : u8 , pub max_decimals : u8 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: token_decimals_over_limit_error :: DecimalsOverLimitError > for dpp_errors_consensus_basic_data_contract_token_decimals_over_limit_error_DecimalsOverLimitError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_token_decimals_over_limit_error_DecimalsOverLimitError) -> dpp :: errors :: consensus :: basic :: data_contract :: token_decimals_over_limit_error :: DecimalsOverLimitError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: token_decimals_over_limit_error :: DecimalsOverLimitError { decimals : ffi_ref . decimals , max_decimals : ffi_ref . max_decimals } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: token_decimals_over_limit_error :: DecimalsOverLimitError > for dpp_errors_consensus_basic_data_contract_token_decimals_over_limit_error_DecimalsOverLimitError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: token_decimals_over_limit_error :: DecimalsOverLimitError) -> * const dpp_errors_consensus_basic_data_contract_token_decimals_over_limit_error_DecimalsOverLimitError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_token_decimals_over_limit_error_DecimalsOverLimitError { decimals : obj . decimals , max_decimals : obj . max_decimals }) } } } pub mod token_payment_by_burning_only_allowed_on_internal_token_error { use crate as example_platform ; # [doc = "FFI-representation of the [`TokenPaymentByBurningOnlyAllowedOnInternalTokenError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError { pub external_token_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub external_token_contract_token_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , pub action : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: token_payment_by_burning_only_allowed_on_internal_token_error :: TokenPaymentByBurningOnlyAllowedOnInternalTokenError > for dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError) -> dpp :: errors :: consensus :: basic :: data_contract :: token_payment_by_burning_only_allowed_on_internal_token_error :: TokenPaymentByBurningOnlyAllowedOnInternalTokenError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: token_payment_by_burning_only_allowed_on_internal_token_error :: TokenPaymentByBurningOnlyAllowedOnInternalTokenError { external_token_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . external_token_contract_id) , external_token_contract_token_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from (ffi_ref . external_token_contract_token_position) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: token_payment_by_burning_only_allowed_on_internal_token_error :: TokenPaymentByBurningOnlyAllowedOnInternalTokenError > for dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: token_payment_by_burning_only_allowed_on_internal_token_error :: TokenPaymentByBurningOnlyAllowedOnInternalTokenError) -> * const dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError { external_token_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . external_token_contract_id) , external_token_contract_token_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition >> :: ffi_to (obj . external_token_contract_token_position) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . external_token_contract_id) ; ferment :: unbox_any (ffi_ref . external_token_contract_token_position) ; ferment :: unbox_string (ffi_ref . action) ; } } } } pub mod undefined_index_property_error { use crate as example_platform ; # [doc = "FFI-representation of the [`UndefinedIndexPropertyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError { pub document_type : * mut std :: os :: raw :: c_char , pub index_name : * mut std :: os :: raw :: c_char , pub property_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: undefined_index_property_error :: UndefinedIndexPropertyError > for dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError) -> dpp :: errors :: consensus :: basic :: data_contract :: undefined_index_property_error :: UndefinedIndexPropertyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: undefined_index_property_error :: UndefinedIndexPropertyError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . index_name) , property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . property_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: undefined_index_property_error :: UndefinedIndexPropertyError > for dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: undefined_index_property_error :: UndefinedIndexPropertyError) -> * const dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . index_name) , property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . property_name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . index_name) ; ferment :: unbox_string (ffi_ref . property_name) ; } } } } pub mod unique_indices_limit_reached_error { use crate as example_platform ; # [doc = "FFI-representation of the [`UniqueIndicesLimitReachedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError { pub document_type : * mut std :: os :: raw :: c_char , pub index_limit : u16 , pub is_contested_limit : bool } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unique_indices_limit_reached_error :: UniqueIndicesLimitReachedError > for dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError) -> dpp :: errors :: consensus :: basic :: data_contract :: unique_indices_limit_reached_error :: UniqueIndicesLimitReachedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: unique_indices_limit_reached_error :: UniqueIndicesLimitReachedError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_limit : ffi_ref . index_limit , is_contested_limit : ffi_ref . is_contested_limit } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unique_indices_limit_reached_error :: UniqueIndicesLimitReachedError > for dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: unique_indices_limit_reached_error :: UniqueIndicesLimitReachedError) -> * const dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_limit : obj . index_limit , is_contested_limit : obj . is_contested_limit }) } } impl Drop for dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ; ; } } } } pub mod unknown_document_action_token_effect_error { use crate as example_platform ; # [doc = "FFI-representation of the [`UnknownDocumentActionTokenEffectError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_unknown_document_action_token_effect_error_UnknownDocumentActionTokenEffectError { pub allowed_values : * mut crate :: fermented :: generics :: Vec_u8 , pub received : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_action_token_effect_error :: UnknownDocumentActionTokenEffectError > for dpp_errors_consensus_basic_data_contract_unknown_document_action_token_effect_error_UnknownDocumentActionTokenEffectError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_unknown_document_action_token_effect_error_UnknownDocumentActionTokenEffectError) -> dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_action_token_effect_error :: UnknownDocumentActionTokenEffectError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_action_token_effect_error :: UnknownDocumentActionTokenEffectError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . allowed_values) , received : ffi_ref . received } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_action_token_effect_error :: UnknownDocumentActionTokenEffectError > for dpp_errors_consensus_basic_data_contract_unknown_document_action_token_effect_error_UnknownDocumentActionTokenEffectError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_action_token_effect_error :: UnknownDocumentActionTokenEffectError) -> * const dpp_errors_consensus_basic_data_contract_unknown_document_action_token_effect_error_UnknownDocumentActionTokenEffectError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unknown_document_action_token_effect_error_UnknownDocumentActionTokenEffectError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . allowed_values) , received : obj . received }) } } impl Drop for dpp_errors_consensus_basic_data_contract_unknown_document_action_token_effect_error_UnknownDocumentActionTokenEffectError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . allowed_values) ; ; } } } } pub mod unknown_document_creation_restriction_mode_error { use crate as example_platform ; # [doc = "FFI-representation of the [`UnknownDocumentCreationRestrictionModeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError { pub allowed_values : * mut crate :: fermented :: generics :: Vec_u8 , pub received : u8 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_creation_restriction_mode_error :: UnknownDocumentCreationRestrictionModeError > for dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError) -> dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_creation_restriction_mode_error :: UnknownDocumentCreationRestrictionModeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_creation_restriction_mode_error :: UnknownDocumentCreationRestrictionModeError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . allowed_values) , received : ffi_ref . received } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_creation_restriction_mode_error :: UnknownDocumentCreationRestrictionModeError > for dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_creation_restriction_mode_error :: UnknownDocumentCreationRestrictionModeError) -> * const dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . allowed_values) , received : obj . received }) } } impl Drop for dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . allowed_values) ; ; } } } } pub mod unknown_gas_fees_paid_by_error { use crate as example_platform ; # [doc = "FFI-representation of the [`UnknownGasFeesPaidByError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_unknown_gas_fees_paid_by_error_UnknownGasFeesPaidByError { pub allowed_values : * mut crate :: fermented :: generics :: Vec_u8 , pub received : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unknown_gas_fees_paid_by_error :: UnknownGasFeesPaidByError > for dpp_errors_consensus_basic_data_contract_unknown_gas_fees_paid_by_error_UnknownGasFeesPaidByError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_unknown_gas_fees_paid_by_error_UnknownGasFeesPaidByError) -> dpp :: errors :: consensus :: basic :: data_contract :: unknown_gas_fees_paid_by_error :: UnknownGasFeesPaidByError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: unknown_gas_fees_paid_by_error :: UnknownGasFeesPaidByError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . allowed_values) , received : ffi_ref . received } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unknown_gas_fees_paid_by_error :: UnknownGasFeesPaidByError > for dpp_errors_consensus_basic_data_contract_unknown_gas_fees_paid_by_error_UnknownGasFeesPaidByError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: unknown_gas_fees_paid_by_error :: UnknownGasFeesPaidByError) -> * const dpp_errors_consensus_basic_data_contract_unknown_gas_fees_paid_by_error_UnknownGasFeesPaidByError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unknown_gas_fees_paid_by_error_UnknownGasFeesPaidByError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . allowed_values) , received : obj . received }) } } impl Drop for dpp_errors_consensus_basic_data_contract_unknown_gas_fees_paid_by_error_UnknownGasFeesPaidByError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . allowed_values) ; ; } } } } pub mod unknown_security_level_error { use crate as example_platform ; # [doc = "FFI-representation of the [`UnknownSecurityLevelError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError { pub allowed_values : * mut crate :: fermented :: generics :: Vec_u8 , pub received : u8 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unknown_security_level_error :: UnknownSecurityLevelError > for dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError) -> dpp :: errors :: consensus :: basic :: data_contract :: unknown_security_level_error :: UnknownSecurityLevelError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: unknown_security_level_error :: UnknownSecurityLevelError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . allowed_values) , received : ffi_ref . received } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unknown_security_level_error :: UnknownSecurityLevelError > for dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: unknown_security_level_error :: UnknownSecurityLevelError) -> * const dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . allowed_values) , received : obj . received }) } } impl Drop for dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . allowed_values) ; ; } } } } pub mod unknown_storage_key_requirements_error { use crate as example_platform ; # [doc = "FFI-representation of the [`UnknownStorageKeyRequirementsError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError { pub allowed_values : * mut crate :: fermented :: generics :: Vec_u8 , pub received : * mut [u8 ; 16] } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unknown_storage_key_requirements_error :: UnknownStorageKeyRequirementsError > for dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError) -> dpp :: errors :: consensus :: basic :: data_contract :: unknown_storage_key_requirements_error :: UnknownStorageKeyRequirementsError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: unknown_storage_key_requirements_error :: UnknownStorageKeyRequirementsError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . allowed_values) , received : < [u8 ; 16] as ferment :: FFIConversionFrom < i128 >> :: ffi_from (ffi_ref . received) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unknown_storage_key_requirements_error :: UnknownStorageKeyRequirementsError > for dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: unknown_storage_key_requirements_error :: UnknownStorageKeyRequirementsError) -> * const dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . allowed_values) , received : < [u8 ; 16] as ferment :: FFIConversionTo < i128 >> :: ffi_to (obj . received) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . allowed_values) ; ferment :: unbox_any_opt (ffi_ref . received) ; } } } } pub mod unknown_trade_mode_error { use crate as example_platform ; # [doc = "FFI-representation of the [`UnknownTradeModeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError { pub allowed_values : * mut crate :: fermented :: generics :: Vec_u8 , pub received : u8 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unknown_trade_mode_error :: UnknownTradeModeError > for dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError) -> dpp :: errors :: consensus :: basic :: data_contract :: unknown_trade_mode_error :: UnknownTradeModeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: unknown_trade_mode_error :: UnknownTradeModeError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . allowed_values) , received : ffi_ref . received } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unknown_trade_mode_error :: UnknownTradeModeError > for dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: unknown_trade_mode_error :: UnknownTradeModeError) -> * const dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . allowed_values) , received : obj . received }) } } impl Drop for dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . allowed_values) ; ; } } } } pub mod unknown_transferable_type_error { use crate as example_platform ; # [doc = "FFI-representation of the [`UnknownTransferableTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError { pub allowed_values : * mut crate :: fermented :: generics :: Vec_u8 , pub received : u8 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unknown_transferable_type_error :: UnknownTransferableTypeError > for dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError) -> dpp :: errors :: consensus :: basic :: data_contract :: unknown_transferable_type_error :: UnknownTransferableTypeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: unknown_transferable_type_error :: UnknownTransferableTypeError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . allowed_values) , received : ffi_ref . received } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unknown_transferable_type_error :: UnknownTransferableTypeError > for dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: unknown_transferable_type_error :: UnknownTransferableTypeError) -> * const dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . allowed_values) , received : obj . received }) } } impl Drop for dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . allowed_values) ; ; } } } } } pub mod decode { pub mod decoding_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DecodingError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_decode_decoding_error_DecodingError { pub error : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: decode :: decoding_error :: DecodingError > for dpp_errors_consensus_basic_decode_decoding_error_DecodingError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_decode_decoding_error_DecodingError) -> dpp :: errors :: consensus :: basic :: decode :: decoding_error :: DecodingError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: decode :: decoding_error :: DecodingError { error : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . error) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: decode :: decoding_error :: DecodingError > for dpp_errors_consensus_basic_decode_decoding_error_DecodingError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: decode :: decoding_error :: DecodingError) -> * const dpp_errors_consensus_basic_decode_decoding_error_DecodingError { ferment :: boxed (dpp_errors_consensus_basic_decode_decoding_error_DecodingError { error : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . error) }) } } impl Drop for dpp_errors_consensus_basic_decode_decoding_error_DecodingError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . error) ; } } } } pub mod protocol_version_parsing_error { use crate as example_platform ; # [doc = "FFI-representation of the [`ProtocolVersionParsingError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError { pub parsing_error : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: decode :: protocol_version_parsing_error :: ProtocolVersionParsingError > for dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError) -> dpp :: errors :: consensus :: basic :: decode :: protocol_version_parsing_error :: ProtocolVersionParsingError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: decode :: protocol_version_parsing_error :: ProtocolVersionParsingError { parsing_error : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . parsing_error) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: decode :: protocol_version_parsing_error :: ProtocolVersionParsingError > for dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: decode :: protocol_version_parsing_error :: ProtocolVersionParsingError) -> * const dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError { ferment :: boxed (dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError { parsing_error : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . parsing_error) }) } } impl Drop for dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . parsing_error) ; } } } } pub mod serialized_object_parsing_error { use crate as example_platform ; # [doc = "FFI-representation of the [`SerializedObjectParsingError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError { pub parsing_error : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: decode :: serialized_object_parsing_error :: SerializedObjectParsingError > for dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError) -> dpp :: errors :: consensus :: basic :: decode :: serialized_object_parsing_error :: SerializedObjectParsingError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: decode :: serialized_object_parsing_error :: SerializedObjectParsingError { parsing_error : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . parsing_error) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: decode :: serialized_object_parsing_error :: SerializedObjectParsingError > for dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: decode :: serialized_object_parsing_error :: SerializedObjectParsingError) -> * const dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError { ferment :: boxed (dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError { parsing_error : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . parsing_error) }) } } impl Drop for dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . parsing_error) ; } } } } pub mod version_error { use crate as example_platform ; # [doc = "FFI-representation of the [`VersionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_decode_version_error_VersionError { pub error : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: decode :: version_error :: VersionError > for dpp_errors_consensus_basic_decode_version_error_VersionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_decode_version_error_VersionError) -> dpp :: errors :: consensus :: basic :: decode :: version_error :: VersionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: decode :: version_error :: VersionError { error : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . error) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: decode :: version_error :: VersionError > for dpp_errors_consensus_basic_decode_version_error_VersionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: decode :: version_error :: VersionError) -> * const dpp_errors_consensus_basic_decode_version_error_VersionError { ferment :: boxed (dpp_errors_consensus_basic_decode_version_error_VersionError { error : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . error) }) } } impl Drop for dpp_errors_consensus_basic_decode_version_error_VersionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . error) ; } } } } } pub mod document { pub mod contested_documents_temporarily_not_allowed_error { use crate as example_platform ; # [doc = "FFI-representation of the [`ContestedDocumentsTemporarilyNotAllowedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError { pub current_epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex , pub target_epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: contested_documents_temporarily_not_allowed_error :: ContestedDocumentsTemporarilyNotAllowedError > for dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError) -> dpp :: errors :: consensus :: basic :: document :: contested_documents_temporarily_not_allowed_error :: ContestedDocumentsTemporarilyNotAllowedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: contested_documents_temporarily_not_allowed_error :: ContestedDocumentsTemporarilyNotAllowedError { current_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionFrom < dpp :: block :: epoch :: EpochIndex >> :: ffi_from (ffi_ref . current_epoch) , target_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionFrom < dpp :: block :: epoch :: EpochIndex >> :: ffi_from (ffi_ref . target_epoch) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: contested_documents_temporarily_not_allowed_error :: ContestedDocumentsTemporarilyNotAllowedError > for dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: contested_documents_temporarily_not_allowed_error :: ContestedDocumentsTemporarilyNotAllowedError) -> * const dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError { ferment :: boxed (dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError { current_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionTo < dpp :: block :: epoch :: EpochIndex >> :: ffi_to (obj . current_epoch) , target_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionTo < dpp :: block :: epoch :: EpochIndex >> :: ffi_to (obj . target_epoch) }) } } impl Drop for dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . current_epoch) ; ferment :: unbox_any (ffi_ref . target_epoch) ; } } } } pub mod data_contract_not_present_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DataContractNotPresentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: data_contract_not_present_error :: DataContractNotPresentError > for dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError) -> dpp :: errors :: consensus :: basic :: document :: data_contract_not_present_error :: DataContractNotPresentError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: data_contract_not_present_error :: DataContractNotPresentError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: data_contract_not_present_error :: DataContractNotPresentError > for dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: data_contract_not_present_error :: DataContractNotPresentError) -> * const dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError { ferment :: boxed (dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) }) } } impl Drop for dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; } } } } pub mod document_creation_not_allowed_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DocumentCreationNotAllowedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub document_type_name : * mut std :: os :: raw :: c_char , pub creation_restriction_mode : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: document_creation_not_allowed_error :: DocumentCreationNotAllowedError > for dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError) -> dpp :: errors :: consensus :: basic :: document :: document_creation_not_allowed_error :: DocumentCreationNotAllowedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: document_creation_not_allowed_error :: DocumentCreationNotAllowedError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type_name) , creation_restriction_mode : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode >> :: ffi_from (ffi_ref . creation_restriction_mode) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: document_creation_not_allowed_error :: DocumentCreationNotAllowedError > for dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: document_creation_not_allowed_error :: DocumentCreationNotAllowedError) -> * const dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError { ferment :: boxed (dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type_name) , creation_restriction_mode : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode >> :: ffi_to (obj . creation_restriction_mode) }) } } impl Drop for dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_string (ffi_ref . document_type_name) ; ferment :: unbox_any (ffi_ref . creation_restriction_mode) ; } } } } pub mod document_field_max_size_exceeded_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DocumentFieldMaxSizeExceededError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError { pub field : * mut std :: os :: raw :: c_char , pub actual_size_bytes : u64 , pub max_size_bytes : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: document_field_max_size_exceeded_error :: DocumentFieldMaxSizeExceededError > for dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError) -> dpp :: errors :: consensus :: basic :: document :: document_field_max_size_exceeded_error :: DocumentFieldMaxSizeExceededError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: document_field_max_size_exceeded_error :: DocumentFieldMaxSizeExceededError { field : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . field) , actual_size_bytes : ffi_ref . actual_size_bytes , max_size_bytes : ffi_ref . max_size_bytes } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: document_field_max_size_exceeded_error :: DocumentFieldMaxSizeExceededError > for dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: document_field_max_size_exceeded_error :: DocumentFieldMaxSizeExceededError) -> * const dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError { ferment :: boxed (dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError { field : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . field) , actual_size_bytes : obj . actual_size_bytes , max_size_bytes : obj . max_size_bytes }) } } impl Drop for dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . field) ; ; ; } } } } pub mod document_transitions_are_absent_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DocumentTransitionsAreAbsentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: document_transitions_are_absent_error :: DocumentTransitionsAreAbsentError > for dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError) -> dpp :: errors :: consensus :: basic :: document :: document_transitions_are_absent_error :: DocumentTransitionsAreAbsentError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: document_transitions_are_absent_error :: DocumentTransitionsAreAbsentError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: document_transitions_are_absent_error :: DocumentTransitionsAreAbsentError > for dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: document_transitions_are_absent_error :: DocumentTransitionsAreAbsentError) -> * const dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError { ferment :: boxed (dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError { }) } } } pub mod duplicate_document_transitions_with_ids_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DuplicateDocumentTransitionsWithIdsError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError { pub references : * mut crate :: fermented :: generics :: Vec_Tuple_String_Arr_u8_32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_ids_error :: DuplicateDocumentTransitionsWithIdsError > for dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError) -> dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_ids_error :: DuplicateDocumentTransitionsWithIdsError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_ids_error :: DuplicateDocumentTransitionsWithIdsError { references : < crate :: fermented :: generics :: Vec_Tuple_String_Arr_u8_32 as ferment :: FFIConversionFrom < Vec < (String , [u8 ; 32]) > >> :: ffi_from (ffi_ref . references) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_ids_error :: DuplicateDocumentTransitionsWithIdsError > for dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_ids_error :: DuplicateDocumentTransitionsWithIdsError) -> * const dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError { ferment :: boxed (dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError { references : < crate :: fermented :: generics :: Vec_Tuple_String_Arr_u8_32 as ferment :: FFIConversionTo < Vec < (String , [u8 ; 32]) > >> :: ffi_to (obj . references) }) } } impl Drop for dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . references) ; } } } } pub mod duplicate_document_transitions_with_indices_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DuplicateDocumentTransitionsWithIndicesError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError { pub references : * mut crate :: fermented :: generics :: Vec_Tuple_String_Arr_u8_32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_indices_error :: DuplicateDocumentTransitionsWithIndicesError > for dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError) -> dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_indices_error :: DuplicateDocumentTransitionsWithIndicesError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_indices_error :: DuplicateDocumentTransitionsWithIndicesError { references : < crate :: fermented :: generics :: Vec_Tuple_String_Arr_u8_32 as ferment :: FFIConversionFrom < Vec < (String , [u8 ; 32]) > >> :: ffi_from (ffi_ref . references) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_indices_error :: DuplicateDocumentTransitionsWithIndicesError > for dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_indices_error :: DuplicateDocumentTransitionsWithIndicesError) -> * const dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError { ferment :: boxed (dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError { references : < crate :: fermented :: generics :: Vec_Tuple_String_Arr_u8_32 as ferment :: FFIConversionTo < Vec < (String , [u8 ; 32]) > >> :: ffi_to (obj . references) }) } } impl Drop for dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . references) ; } } } } pub mod identity_contract_nonce_out_of_bounds_error { use crate as example_platform ; # [doc = "FFI-representation of the [`NonceOutOfBoundsError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError { pub nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: identity_contract_nonce_out_of_bounds_error :: NonceOutOfBoundsError > for dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError) -> dpp :: errors :: consensus :: basic :: document :: identity_contract_nonce_out_of_bounds_error :: NonceOutOfBoundsError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: identity_contract_nonce_out_of_bounds_error :: NonceOutOfBoundsError { nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . nonce) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: identity_contract_nonce_out_of_bounds_error :: NonceOutOfBoundsError > for dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: identity_contract_nonce_out_of_bounds_error :: NonceOutOfBoundsError) -> * const dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError { ferment :: boxed (dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError { nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . nonce) }) } } impl Drop for dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . nonce) ; } } } } pub mod inconsistent_compound_index_data_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InconsistentCompoundIndexDataError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError { pub document_type : * mut std :: os :: raw :: c_char , pub index_properties : * mut crate :: fermented :: generics :: Vec_String } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: inconsistent_compound_index_data_error :: InconsistentCompoundIndexDataError > for dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError) -> dpp :: errors :: consensus :: basic :: document :: inconsistent_compound_index_data_error :: InconsistentCompoundIndexDataError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: inconsistent_compound_index_data_error :: InconsistentCompoundIndexDataError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_properties : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionFrom < Vec < String > >> :: ffi_from (ffi_ref . index_properties) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: inconsistent_compound_index_data_error :: InconsistentCompoundIndexDataError > for dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: inconsistent_compound_index_data_error :: InconsistentCompoundIndexDataError) -> * const dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError { ferment :: boxed (dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_properties : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionTo < Vec < String > >> :: ffi_to (obj . index_properties) }) } } impl Drop for dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_any (ffi_ref . index_properties) ; } } } } pub mod invalid_document_transition_action_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidDocumentTransitionActionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError { pub action : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_action_error :: InvalidDocumentTransitionActionError > for dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError) -> dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_action_error :: InvalidDocumentTransitionActionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_action_error :: InvalidDocumentTransitionActionError { action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_action_error :: InvalidDocumentTransitionActionError > for dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_action_error :: InvalidDocumentTransitionActionError) -> * const dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError { ferment :: boxed (dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError { action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) }) } } impl Drop for dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . action) ; } } } } pub mod invalid_document_transition_id_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidDocumentTransitionIdError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError { pub expected_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub invalid_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_id_error :: InvalidDocumentTransitionIdError > for dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError) -> dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_id_error :: InvalidDocumentTransitionIdError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_id_error :: InvalidDocumentTransitionIdError { expected_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . expected_id) , invalid_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . invalid_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_id_error :: InvalidDocumentTransitionIdError > for dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_id_error :: InvalidDocumentTransitionIdError) -> * const dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError { ferment :: boxed (dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError { expected_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . expected_id) , invalid_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . invalid_id) }) } } impl Drop for dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . expected_id) ; ferment :: unbox_any (ffi_ref . invalid_id) ; } } } } pub mod invalid_document_type_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidDocumentTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError { pub document_type : * mut std :: os :: raw :: c_char , pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: invalid_document_type_error :: InvalidDocumentTypeError > for dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError) -> dpp :: errors :: consensus :: basic :: document :: invalid_document_type_error :: InvalidDocumentTypeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: invalid_document_type_error :: InvalidDocumentTypeError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: invalid_document_type_error :: InvalidDocumentTypeError > for dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: invalid_document_type_error :: InvalidDocumentTypeError) -> * const dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError { ferment :: boxed (dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) }) } } impl Drop for dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_any (ffi_ref . data_contract_id) ; } } } } pub mod max_documents_transitions_exceeded_error { use crate as example_platform ; # [doc = "FFI-representation of the [`MaxDocumentsTransitionsExceededError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError { pub max_transitions : u16 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: max_documents_transitions_exceeded_error :: MaxDocumentsTransitionsExceededError > for dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError) -> dpp :: errors :: consensus :: basic :: document :: max_documents_transitions_exceeded_error :: MaxDocumentsTransitionsExceededError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: max_documents_transitions_exceeded_error :: MaxDocumentsTransitionsExceededError { max_transitions : ffi_ref . max_transitions } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: max_documents_transitions_exceeded_error :: MaxDocumentsTransitionsExceededError > for dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: max_documents_transitions_exceeded_error :: MaxDocumentsTransitionsExceededError) -> * const dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError { ferment :: boxed (dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError { max_transitions : obj . max_transitions }) } } } pub mod missing_data_contract_id_basic_error { use crate as example_platform ; # [doc = "FFI-representation of the [`MissingDataContractIdBasicError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: missing_data_contract_id_basic_error :: MissingDataContractIdBasicError > for dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError) -> dpp :: errors :: consensus :: basic :: document :: missing_data_contract_id_basic_error :: MissingDataContractIdBasicError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: missing_data_contract_id_basic_error :: MissingDataContractIdBasicError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: missing_data_contract_id_basic_error :: MissingDataContractIdBasicError > for dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: missing_data_contract_id_basic_error :: MissingDataContractIdBasicError) -> * const dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError { ferment :: boxed (dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError { }) } } } pub mod missing_document_transition_action_error { use crate as example_platform ; # [doc = "FFI-representation of the [`MissingDocumentTransitionActionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: missing_document_transition_action_error :: MissingDocumentTransitionActionError > for dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError) -> dpp :: errors :: consensus :: basic :: document :: missing_document_transition_action_error :: MissingDocumentTransitionActionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: missing_document_transition_action_error :: MissingDocumentTransitionActionError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: missing_document_transition_action_error :: MissingDocumentTransitionActionError > for dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: missing_document_transition_action_error :: MissingDocumentTransitionActionError) -> * const dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError { ferment :: boxed (dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError { }) } } } pub mod missing_document_transition_type_error { use crate as example_platform ; # [doc = "FFI-representation of the [`MissingDocumentTransitionTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: missing_document_transition_type_error :: MissingDocumentTransitionTypeError > for dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError) -> dpp :: errors :: consensus :: basic :: document :: missing_document_transition_type_error :: MissingDocumentTransitionTypeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: missing_document_transition_type_error :: MissingDocumentTransitionTypeError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: missing_document_transition_type_error :: MissingDocumentTransitionTypeError > for dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: missing_document_transition_type_error :: MissingDocumentTransitionTypeError) -> * const dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError { ferment :: boxed (dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError { }) } } } pub mod missing_document_type_error { use crate as example_platform ; # [doc = "FFI-representation of the [`MissingDocumentTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: missing_document_type_error :: MissingDocumentTypeError > for dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError) -> dpp :: errors :: consensus :: basic :: document :: missing_document_type_error :: MissingDocumentTypeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: missing_document_type_error :: MissingDocumentTypeError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: missing_document_type_error :: MissingDocumentTypeError > for dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: missing_document_type_error :: MissingDocumentTypeError) -> * const dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError { ferment :: boxed (dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError { }) } } } pub mod missing_positions_in_document_type_properties_error { use crate as example_platform ; # [doc = "FFI-representation of the [`MissingPositionsInDocumentTypePropertiesError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError { pub missing_position : u32 , pub contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub document_type_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: missing_positions_in_document_type_properties_error :: MissingPositionsInDocumentTypePropertiesError > for dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError) -> dpp :: errors :: consensus :: basic :: document :: missing_positions_in_document_type_properties_error :: MissingPositionsInDocumentTypePropertiesError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: missing_positions_in_document_type_properties_error :: MissingPositionsInDocumentTypePropertiesError { missing_position : ffi_ref . missing_position , contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . contract_id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: missing_positions_in_document_type_properties_error :: MissingPositionsInDocumentTypePropertiesError > for dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: missing_positions_in_document_type_properties_error :: MissingPositionsInDocumentTypePropertiesError) -> * const dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError { ferment :: boxed (dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError { missing_position : obj . missing_position , contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . contract_id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type_name) }) } } impl Drop for dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . contract_id) ; ferment :: unbox_string (ffi_ref . document_type_name) ; } } } } } pub mod identity { pub mod data_contract_bounds_not_present_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DataContractBoundsNotPresentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: data_contract_bounds_not_present_error :: DataContractBoundsNotPresentError > for dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError) -> dpp :: errors :: consensus :: basic :: identity :: data_contract_bounds_not_present_error :: DataContractBoundsNotPresentError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: data_contract_bounds_not_present_error :: DataContractBoundsNotPresentError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: data_contract_bounds_not_present_error :: DataContractBoundsNotPresentError > for dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: data_contract_bounds_not_present_error :: DataContractBoundsNotPresentError) -> * const dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError { ferment :: boxed (dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) }) } } impl Drop for dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; } } } } pub mod disabling_key_id_also_being_added_in_same_transition_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DisablingKeyIdAlsoBeingAddedInSameTransitionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError { pub key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: disabling_key_id_also_being_added_in_same_transition_error :: DisablingKeyIdAlsoBeingAddedInSameTransitionError > for dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError) -> dpp :: errors :: consensus :: basic :: identity :: disabling_key_id_also_being_added_in_same_transition_error :: DisablingKeyIdAlsoBeingAddedInSameTransitionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: disabling_key_id_also_being_added_in_same_transition_error :: DisablingKeyIdAlsoBeingAddedInSameTransitionError { key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . key_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: disabling_key_id_also_being_added_in_same_transition_error :: DisablingKeyIdAlsoBeingAddedInSameTransitionError > for dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: disabling_key_id_also_being_added_in_same_transition_error :: DisablingKeyIdAlsoBeingAddedInSameTransitionError) -> * const dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError { ferment :: boxed (dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError { key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . key_id) }) } } impl Drop for dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . key_id) ; } } } } pub mod duplicated_identity_public_key_basic_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DuplicatedIdentityPublicKeyBasicError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError { pub duplicated_ids : * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_basic_error :: DuplicatedIdentityPublicKeyBasicError > for dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError) -> dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_basic_error :: DuplicatedIdentityPublicKeyBasicError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_basic_error :: DuplicatedIdentityPublicKeyBasicError { duplicated_ids : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < Vec < dpp :: identity :: identity_public_key :: KeyID > >> :: ffi_from (ffi_ref . duplicated_ids) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_basic_error :: DuplicatedIdentityPublicKeyBasicError > for dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_basic_error :: DuplicatedIdentityPublicKeyBasicError) -> * const dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError { ferment :: boxed (dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError { duplicated_ids : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < Vec < dpp :: identity :: identity_public_key :: KeyID > >> :: ffi_to (obj . duplicated_ids) }) } } impl Drop for dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . duplicated_ids) ; } } } } pub mod duplicated_identity_public_key_id_basic_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DuplicatedIdentityPublicKeyIdBasicError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError { pub duplicated_ids : * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_id_basic_error :: DuplicatedIdentityPublicKeyIdBasicError > for dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError) -> dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_id_basic_error :: DuplicatedIdentityPublicKeyIdBasicError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_id_basic_error :: DuplicatedIdentityPublicKeyIdBasicError { duplicated_ids : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < Vec < dpp :: identity :: identity_public_key :: KeyID > >> :: ffi_from (ffi_ref . duplicated_ids) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_id_basic_error :: DuplicatedIdentityPublicKeyIdBasicError > for dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_id_basic_error :: DuplicatedIdentityPublicKeyIdBasicError) -> * const dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError { ferment :: boxed (dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError { duplicated_ids : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < Vec < dpp :: identity :: identity_public_key :: KeyID > >> :: ffi_to (obj . duplicated_ids) }) } } impl Drop for dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . duplicated_ids) ; } } } } pub mod identity_asset_lock_proof_locked_transaction_mismatch_error { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityAssetLockProofLockedTransactionMismatchError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError { pub instant_lock_transaction_id : * mut dashcore :: hash_types :: Txid , pub asset_lock_transaction_id : * mut dashcore :: hash_types :: Txid } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_proof_locked_transaction_mismatch_error :: IdentityAssetLockProofLockedTransactionMismatchError > for dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError) -> dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_proof_locked_transaction_mismatch_error :: IdentityAssetLockProofLockedTransactionMismatchError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_proof_locked_transaction_mismatch_error :: IdentityAssetLockProofLockedTransactionMismatchError { instant_lock_transaction_id : std :: ptr :: read (ffi_ref . instant_lock_transaction_id) , asset_lock_transaction_id : std :: ptr :: read (ffi_ref . asset_lock_transaction_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_proof_locked_transaction_mismatch_error :: IdentityAssetLockProofLockedTransactionMismatchError > for dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_proof_locked_transaction_mismatch_error :: IdentityAssetLockProofLockedTransactionMismatchError) -> * const dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError { instant_lock_transaction_id : ferment :: boxed (obj . instant_lock_transaction_id) , asset_lock_transaction_id : ferment :: boxed (obj . asset_lock_transaction_id) }) } } impl Drop for dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . instant_lock_transaction_id) ; ferment :: unbox_any (ffi_ref . asset_lock_transaction_id) ; } } } } pub mod identity_asset_lock_transaction_is_not_found_error { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityAssetLockTransactionIsNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError { pub transaction_id : * mut crate :: fermented :: generics :: Arr_u8_32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_is_not_found_error :: IdentityAssetLockTransactionIsNotFoundError > for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError) -> dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_is_not_found_error :: IdentityAssetLockTransactionIsNotFoundError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_is_not_found_error :: IdentityAssetLockTransactionIsNotFoundError { transaction_id : < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (ffi_ref . transaction_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_is_not_found_error :: IdentityAssetLockTransactionIsNotFoundError > for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_is_not_found_error :: IdentityAssetLockTransactionIsNotFoundError) -> * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError { transaction_id : < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (obj . transaction_id) }) } } impl Drop for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . transaction_id) ; } } } } pub mod identity_asset_lock_transaction_out_point_already_consumed_error { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityAssetLockTransactionOutPointAlreadyConsumedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError { pub transaction_id : * mut dashcore :: hash_types :: Txid , pub output_index : usize } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_already_consumed_error :: IdentityAssetLockTransactionOutPointAlreadyConsumedError > for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError) -> dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_already_consumed_error :: IdentityAssetLockTransactionOutPointAlreadyConsumedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_already_consumed_error :: IdentityAssetLockTransactionOutPointAlreadyConsumedError { transaction_id : std :: ptr :: read (ffi_ref . transaction_id) , output_index : ffi_ref . output_index } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_already_consumed_error :: IdentityAssetLockTransactionOutPointAlreadyConsumedError > for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_already_consumed_error :: IdentityAssetLockTransactionOutPointAlreadyConsumedError) -> * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError { transaction_id : ferment :: boxed (obj . transaction_id) , output_index : obj . output_index }) } } impl Drop for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . transaction_id) ; ; } } } } pub mod identity_asset_lock_state_transition_replay_error { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityAssetLockStateTransitionReplayError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError { pub transaction_id : * mut dashcore :: hash_types :: Txid , pub output_index : usize , pub state_transition_id : * mut crate :: fermented :: types :: platform_value :: types :: bytes_32 :: platform_value_types_bytes_32_Bytes32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_state_transition_replay_error :: IdentityAssetLockStateTransitionReplayError > for dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError) -> dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_state_transition_replay_error :: IdentityAssetLockStateTransitionReplayError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_state_transition_replay_error :: IdentityAssetLockStateTransitionReplayError { transaction_id : std :: ptr :: read (ffi_ref . transaction_id) , output_index : ffi_ref . output_index , state_transition_id : < crate :: fermented :: types :: platform_value :: types :: bytes_32 :: platform_value_types_bytes_32_Bytes32 as ferment :: FFIConversionFrom < platform_value :: types :: bytes_32 :: Bytes32 >> :: ffi_from (ffi_ref . state_transition_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_state_transition_replay_error :: IdentityAssetLockStateTransitionReplayError > for dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_state_transition_replay_error :: IdentityAssetLockStateTransitionReplayError) -> * const dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError { transaction_id : ferment :: boxed (obj . transaction_id) , output_index : obj . output_index , state_transition_id : < crate :: fermented :: types :: platform_value :: types :: bytes_32 :: platform_value_types_bytes_32_Bytes32 as ferment :: FFIConversionTo < platform_value :: types :: bytes_32 :: Bytes32 >> :: ffi_to (obj . state_transition_id) }) } } impl Drop for dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . transaction_id) ; ; ferment :: unbox_any (ffi_ref . state_transition_id) ; } } } } pub mod identity_asset_lock_transaction_out_point_not_enough_balance_error { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityAssetLockTransactionOutPointNotEnoughBalanceError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError { pub transaction_id : * mut dashcore :: hash_types :: Txid , pub output_index : usize , pub initial_asset_lock_credits : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , pub credits_left : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , pub credits_required : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_not_enough_balance_error :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError > for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError) -> dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_not_enough_balance_error :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_not_enough_balance_error :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError { transaction_id : std :: ptr :: read (ffi_ref . transaction_id) , output_index : ffi_ref . output_index , initial_asset_lock_credits : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . initial_asset_lock_credits) , credits_left : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . credits_left) , credits_required : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . credits_required) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_not_enough_balance_error :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError > for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_not_enough_balance_error :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError) -> * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError { transaction_id : ferment :: boxed (obj . transaction_id) , output_index : obj . output_index , initial_asset_lock_credits : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . initial_asset_lock_credits) , credits_left : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . credits_left) , credits_required : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . credits_required) }) } } impl Drop for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . transaction_id) ; ; ferment :: unbox_any (ffi_ref . initial_asset_lock_credits) ; ferment :: unbox_any (ffi_ref . credits_left) ; ferment :: unbox_any (ffi_ref . credits_required) ; } } } } pub mod identity_asset_lock_transaction_output_not_found_error { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityAssetLockTransactionOutputNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError { pub output_index : usize } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_output_not_found_error :: IdentityAssetLockTransactionOutputNotFoundError > for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError) -> dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_output_not_found_error :: IdentityAssetLockTransactionOutputNotFoundError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_output_not_found_error :: IdentityAssetLockTransactionOutputNotFoundError { output_index : ffi_ref . output_index } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_output_not_found_error :: IdentityAssetLockTransactionOutputNotFoundError > for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_output_not_found_error :: IdentityAssetLockTransactionOutputNotFoundError) -> * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError { output_index : obj . output_index }) } } } pub mod identity_credit_transfer_to_self_error { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityCreditTransferToSelfError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_credit_transfer_to_self_error :: IdentityCreditTransferToSelfError > for dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError) -> dpp :: errors :: consensus :: basic :: identity :: identity_credit_transfer_to_self_error :: IdentityCreditTransferToSelfError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: identity_credit_transfer_to_self_error :: IdentityCreditTransferToSelfError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_credit_transfer_to_self_error :: IdentityCreditTransferToSelfError > for dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: identity_credit_transfer_to_self_error :: IdentityCreditTransferToSelfError) -> * const dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError { }) } } } pub mod invalid_asset_lock_proof_core_chain_height_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidAssetLockProofCoreChainHeightError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError { pub proof_core_chain_locked_height : u32 , pub current_core_chain_locked_height : u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_core_chain_height_error :: InvalidAssetLockProofCoreChainHeightError > for dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_core_chain_height_error :: InvalidAssetLockProofCoreChainHeightError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_core_chain_height_error :: InvalidAssetLockProofCoreChainHeightError { proof_core_chain_locked_height : ffi_ref . proof_core_chain_locked_height , current_core_chain_locked_height : ffi_ref . current_core_chain_locked_height } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_core_chain_height_error :: InvalidAssetLockProofCoreChainHeightError > for dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_core_chain_height_error :: InvalidAssetLockProofCoreChainHeightError) -> * const dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError { proof_core_chain_locked_height : obj . proof_core_chain_locked_height , current_core_chain_locked_height : obj . current_core_chain_locked_height }) } } } pub mod invalid_asset_lock_proof_transaction_height_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidAssetLockProofTransactionHeightError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError { pub proof_core_chain_locked_height : u32 , pub transaction_height : * mut u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_transaction_height_error :: InvalidAssetLockProofTransactionHeightError > for dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_transaction_height_error :: InvalidAssetLockProofTransactionHeightError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_transaction_height_error :: InvalidAssetLockProofTransactionHeightError { proof_core_chain_locked_height : ffi_ref . proof_core_chain_locked_height , transaction_height : ferment :: from_opt_primitive (ffi_ref . transaction_height) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_transaction_height_error :: InvalidAssetLockProofTransactionHeightError > for dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_transaction_height_error :: InvalidAssetLockProofTransactionHeightError) -> * const dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError { proof_core_chain_locked_height : obj . proof_core_chain_locked_height , transaction_height : ferment :: to_opt_primitive (obj . transaction_height) }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any_opt (ffi_ref . transaction_height) ; } } } } pub mod invalid_asset_lock_transaction_output_return_size { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidAssetLockTransactionOutputReturnSizeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError { pub output_index : usize } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_transaction_output_return_size :: InvalidAssetLockTransactionOutputReturnSizeError > for dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_transaction_output_return_size :: InvalidAssetLockTransactionOutputReturnSizeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_transaction_output_return_size :: InvalidAssetLockTransactionOutputReturnSizeError { output_index : ffi_ref . output_index } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_transaction_output_return_size :: InvalidAssetLockTransactionOutputReturnSizeError > for dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_transaction_output_return_size :: InvalidAssetLockTransactionOutputReturnSizeError) -> * const dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError { output_index : obj . output_index }) } } } pub mod invalid_identity_asset_lock_proof_chain_lock_validation_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidIdentityAssetLockProofChainLockValidationError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError { pub transaction_id : * mut dashcore :: hash_types :: Txid , pub height_reported_not_locked : u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_proof_chain_lock_validation_error :: InvalidIdentityAssetLockProofChainLockValidationError > for dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_proof_chain_lock_validation_error :: InvalidIdentityAssetLockProofChainLockValidationError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_proof_chain_lock_validation_error :: InvalidIdentityAssetLockProofChainLockValidationError { transaction_id : std :: ptr :: read (ffi_ref . transaction_id) , height_reported_not_locked : ffi_ref . height_reported_not_locked } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_proof_chain_lock_validation_error :: InvalidIdentityAssetLockProofChainLockValidationError > for dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_proof_chain_lock_validation_error :: InvalidIdentityAssetLockProofChainLockValidationError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError { transaction_id : ferment :: boxed (obj . transaction_id) , height_reported_not_locked : obj . height_reported_not_locked }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . transaction_id) ; ; } } } } pub mod invalid_identity_asset_lock_transaction_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidIdentityAssetLockTransactionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_error :: InvalidIdentityAssetLockTransactionError > for dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_error :: InvalidIdentityAssetLockTransactionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_error :: InvalidIdentityAssetLockTransactionError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_error :: InvalidIdentityAssetLockTransactionError > for dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_error :: InvalidIdentityAssetLockTransactionError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } } pub mod invalid_identity_asset_lock_transaction_output_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidIdentityAssetLockTransactionOutputError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError { pub output_index : usize } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_output_error :: InvalidIdentityAssetLockTransactionOutputError > for dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_output_error :: InvalidIdentityAssetLockTransactionOutputError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_output_error :: InvalidIdentityAssetLockTransactionOutputError { output_index : ffi_ref . output_index } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_output_error :: InvalidIdentityAssetLockTransactionOutputError > for dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_output_error :: InvalidIdentityAssetLockTransactionOutputError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError { output_index : obj . output_index }) } } } pub mod invalid_identity_credit_transfer_amount_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidIdentityCreditTransferAmountError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError { pub amount : u64 , pub min_amount : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_transfer_amount_error :: InvalidIdentityCreditTransferAmountError > for dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_transfer_amount_error :: InvalidIdentityCreditTransferAmountError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_transfer_amount_error :: InvalidIdentityCreditTransferAmountError { amount : ffi_ref . amount , min_amount : ffi_ref . min_amount } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_transfer_amount_error :: InvalidIdentityCreditTransferAmountError > for dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_transfer_amount_error :: InvalidIdentityCreditTransferAmountError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError { amount : obj . amount , min_amount : obj . min_amount }) } } } pub mod invalid_identity_credit_withdrawal_transition_amount_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidIdentityCreditWithdrawalTransitionAmountError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError { pub amount : u64 , pub min_amount : u64 , pub max_amount : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_amount_error :: InvalidIdentityCreditWithdrawalTransitionAmountError > for dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_amount_error :: InvalidIdentityCreditWithdrawalTransitionAmountError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_amount_error :: InvalidIdentityCreditWithdrawalTransitionAmountError { amount : ffi_ref . amount , min_amount : ffi_ref . min_amount , max_amount : ffi_ref . max_amount } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_amount_error :: InvalidIdentityCreditWithdrawalTransitionAmountError > for dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_amount_error :: InvalidIdentityCreditWithdrawalTransitionAmountError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError { amount : obj . amount , min_amount : obj . min_amount , max_amount : obj . max_amount }) } } } pub mod invalid_identity_credit_withdrawal_transition_core_fee_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidIdentityCreditWithdrawalTransitionCoreFeeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError { pub core_fee_per_byte : u32 , pub min_core_fee_per_byte : u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_core_fee_error :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError > for dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_core_fee_error :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_core_fee_error :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError { core_fee_per_byte : ffi_ref . core_fee_per_byte , min_core_fee_per_byte : ffi_ref . min_core_fee_per_byte } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_core_fee_error :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError > for dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_core_fee_error :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError { core_fee_per_byte : obj . core_fee_per_byte , min_core_fee_per_byte : obj . min_core_fee_per_byte }) } } } pub mod invalid_identity_credit_withdrawal_transition_output_script_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidIdentityCreditWithdrawalTransitionOutputScriptError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError { pub output_script : * mut example_platform :: custom :: dpp :: CoreScriptFFI } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_output_script_error :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError > for dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_output_script_error :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_output_script_error :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError { output_script : < example_platform :: custom :: dpp :: CoreScriptFFI as ferment :: FFIConversionFrom < dpp :: identity :: core_script :: CoreScript >> :: ffi_from (ffi_ref . output_script) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_output_script_error :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError > for dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_output_script_error :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError { output_script : < example_platform :: custom :: dpp :: CoreScriptFFI as ferment :: FFIConversionTo < dpp :: identity :: core_script :: CoreScript >> :: ffi_to (obj . output_script) }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . output_script) ; } } } } pub mod invalid_identity_key_signature_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidIdentityKeySignatureError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError { pub public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_key_signature_error :: InvalidIdentityKeySignatureError > for dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_key_signature_error :: InvalidIdentityKeySignatureError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_key_signature_error :: InvalidIdentityKeySignatureError { public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . public_key_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_key_signature_error :: InvalidIdentityKeySignatureError > for dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_key_signature_error :: InvalidIdentityKeySignatureError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError { public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . public_key_id) }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_id) ; } } } } pub mod invalid_identity_public_key_data_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidIdentityPublicKeyDataError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError { pub public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , pub validation_error : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_data_error :: InvalidIdentityPublicKeyDataError > for dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_data_error :: InvalidIdentityPublicKeyDataError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_data_error :: InvalidIdentityPublicKeyDataError { public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . public_key_id) , validation_error : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . validation_error) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_data_error :: InvalidIdentityPublicKeyDataError > for dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_data_error :: InvalidIdentityPublicKeyDataError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError { public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . public_key_id) , validation_error : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . validation_error) }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_id) ; ferment :: unbox_string (ffi_ref . validation_error) ; } } } } pub mod invalid_identity_public_key_security_level_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidIdentityPublicKeySecurityLevelError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError { pub public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , pub purpose : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose , pub security_level : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel , pub allowed_security_levels : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_security_level_error :: InvalidIdentityPublicKeySecurityLevelError > for dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_security_level_error :: InvalidIdentityPublicKeySecurityLevelError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_security_level_error :: InvalidIdentityPublicKeySecurityLevelError { public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . public_key_id) , purpose : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: purpose :: Purpose >> :: ffi_from (ffi_ref . purpose) , security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_from (ffi_ref . security_level) , allowed_security_levels : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . allowed_security_levels) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_security_level_error :: InvalidIdentityPublicKeySecurityLevelError > for dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_security_level_error :: InvalidIdentityPublicKeySecurityLevelError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError { public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . public_key_id) , purpose : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: purpose :: Purpose >> :: ffi_to (obj . purpose) , security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_to (obj . security_level) , allowed_security_levels : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . allowed_security_levels) }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_id) ; ferment :: unbox_any (ffi_ref . purpose) ; ferment :: unbox_any (ffi_ref . security_level) ; ferment :: unbox_string (ffi_ref . allowed_security_levels) ; } } } } pub mod invalid_identity_update_transition_disable_keys_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidIdentityUpdateTransitionDisableKeysError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_disable_keys_error :: InvalidIdentityUpdateTransitionDisableKeysError > for dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_disable_keys_error :: InvalidIdentityUpdateTransitionDisableKeysError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_disable_keys_error :: InvalidIdentityUpdateTransitionDisableKeysError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_disable_keys_error :: InvalidIdentityUpdateTransitionDisableKeysError > for dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_disable_keys_error :: InvalidIdentityUpdateTransitionDisableKeysError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError { }) } } } pub mod invalid_identity_update_transition_empty_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidIdentityUpdateTransitionEmptyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_empty_error :: InvalidIdentityUpdateTransitionEmptyError > for dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_empty_error :: InvalidIdentityUpdateTransitionEmptyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_empty_error :: InvalidIdentityUpdateTransitionEmptyError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_empty_error :: InvalidIdentityUpdateTransitionEmptyError > for dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_empty_error :: InvalidIdentityUpdateTransitionEmptyError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError { }) } } } pub mod invalid_instant_asset_lock_proof_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidInstantAssetLockProofError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_error :: InvalidInstantAssetLockProofError > for dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_error :: InvalidInstantAssetLockProofError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_error :: InvalidInstantAssetLockProofError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_error :: InvalidInstantAssetLockProofError > for dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_error :: InvalidInstantAssetLockProofError) -> * const dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } } pub mod invalid_instant_asset_lock_proof_signature_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidInstantAssetLockProofSignatureError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_signature_error :: InvalidInstantAssetLockProofSignatureError > for dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_signature_error :: InvalidInstantAssetLockProofSignatureError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_signature_error :: InvalidInstantAssetLockProofSignatureError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_signature_error :: InvalidInstantAssetLockProofSignatureError > for dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_signature_error :: InvalidInstantAssetLockProofSignatureError) -> * const dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError { }) } } } pub mod missing_master_public_key_error { use crate as example_platform ; # [doc = "FFI-representation of the [`MissingMasterPublicKeyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: missing_master_public_key_error :: MissingMasterPublicKeyError > for dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError) -> dpp :: errors :: consensus :: basic :: identity :: missing_master_public_key_error :: MissingMasterPublicKeyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: missing_master_public_key_error :: MissingMasterPublicKeyError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: missing_master_public_key_error :: MissingMasterPublicKeyError > for dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: missing_master_public_key_error :: MissingMasterPublicKeyError) -> * const dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError { ferment :: boxed (dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError { }) } } } pub mod not_implemented_identity_credit_withdrawal_transition_pooling_error { use crate as example_platform ; # [doc = "FFI-representation of the [`NotImplementedIdentityCreditWithdrawalTransitionPoolingError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError { pub pooling : u8 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: not_implemented_identity_credit_withdrawal_transition_pooling_error :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError > for dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError) -> dpp :: errors :: consensus :: basic :: identity :: not_implemented_identity_credit_withdrawal_transition_pooling_error :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: not_implemented_identity_credit_withdrawal_transition_pooling_error :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError { pooling : ffi_ref . pooling } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: not_implemented_identity_credit_withdrawal_transition_pooling_error :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError > for dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: not_implemented_identity_credit_withdrawal_transition_pooling_error :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError) -> * const dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError { ferment :: boxed (dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError { pooling : obj . pooling }) } } } pub mod too_many_master_public_key_error { use crate as example_platform ; # [doc = "FFI-representation of the [`TooManyMasterPublicKeyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: too_many_master_public_key_error :: TooManyMasterPublicKeyError > for dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError) -> dpp :: errors :: consensus :: basic :: identity :: too_many_master_public_key_error :: TooManyMasterPublicKeyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: too_many_master_public_key_error :: TooManyMasterPublicKeyError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: too_many_master_public_key_error :: TooManyMasterPublicKeyError > for dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: too_many_master_public_key_error :: TooManyMasterPublicKeyError) -> * const dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError { ferment :: boxed (dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError { }) } } } pub mod withdrawal_output_script_not_allowed_when_signing_with_owner_key { use crate as example_platform ; # [doc = "FFI-representation of the [`WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError { pub output_script : * mut example_platform :: custom :: dpp :: CoreScriptFFI , pub key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: withdrawal_output_script_not_allowed_when_signing_with_owner_key :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError > for dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError) -> dpp :: errors :: consensus :: basic :: identity :: withdrawal_output_script_not_allowed_when_signing_with_owner_key :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: withdrawal_output_script_not_allowed_when_signing_with_owner_key :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError { output_script : < example_platform :: custom :: dpp :: CoreScriptFFI as ferment :: FFIConversionFrom < dpp :: identity :: core_script :: CoreScript >> :: ffi_from (ffi_ref . output_script) , key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . key_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: withdrawal_output_script_not_allowed_when_signing_with_owner_key :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError > for dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: withdrawal_output_script_not_allowed_when_signing_with_owner_key :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError) -> * const dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError { ferment :: boxed (dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError { output_script : < example_platform :: custom :: dpp :: CoreScriptFFI as ferment :: FFIConversionTo < dpp :: identity :: core_script :: CoreScript >> :: ffi_to (obj . output_script) , key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . key_id) }) } } impl Drop for dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . output_script) ; ferment :: unbox_any (ffi_ref . key_id) ; } } } } } pub mod incompatible_protocol_version_error { use crate as example_platform ; # [doc = "FFI-representation of the [`IncompatibleProtocolVersionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError { pub parsed_protocol_version : u32 , pub minimal_protocol_version : u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: incompatible_protocol_version_error :: IncompatibleProtocolVersionError > for dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError) -> dpp :: errors :: consensus :: basic :: incompatible_protocol_version_error :: IncompatibleProtocolVersionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: incompatible_protocol_version_error :: IncompatibleProtocolVersionError { parsed_protocol_version : ffi_ref . parsed_protocol_version , minimal_protocol_version : ffi_ref . minimal_protocol_version } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: incompatible_protocol_version_error :: IncompatibleProtocolVersionError > for dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: incompatible_protocol_version_error :: IncompatibleProtocolVersionError) -> * const dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError { ferment :: boxed (dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError { parsed_protocol_version : obj . parsed_protocol_version , minimal_protocol_version : obj . minimal_protocol_version }) } } } pub mod token { pub mod choosing_token_mint_recipient_not_allowed_error { use crate as example_platform ; # [doc = "FFI-representation of the [`ChoosingTokenMintRecipientNotAllowedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: choosing_token_mint_recipient_not_allowed_error :: ChoosingTokenMintRecipientNotAllowedError > for dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError) -> dpp :: errors :: consensus :: basic :: token :: choosing_token_mint_recipient_not_allowed_error :: ChoosingTokenMintRecipientNotAllowedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: choosing_token_mint_recipient_not_allowed_error :: ChoosingTokenMintRecipientNotAllowedError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: choosing_token_mint_recipient_not_allowed_error :: ChoosingTokenMintRecipientNotAllowedError > for dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: choosing_token_mint_recipient_not_allowed_error :: ChoosingTokenMintRecipientNotAllowedError) -> * const dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError { ferment :: boxed (dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) }) } } impl Drop for dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; } } } } pub mod contract_has_no_tokens_error { use crate as example_platform ; # [doc = "FFI-representation of the [`ContractHasNoTokensError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError { pub contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: contract_has_no_tokens_error :: ContractHasNoTokensError > for dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError) -> dpp :: errors :: consensus :: basic :: token :: contract_has_no_tokens_error :: ContractHasNoTokensError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: contract_has_no_tokens_error :: ContractHasNoTokensError { contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . contract_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: contract_has_no_tokens_error :: ContractHasNoTokensError > for dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: contract_has_no_tokens_error :: ContractHasNoTokensError) -> * const dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError { ferment :: boxed (dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError { contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . contract_id) }) } } impl Drop for dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . contract_id) ; } } } } pub mod destination_identity_for_token_minting_not_set_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DestinationIdentityForTokenMintingNotSetError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: destination_identity_for_token_minting_not_set_error :: DestinationIdentityForTokenMintingNotSetError > for dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError) -> dpp :: errors :: consensus :: basic :: token :: destination_identity_for_token_minting_not_set_error :: DestinationIdentityForTokenMintingNotSetError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: destination_identity_for_token_minting_not_set_error :: DestinationIdentityForTokenMintingNotSetError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: destination_identity_for_token_minting_not_set_error :: DestinationIdentityForTokenMintingNotSetError > for dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: destination_identity_for_token_minting_not_set_error :: DestinationIdentityForTokenMintingNotSetError) -> * const dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError { ferment :: boxed (dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) }) } } impl Drop for dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; } } } } pub mod invalid_action_id_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidActionIdError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError { pub expected_action_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub invalid_action_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: invalid_action_id_error :: InvalidActionIdError > for dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError) -> dpp :: errors :: consensus :: basic :: token :: invalid_action_id_error :: InvalidActionIdError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: invalid_action_id_error :: InvalidActionIdError { expected_action_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . expected_action_id) , invalid_action_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . invalid_action_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: invalid_action_id_error :: InvalidActionIdError > for dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: invalid_action_id_error :: InvalidActionIdError) -> * const dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError { ferment :: boxed (dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError { expected_action_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . expected_action_id) , invalid_action_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . invalid_action_id) }) } } impl Drop for dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . expected_action_id) ; ferment :: unbox_any (ffi_ref . invalid_action_id) ; } } } } pub mod invalid_token_amount_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidTokenAmountError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError { pub max_token_amount : u64 , pub token_amount : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: invalid_token_amount_error :: InvalidTokenAmountError > for dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError) -> dpp :: errors :: consensus :: basic :: token :: invalid_token_amount_error :: InvalidTokenAmountError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: invalid_token_amount_error :: InvalidTokenAmountError { max_token_amount : ffi_ref . max_token_amount , token_amount : ffi_ref . token_amount } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: invalid_token_amount_error :: InvalidTokenAmountError > for dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: invalid_token_amount_error :: InvalidTokenAmountError) -> * const dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError { ferment :: boxed (dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError { max_token_amount : obj . max_token_amount , token_amount : obj . token_amount }) } } } pub mod invalid_token_config_update_no_change_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidTokenConfigUpdateNoChangeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: invalid_token_config_update_no_change_error :: InvalidTokenConfigUpdateNoChangeError > for dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError) -> dpp :: errors :: consensus :: basic :: token :: invalid_token_config_update_no_change_error :: InvalidTokenConfigUpdateNoChangeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: invalid_token_config_update_no_change_error :: InvalidTokenConfigUpdateNoChangeError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: invalid_token_config_update_no_change_error :: InvalidTokenConfigUpdateNoChangeError > for dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: invalid_token_config_update_no_change_error :: InvalidTokenConfigUpdateNoChangeError) -> * const dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError { ferment :: boxed (dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError { }) } } } pub mod invalid_token_id_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidTokenIdError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError { pub expected_token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub invalid_token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: invalid_token_id_error :: InvalidTokenIdError > for dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError) -> dpp :: errors :: consensus :: basic :: token :: invalid_token_id_error :: InvalidTokenIdError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: invalid_token_id_error :: InvalidTokenIdError { expected_token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . expected_token_id) , invalid_token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . invalid_token_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: invalid_token_id_error :: InvalidTokenIdError > for dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: invalid_token_id_error :: InvalidTokenIdError) -> * const dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError { ferment :: boxed (dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError { expected_token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . expected_token_id) , invalid_token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . invalid_token_id) }) } } impl Drop for dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . expected_token_id) ; ferment :: unbox_any (ffi_ref . invalid_token_id) ; } } } } pub mod invalid_token_note_too_big_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidTokenNoteTooBigError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError { pub max_note_length : u32 , pub note_type : * mut std :: os :: raw :: c_char , pub note_length : u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: invalid_token_note_too_big_error :: InvalidTokenNoteTooBigError > for dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError) -> dpp :: errors :: consensus :: basic :: token :: invalid_token_note_too_big_error :: InvalidTokenNoteTooBigError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: invalid_token_note_too_big_error :: InvalidTokenNoteTooBigError { max_note_length : ffi_ref . max_note_length , note_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . note_type) , note_length : ffi_ref . note_length } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: invalid_token_note_too_big_error :: InvalidTokenNoteTooBigError > for dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: invalid_token_note_too_big_error :: InvalidTokenNoteTooBigError) -> * const dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError { ferment :: boxed (dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError { max_note_length : obj . max_note_length , note_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . note_type) , note_length : obj . note_length }) } } impl Drop for dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_string (ffi_ref . note_type) ; ; } } } } pub mod invalid_token_position_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidTokenPositionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError { pub max_token_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , pub invalid_token_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: invalid_token_position_error :: InvalidTokenPositionError > for dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError) -> dpp :: errors :: consensus :: basic :: token :: invalid_token_position_error :: InvalidTokenPositionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: invalid_token_position_error :: InvalidTokenPositionError { max_token_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from_opt (ffi_ref . max_token_position) , invalid_token_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from (ffi_ref . invalid_token_position) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: invalid_token_position_error :: InvalidTokenPositionError > for dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: invalid_token_position_error :: InvalidTokenPositionError) -> * const dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError { ferment :: boxed (dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError { max_token_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition >> :: ffi_to_opt (obj . max_token_position) , invalid_token_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition >> :: ffi_to (obj . invalid_token_position) }) } } impl Drop for dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any_opt (ffi_ref . max_token_position) ; ferment :: unbox_any (ffi_ref . invalid_token_position) ; } } } } pub mod missing_default_localization { use crate as example_platform ; # [doc = "FFI-representation of the [`MissingDefaultLocalizationError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: missing_default_localization :: MissingDefaultLocalizationError > for dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError) -> dpp :: errors :: consensus :: basic :: token :: missing_default_localization :: MissingDefaultLocalizationError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: missing_default_localization :: MissingDefaultLocalizationError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: missing_default_localization :: MissingDefaultLocalizationError > for dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: missing_default_localization :: MissingDefaultLocalizationError) -> * const dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError { ferment :: boxed (dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError { }) } } } pub mod token_note_only_allowed_on_proposer_error { use crate as example_platform ; # [doc = "FFI-representation of the [`TokenNoteOnlyAllowedWhenProposerError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_token_note_only_allowed_on_proposer_error_TokenNoteOnlyAllowedWhenProposerError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: token_note_only_allowed_on_proposer_error :: TokenNoteOnlyAllowedWhenProposerError > for dpp_errors_consensus_basic_token_token_note_only_allowed_on_proposer_error_TokenNoteOnlyAllowedWhenProposerError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_token_note_only_allowed_on_proposer_error_TokenNoteOnlyAllowedWhenProposerError) -> dpp :: errors :: consensus :: basic :: token :: token_note_only_allowed_on_proposer_error :: TokenNoteOnlyAllowedWhenProposerError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: token_note_only_allowed_on_proposer_error :: TokenNoteOnlyAllowedWhenProposerError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: token_note_only_allowed_on_proposer_error :: TokenNoteOnlyAllowedWhenProposerError > for dpp_errors_consensus_basic_token_token_note_only_allowed_on_proposer_error_TokenNoteOnlyAllowedWhenProposerError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: token_note_only_allowed_on_proposer_error :: TokenNoteOnlyAllowedWhenProposerError) -> * const dpp_errors_consensus_basic_token_token_note_only_allowed_on_proposer_error_TokenNoteOnlyAllowedWhenProposerError { ferment :: boxed (dpp_errors_consensus_basic_token_token_note_only_allowed_on_proposer_error_TokenNoteOnlyAllowedWhenProposerError { }) } } } pub mod token_transfer_to_ourselves_error { use crate as example_platform ; # [doc = "FFI-representation of the [`TokenTransferToOurselfError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: token_transfer_to_ourselves_error :: TokenTransferToOurselfError > for dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError) -> dpp :: errors :: consensus :: basic :: token :: token_transfer_to_ourselves_error :: TokenTransferToOurselfError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: token_transfer_to_ourselves_error :: TokenTransferToOurselfError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: token_transfer_to_ourselves_error :: TokenTransferToOurselfError > for dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: token_transfer_to_ourselves_error :: TokenTransferToOurselfError) -> * const dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError { ferment :: boxed (dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) }) } } impl Drop for dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_any (ffi_ref . identity_id) ; } } } } } pub mod unsupported_protocol_version_error { use crate as example_platform ; # [doc = "FFI-representation of the [`UnsupportedProtocolVersionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError { pub parsed_protocol_version : u32 , pub latest_version : u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: unsupported_protocol_version_error :: UnsupportedProtocolVersionError > for dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError) -> dpp :: errors :: consensus :: basic :: unsupported_protocol_version_error :: UnsupportedProtocolVersionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: unsupported_protocol_version_error :: UnsupportedProtocolVersionError { parsed_protocol_version : ffi_ref . parsed_protocol_version , latest_version : ffi_ref . latest_version } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: unsupported_protocol_version_error :: UnsupportedProtocolVersionError > for dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: unsupported_protocol_version_error :: UnsupportedProtocolVersionError) -> * const dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError { ferment :: boxed (dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError { parsed_protocol_version : obj . parsed_protocol_version , latest_version : obj . latest_version }) } } } pub mod basic_error { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`BasicError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_errors_consensus_basic_basic_error_BasicError { ProtocolVersionParsingError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: protocol_version_parsing_error :: dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError) , VersionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: version_error :: dpp_errors_consensus_basic_decode_version_error_VersionError) , ContractError (* mut crate :: fermented :: types :: dpp :: data_contract :: errors :: contract :: dpp_data_contract_errors_contract_DataContractError) , UnknownSecurityLevelError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_security_level_error :: dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError) , UnknownStorageKeyRequirementsError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_storage_key_requirements_error :: dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError) , UnknownTransferableTypeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_transferable_type_error :: dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError) , UnknownTradeModeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_trade_mode_error :: dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError) , UnknownDocumentCreationRestrictionModeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_creation_restriction_mode_error :: dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError) , SerializedObjectParsingError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: serialized_object_parsing_error :: dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError) , UnsupportedProtocolVersionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: unsupported_protocol_version_error :: dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError) , UnsupportedVersionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: unsupported_version_error :: dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError) , IncompatibleProtocolVersionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: incompatible_protocol_version_error :: dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError) , JsonSchemaCompilationError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: json_schema_compilation_error :: dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError) , JsonSchemaError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: json_schema_error :: error :: dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError) , InvalidIdentifierError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: invalid_identifier_error :: dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError) , ValueError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: value_error :: dpp_errors_consensus_basic_value_error_ValueError) , DataContractMaxDepthExceedError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_max_depth_exceed_error :: dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError) , DuplicateIndexError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_error :: dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError) , IncompatibleRe2PatternError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: incompatible_re2_pattern_error :: dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError) , InvalidCompoundIndexError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_compound_index_error :: dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError) , InvalidDataContractIdError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_id_error :: dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError) , InvalidIndexedPropertyConstraintError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_indexed_property_constraint_error :: dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError) , InvalidIndexPropertyTypeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_index_property_type_error :: dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError) , InvalidJsonSchemaRefError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_json_schema_ref_error :: dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError) , SystemPropertyIndexAlreadyPresentError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: system_property_index_already_present_error :: dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError) , UndefinedIndexPropertyError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: undefined_index_property_error :: dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError) , UniqueIndicesLimitReachedError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unique_indices_limit_reached_error :: dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError) , DuplicateIndexNameError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_name_error :: dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError) , InvalidDataContractVersionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_version_error :: dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError) , IncompatibleDataContractSchemaError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: incompatible_data_contract_schema_error :: dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError) , DataContractImmutablePropertiesUpdateError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_immutable_properties_update_error :: dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError) , DataContractUniqueIndicesChangedError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_unique_indices_changed_error :: dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError) , DataContractInvalidIndexDefinitionUpdateError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_invalid_index_definition_update_error :: dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError) , DataContractHaveNewUniqueIndexError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_have_new_unique_index_error :: dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError) , DataContractNotPresentError (* mut crate :: fermented :: types :: dpp :: data_contract :: errors :: data_contract_not_present_error :: dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError) , DocumentCreationNotAllowedError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: document_creation_not_allowed_error :: dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError) , DataContractBoundsNotPresentError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: data_contract_bounds_not_present_error :: dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError) , DuplicateDocumentTransitionsWithIdsError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_ids_error :: dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError) , DuplicateDocumentTransitionsWithIndicesError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_indices_error :: dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError) , NonceOutOfBoundsError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: identity_contract_nonce_out_of_bounds_error :: dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError) , InconsistentCompoundIndexDataError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: inconsistent_compound_index_data_error :: dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError) , InvalidDocumentTransitionActionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_action_error :: dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError) , InvalidDocumentTransitionIdError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_id_error :: dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError) , InvalidDocumentTypeError (* mut crate :: fermented :: types :: dpp :: data_contract :: errors :: invalid_document_type_error :: dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError) , MissingPositionsInDocumentTypePropertiesError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_positions_in_document_type_properties_error :: dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError) , MissingDataContractIdBasicError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_data_contract_id_basic_error :: dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError) , MissingDocumentTransitionActionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_document_transition_action_error :: dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError) , MissingDocumentTransitionTypeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_document_transition_type_error :: dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError) , MissingDocumentTypeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_document_type_error :: dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError) , MaxDocumentsTransitionsExceededError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: max_documents_transitions_exceeded_error :: dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError) , DuplicatedIdentityPublicKeyBasicError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_basic_error :: dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError) , DuplicatedIdentityPublicKeyIdBasicError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_id_basic_error :: dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError) , DisablingKeyIdAlsoBeingAddedInSameTransitionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: disabling_key_id_also_being_added_in_same_transition_error :: dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError) , IdentityAssetLockProofLockedTransactionMismatchError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_proof_locked_transaction_mismatch_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError) , IdentityAssetLockTransactionIsNotFoundError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_is_not_found_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError) , IdentityAssetLockTransactionOutPointAlreadyConsumedError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_already_consumed_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError) , IdentityAssetLockTransactionOutPointNotEnoughBalanceError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_not_enough_balance_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError) , IdentityAssetLockStateTransitionReplayError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_state_transition_replay_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError) , IdentityAssetLockTransactionOutputNotFoundError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_output_not_found_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError) , InvalidAssetLockProofCoreChainHeightError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_core_chain_height_error :: dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError) , InvalidIdentityAssetLockProofChainLockValidationError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_proof_chain_lock_validation_error :: dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError) , InvalidAssetLockProofTransactionHeightError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_transaction_height_error :: dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError) , InvalidAssetLockTransactionOutputReturnSizeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_transaction_output_return_size :: dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError) , InvalidIdentityAssetLockTransactionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_error :: dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError) , InvalidIdentityAssetLockTransactionOutputError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_output_error :: dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError) , InvalidIdentityPublicKeyDataError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_data_error :: dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError) , InvalidInstantAssetLockProofError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_error :: dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError) , InvalidInstantAssetLockProofSignatureError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_signature_error :: dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError) , MissingMasterPublicKeyError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: missing_master_public_key_error :: dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError) , TooManyMasterPublicKeyError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: too_many_master_public_key_error :: dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError) , MasterPublicKeyUpdateError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: master_public_key_update_error :: dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError) , InvalidDocumentTypeRequiredSecurityLevelError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_required_security_level :: dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError) , InvalidIdentityPublicKeySecurityLevelError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_security_level_error :: dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError) , InvalidIdentityKeySignatureError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_key_signature_error :: dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError) , InvalidIdentityCreditTransferAmountError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_transfer_amount_error :: dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError) , InvalidIdentityCreditWithdrawalTransitionOutputScriptError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_output_script_error :: dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError) , WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: withdrawal_output_script_not_allowed_when_signing_with_owner_key :: dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError) , InvalidIdentityCreditWithdrawalTransitionCoreFeeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_core_fee_error :: dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError) , InvalidIdentityCreditWithdrawalTransitionAmountError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_amount_error :: dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError) , InvalidIdentityUpdateTransitionEmptyError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_empty_error :: dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError) , InvalidIdentityUpdateTransitionDisableKeysError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_disable_keys_error :: dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError) , NotImplementedIdentityCreditWithdrawalTransitionPoolingError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: not_implemented_identity_credit_withdrawal_transition_pooling_error :: dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError) , InvalidStateTransitionTypeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError) , MissingStateTransitionTypeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: state_transition :: missing_state_transition_type_error :: dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError) , DocumentFieldMaxSizeExceededError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: document_field_max_size_exceeded_error :: dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError) , StateTransitionMaxSizeExceededError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: state_transition :: state_transition_max_size_exceeded_error :: dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError) , DocumentTransitionsAreAbsentError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: document_transitions_are_absent_error :: dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError) , IdentityCreditTransferToSelfError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_credit_transfer_to_self_error :: dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError) , InvalidDocumentTypeNameError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_name_error :: dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError) , IncompatibleDocumentTypeSchemaError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: incompatible_document_type_schema_error :: dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError) , ContestedUniqueIndexOnMutableDocumentTypeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_on_mutable_document_type_error :: dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError) , ContestedUniqueIndexWithUniqueIndexError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_with_unique_index_error :: dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError) , OverflowError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: overflow_error :: dpp_errors_consensus_basic_overflow_error_OverflowError) , UnsupportedFeatureError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: unsupported_feature_error :: dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError) , ContestedDocumentsTemporarilyNotAllowedError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: contested_documents_temporarily_not_allowed_error :: dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError) , DataContractTokenConfigurationUpdateError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_token_configuration_update_error :: dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError) , NonContiguousContractTokenPositionsError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_token_positions_error :: dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError) , NonContiguousContractGroupPositionsError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_group_positions_error :: dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError) , InvalidTokenBaseSupplyError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_base_supply_error :: dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError) , InvalidTokenIdError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_id_error :: dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError) , InvalidTokenAmountError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_amount_error :: dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError) , InvalidTokenPositionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_position_error :: dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError) , InvalidTokenConfigUpdateNoChangeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_config_update_no_change_error :: dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError) , InvalidTokenDistributionFunctionDivideByZeroError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_divide_by_zero_error :: dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError) , InvalidTokenDistributionFunctionInvalidParameterError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_error :: dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError) , InvalidTokenDistributionFunctionInvalidParameterTupleError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_tuple_error :: dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError) , InvalidTokenDistributionFunctionIncoherenceError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_incoherence_error :: dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError) , TokenTransferToOurselfError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: token_transfer_to_ourselves_error :: dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError) , InvalidTokenNoteTooBigError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_note_too_big_error :: dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError) , ContractHasNoTokensError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: contract_has_no_tokens_error :: dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError) , GroupPositionDoesNotExistError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_position_does_not_exist_error :: dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError) , InvalidActionIdError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_action_id_error :: dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError) , DestinationIdentityForTokenMintingNotSetError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: destination_identity_for_token_minting_not_set_error :: dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError) , ChoosingTokenMintRecipientNotAllowedError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: choosing_token_mint_recipient_not_allowed_error :: dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError) , GroupActionNotAllowedOnTransitionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: group :: group_action_not_allowed_on_transition_error :: dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError) , GroupExceedsMaxMembersError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_exceeds_max_members_error :: dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError) , GroupMemberHasPowerOfZeroError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_of_zero_error :: dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError) , GroupMemberHasPowerOverLimitError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_over_limit_error :: dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError) , GroupTotalPowerLessThanRequiredError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_total_power_has_less_than_required_power_error :: dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError) , GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_non_unilateral_member_power_has_less_than_required_power_error :: dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError) , MissingDefaultLocalizationError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: missing_default_localization :: dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError) , UnknownGasFeesPaidByError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_gas_fees_paid_by_error :: dpp_errors_consensus_basic_data_contract_unknown_gas_fees_paid_by_error_UnknownGasFeesPaidByError) , UnknownDocumentActionTokenEffectError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_action_token_effect_error :: dpp_errors_consensus_basic_data_contract_unknown_document_action_token_effect_error_UnknownDocumentActionTokenEffectError) , TokenPaymentByBurningOnlyAllowedOnInternalTokenError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: token_payment_by_burning_only_allowed_on_internal_token_error :: dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError) , TooManyKeywordsError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: keywords_over_limit :: dpp_errors_consensus_basic_data_contract_keywords_over_limit_TooManyKeywordsError) , DuplicateKeywordsError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: duplicate_keywords_error :: dpp_errors_consensus_basic_data_contract_duplicate_keywords_error_DuplicateKeywordsError) , InvalidKeywordLengthError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_keyword_length_error :: dpp_errors_consensus_basic_data_contract_invalid_keyword_length_error_InvalidKeywordLengthError) , InvalidDescriptionLengthError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_description_length_error :: dpp_errors_consensus_basic_data_contract_invalid_description_length_error_InvalidDescriptionLengthError) , NewTokensDestinationIdentityOptionRequiredError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: new_tokens_destination_identity_option_required_error :: dpp_errors_consensus_basic_data_contract_new_tokens_destination_identity_option_required_error_NewTokensDestinationIdentityOptionRequiredError) , InvalidKeywordCharacterError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_keyword_character_error :: dpp_errors_consensus_basic_data_contract_invalid_keyword_character_error_InvalidKeywordCharacterError) , InvalidTokenNameCharacterError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_name_character_error :: dpp_errors_consensus_basic_data_contract_invalid_token_name_character_error_InvalidTokenNameCharacterError) , DecimalsOverLimitError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: token_decimals_over_limit_error :: dpp_errors_consensus_basic_data_contract_token_decimals_over_limit_error_DecimalsOverLimitError) , InvalidTokenNameLengthError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_name_length_error :: dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError) , InvalidTokenLanguageCodeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_language_code_error :: dpp_errors_consensus_basic_data_contract_invalid_token_language_code_error_InvalidTokenLanguageCodeError) , MainGroupIsNotDefinedError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: main_group_is_not_defined :: dpp_errors_consensus_basic_data_contract_main_group_is_not_defined_MainGroupIsNotDefinedError) , GroupRequiredPowerIsInvalidError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_required_power_is_invalid_error :: dpp_errors_consensus_basic_data_contract_group_required_power_is_invalid_error_GroupRequiredPowerIsInvalidError) , TokenNoteOnlyAllowedWhenProposerError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: token_note_only_allowed_on_proposer_error :: dpp_errors_consensus_basic_token_token_note_only_allowed_on_proposer_error_TokenNoteOnlyAllowedWhenProposerError) , InvalidTokenDistributionBlockIntervalTooShortError (* mut dpp :: consensus :: basic :: token :: InvalidTokenDistributionBlockIntervalTooShortError) , InvalidTokenDistributionTimeIntervalTooShortError (* mut dpp :: consensus :: basic :: token :: InvalidTokenDistributionTimeIntervalTooShortError) , InvalidTokenDistributionTimeIntervalNotMinuteAlignedError (* mut dpp :: consensus :: basic :: token :: InvalidTokenDistributionTimeIntervalNotMinuteAlignedError) , RedundantDocumentPaidForByTokenWithContractId (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: redundant_document_paid_for_by_token_with_contract_id :: dpp_errors_consensus_basic_data_contract_redundant_document_paid_for_by_token_with_contract_id_RedundantDocumentPaidForByTokenWithContractId) , GroupHasTooFewMembersError (* mut dpp :: consensus :: basic :: data_contract :: GroupHasTooFewMembersError) , InvalidKeyPurposeForContractBoundsError (* mut dpp :: consensus :: basic :: identity :: InvalidKeyPurposeForContractBoundsError) } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: basic_error :: BasicError > for dpp_errors_consensus_basic_basic_error_BasicError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_basic_error_BasicError) -> dpp :: errors :: consensus :: basic :: basic_error :: BasicError { let ffi_ref = & * ffi ; match ffi_ref { dpp_errors_consensus_basic_basic_error_BasicError :: ProtocolVersionParsingError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ProtocolVersionParsingError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: protocol_version_parsing_error :: dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: decode :: protocol_version_parsing_error :: ProtocolVersionParsingError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: VersionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: VersionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: version_error :: dpp_errors_consensus_basic_decode_version_error_VersionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: decode :: version_error :: VersionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: ContractError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ContractError (< crate :: fermented :: types :: dpp :: data_contract :: errors :: contract :: dpp_data_contract_errors_contract_DataContractError as ferment :: FFIConversionFrom < dpp :: data_contract :: errors :: contract :: DataContractError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownSecurityLevelError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownSecurityLevelError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_security_level_error :: dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unknown_security_level_error :: UnknownSecurityLevelError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownStorageKeyRequirementsError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownStorageKeyRequirementsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_storage_key_requirements_error :: dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unknown_storage_key_requirements_error :: UnknownStorageKeyRequirementsError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownTransferableTypeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownTransferableTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_transferable_type_error :: dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unknown_transferable_type_error :: UnknownTransferableTypeError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownTradeModeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownTradeModeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_trade_mode_error :: dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unknown_trade_mode_error :: UnknownTradeModeError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownDocumentCreationRestrictionModeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownDocumentCreationRestrictionModeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_creation_restriction_mode_error :: dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_creation_restriction_mode_error :: UnknownDocumentCreationRestrictionModeError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: SerializedObjectParsingError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: SerializedObjectParsingError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: serialized_object_parsing_error :: dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: decode :: serialized_object_parsing_error :: SerializedObjectParsingError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedProtocolVersionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnsupportedProtocolVersionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: unsupported_protocol_version_error :: dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: unsupported_protocol_version_error :: UnsupportedProtocolVersionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedVersionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnsupportedVersionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: unsupported_version_error :: dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: unsupported_version_error :: UnsupportedVersionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleProtocolVersionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IncompatibleProtocolVersionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: incompatible_protocol_version_error :: dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: incompatible_protocol_version_error :: IncompatibleProtocolVersionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: JsonSchemaCompilationError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: JsonSchemaCompilationError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: json_schema_compilation_error :: dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: json_schema_compilation_error :: JsonSchemaCompilationError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: JsonSchemaError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: JsonSchemaError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: json_schema_error :: error :: dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: json_schema_error :: error :: JsonSchemaError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentifierError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentifierError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: invalid_identifier_error :: dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: invalid_identifier_error :: InvalidIdentifierError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: ValueError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ValueError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: value_error :: dpp_errors_consensus_basic_value_error_ValueError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: value_error :: ValueError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractMaxDepthExceedError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractMaxDepthExceedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_max_depth_exceed_error :: dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_max_depth_exceed_error :: DataContractMaxDepthExceedError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateIndexError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicateIndexError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_error :: dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_error :: DuplicateIndexError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleRe2PatternError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IncompatibleRe2PatternError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: incompatible_re2_pattern_error :: dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: incompatible_re2_pattern_error :: IncompatibleRe2PatternError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidCompoundIndexError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidCompoundIndexError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_compound_index_error :: dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_compound_index_error :: InvalidCompoundIndexError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDataContractIdError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDataContractIdError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_id_error :: dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_id_error :: InvalidDataContractIdError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIndexedPropertyConstraintError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIndexedPropertyConstraintError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_indexed_property_constraint_error :: dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_indexed_property_constraint_error :: InvalidIndexedPropertyConstraintError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIndexPropertyTypeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIndexPropertyTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_index_property_type_error :: dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_index_property_type_error :: InvalidIndexPropertyTypeError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidJsonSchemaRefError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidJsonSchemaRefError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_json_schema_ref_error :: dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_json_schema_ref_error :: InvalidJsonSchemaRefError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: SystemPropertyIndexAlreadyPresentError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: SystemPropertyIndexAlreadyPresentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: system_property_index_already_present_error :: dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: system_property_index_already_present_error :: SystemPropertyIndexAlreadyPresentError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UndefinedIndexPropertyError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UndefinedIndexPropertyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: undefined_index_property_error :: dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: undefined_index_property_error :: UndefinedIndexPropertyError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UniqueIndicesLimitReachedError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UniqueIndicesLimitReachedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unique_indices_limit_reached_error :: dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unique_indices_limit_reached_error :: UniqueIndicesLimitReachedError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateIndexNameError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicateIndexNameError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_name_error :: dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_name_error :: DuplicateIndexNameError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDataContractVersionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDataContractVersionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_version_error :: dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_version_error :: InvalidDataContractVersionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleDataContractSchemaError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IncompatibleDataContractSchemaError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: incompatible_data_contract_schema_error :: dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: incompatible_data_contract_schema_error :: IncompatibleDataContractSchemaError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractImmutablePropertiesUpdateError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractImmutablePropertiesUpdateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_immutable_properties_update_error :: dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_immutable_properties_update_error :: DataContractImmutablePropertiesUpdateError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractUniqueIndicesChangedError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractUniqueIndicesChangedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_unique_indices_changed_error :: dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_unique_indices_changed_error :: DataContractUniqueIndicesChangedError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractInvalidIndexDefinitionUpdateError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractInvalidIndexDefinitionUpdateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_invalid_index_definition_update_error :: dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_invalid_index_definition_update_error :: DataContractInvalidIndexDefinitionUpdateError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractHaveNewUniqueIndexError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractHaveNewUniqueIndexError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_have_new_unique_index_error :: dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_have_new_unique_index_error :: DataContractHaveNewUniqueIndexError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractNotPresentError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractNotPresentError (< crate :: fermented :: types :: dpp :: data_contract :: errors :: data_contract_not_present_error :: dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError as ferment :: FFIConversionFrom < dpp :: data_contract :: errors :: data_contract_not_present_error :: DataContractNotPresentError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DocumentCreationNotAllowedError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DocumentCreationNotAllowedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: document_creation_not_allowed_error :: dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: document_creation_not_allowed_error :: DocumentCreationNotAllowedError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractBoundsNotPresentError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractBoundsNotPresentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: data_contract_bounds_not_present_error :: dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: data_contract_bounds_not_present_error :: DataContractBoundsNotPresentError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateDocumentTransitionsWithIdsError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicateDocumentTransitionsWithIdsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_ids_error :: dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_ids_error :: DuplicateDocumentTransitionsWithIdsError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateDocumentTransitionsWithIndicesError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicateDocumentTransitionsWithIndicesError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_indices_error :: dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_indices_error :: DuplicateDocumentTransitionsWithIndicesError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: NonceOutOfBoundsError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: NonceOutOfBoundsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: identity_contract_nonce_out_of_bounds_error :: dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: identity_contract_nonce_out_of_bounds_error :: NonceOutOfBoundsError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InconsistentCompoundIndexDataError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InconsistentCompoundIndexDataError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: inconsistent_compound_index_data_error :: dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: inconsistent_compound_index_data_error :: InconsistentCompoundIndexDataError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTransitionActionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDocumentTransitionActionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_action_error :: dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_action_error :: InvalidDocumentTransitionActionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTransitionIdError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDocumentTransitionIdError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_id_error :: dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_id_error :: InvalidDocumentTransitionIdError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDocumentTypeError (< crate :: fermented :: types :: dpp :: data_contract :: errors :: invalid_document_type_error :: dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError as ferment :: FFIConversionFrom < dpp :: data_contract :: errors :: invalid_document_type_error :: InvalidDocumentTypeError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: MissingPositionsInDocumentTypePropertiesError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingPositionsInDocumentTypePropertiesError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_positions_in_document_type_properties_error :: dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: missing_positions_in_document_type_properties_error :: MissingPositionsInDocumentTypePropertiesError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: MissingDataContractIdBasicError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingDataContractIdBasicError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_data_contract_id_basic_error :: dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: missing_data_contract_id_basic_error :: MissingDataContractIdBasicError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTransitionActionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingDocumentTransitionActionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_document_transition_action_error :: dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: missing_document_transition_action_error :: MissingDocumentTransitionActionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTransitionTypeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingDocumentTransitionTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_document_transition_type_error :: dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: missing_document_transition_type_error :: MissingDocumentTransitionTypeError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTypeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingDocumentTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_document_type_error :: dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: missing_document_type_error :: MissingDocumentTypeError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: MaxDocumentsTransitionsExceededError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MaxDocumentsTransitionsExceededError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: max_documents_transitions_exceeded_error :: dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: max_documents_transitions_exceeded_error :: MaxDocumentsTransitionsExceededError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicatedIdentityPublicKeyBasicError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicatedIdentityPublicKeyBasicError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_basic_error :: dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_basic_error :: DuplicatedIdentityPublicKeyBasicError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicatedIdentityPublicKeyIdBasicError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicatedIdentityPublicKeyIdBasicError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_id_basic_error :: dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_id_basic_error :: DuplicatedIdentityPublicKeyIdBasicError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DisablingKeyIdAlsoBeingAddedInSameTransitionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DisablingKeyIdAlsoBeingAddedInSameTransitionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: disabling_key_id_also_being_added_in_same_transition_error :: dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: disabling_key_id_also_being_added_in_same_transition_error :: DisablingKeyIdAlsoBeingAddedInSameTransitionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockProofLockedTransactionMismatchError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockProofLockedTransactionMismatchError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_proof_locked_transaction_mismatch_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_proof_locked_transaction_mismatch_error :: IdentityAssetLockProofLockedTransactionMismatchError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionIsNotFoundError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockTransactionIsNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_is_not_found_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_is_not_found_error :: IdentityAssetLockTransactionIsNotFoundError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutPointAlreadyConsumedError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockTransactionOutPointAlreadyConsumedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_already_consumed_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_already_consumed_error :: IdentityAssetLockTransactionOutPointAlreadyConsumedError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_not_enough_balance_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_not_enough_balance_error :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockStateTransitionReplayError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockStateTransitionReplayError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_state_transition_replay_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_state_transition_replay_error :: IdentityAssetLockStateTransitionReplayError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutputNotFoundError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockTransactionOutputNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_output_not_found_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_output_not_found_error :: IdentityAssetLockTransactionOutputNotFoundError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockProofCoreChainHeightError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidAssetLockProofCoreChainHeightError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_core_chain_height_error :: dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_core_chain_height_error :: InvalidAssetLockProofCoreChainHeightError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockProofChainLockValidationError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityAssetLockProofChainLockValidationError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_proof_chain_lock_validation_error :: dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_proof_chain_lock_validation_error :: InvalidIdentityAssetLockProofChainLockValidationError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockProofTransactionHeightError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidAssetLockProofTransactionHeightError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_transaction_height_error :: dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_transaction_height_error :: InvalidAssetLockProofTransactionHeightError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockTransactionOutputReturnSizeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidAssetLockTransactionOutputReturnSizeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_transaction_output_return_size :: dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_transaction_output_return_size :: InvalidAssetLockTransactionOutputReturnSizeError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockTransactionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityAssetLockTransactionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_error :: dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_error :: InvalidIdentityAssetLockTransactionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockTransactionOutputError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityAssetLockTransactionOutputError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_output_error :: dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_output_error :: InvalidIdentityAssetLockTransactionOutputError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityPublicKeyDataError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityPublicKeyDataError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_data_error :: dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_data_error :: InvalidIdentityPublicKeyDataError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidInstantAssetLockProofError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidInstantAssetLockProofError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_error :: dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_error :: InvalidInstantAssetLockProofError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidInstantAssetLockProofSignatureError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidInstantAssetLockProofSignatureError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_signature_error :: dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_signature_error :: InvalidInstantAssetLockProofSignatureError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: MissingMasterPublicKeyError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingMasterPublicKeyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: missing_master_public_key_error :: dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: missing_master_public_key_error :: MissingMasterPublicKeyError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: TooManyMasterPublicKeyError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: TooManyMasterPublicKeyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: too_many_master_public_key_error :: dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: too_many_master_public_key_error :: TooManyMasterPublicKeyError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: MasterPublicKeyUpdateError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MasterPublicKeyUpdateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: master_public_key_update_error :: dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: master_public_key_update_error :: MasterPublicKeyUpdateError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeRequiredSecurityLevelError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDocumentTypeRequiredSecurityLevelError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_required_security_level :: dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_required_security_level :: InvalidDocumentTypeRequiredSecurityLevelError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityPublicKeySecurityLevelError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityPublicKeySecurityLevelError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_security_level_error :: dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_security_level_error :: InvalidIdentityPublicKeySecurityLevelError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityKeySignatureError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityKeySignatureError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_key_signature_error :: dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_key_signature_error :: InvalidIdentityKeySignatureError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditTransferAmountError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityCreditTransferAmountError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_transfer_amount_error :: dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_transfer_amount_error :: InvalidIdentityCreditTransferAmountError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_output_script_error :: dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_output_script_error :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: withdrawal_output_script_not_allowed_when_signing_with_owner_key :: dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: withdrawal_output_script_not_allowed_when_signing_with_owner_key :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_core_fee_error :: dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_core_fee_error :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionAmountError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityCreditWithdrawalTransitionAmountError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_amount_error :: dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_amount_error :: InvalidIdentityCreditWithdrawalTransitionAmountError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityUpdateTransitionEmptyError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityUpdateTransitionEmptyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_empty_error :: dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_empty_error :: InvalidIdentityUpdateTransitionEmptyError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityUpdateTransitionDisableKeysError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityUpdateTransitionDisableKeysError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_disable_keys_error :: dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_disable_keys_error :: InvalidIdentityUpdateTransitionDisableKeysError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: not_implemented_identity_credit_withdrawal_transition_pooling_error :: dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: not_implemented_identity_credit_withdrawal_transition_pooling_error :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidStateTransitionTypeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidStateTransitionTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: InvalidStateTransitionTypeError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: MissingStateTransitionTypeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingStateTransitionTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: state_transition :: missing_state_transition_type_error :: dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: state_transition :: missing_state_transition_type_error :: MissingStateTransitionTypeError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DocumentFieldMaxSizeExceededError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DocumentFieldMaxSizeExceededError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: document_field_max_size_exceeded_error :: dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: document_field_max_size_exceeded_error :: DocumentFieldMaxSizeExceededError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: StateTransitionMaxSizeExceededError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: StateTransitionMaxSizeExceededError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: state_transition :: state_transition_max_size_exceeded_error :: dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: state_transition :: state_transition_max_size_exceeded_error :: StateTransitionMaxSizeExceededError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DocumentTransitionsAreAbsentError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DocumentTransitionsAreAbsentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: document_transitions_are_absent_error :: dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: document_transitions_are_absent_error :: DocumentTransitionsAreAbsentError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityCreditTransferToSelfError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityCreditTransferToSelfError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_credit_transfer_to_self_error :: dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_credit_transfer_to_self_error :: IdentityCreditTransferToSelfError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeNameError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDocumentTypeNameError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_name_error :: dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_name_error :: InvalidDocumentTypeNameError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleDocumentTypeSchemaError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IncompatibleDocumentTypeSchemaError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: incompatible_document_type_schema_error :: dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: incompatible_document_type_schema_error :: IncompatibleDocumentTypeSchemaError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: ContestedUniqueIndexOnMutableDocumentTypeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ContestedUniqueIndexOnMutableDocumentTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_on_mutable_document_type_error :: dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_on_mutable_document_type_error :: ContestedUniqueIndexOnMutableDocumentTypeError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: ContestedUniqueIndexWithUniqueIndexError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ContestedUniqueIndexWithUniqueIndexError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_with_unique_index_error :: dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_with_unique_index_error :: ContestedUniqueIndexWithUniqueIndexError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: OverflowError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: OverflowError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: overflow_error :: dpp_errors_consensus_basic_overflow_error_OverflowError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: overflow_error :: OverflowError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedFeatureError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnsupportedFeatureError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: unsupported_feature_error :: dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: unsupported_feature_error :: UnsupportedFeatureError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: ContestedDocumentsTemporarilyNotAllowedError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ContestedDocumentsTemporarilyNotAllowedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: contested_documents_temporarily_not_allowed_error :: dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: contested_documents_temporarily_not_allowed_error :: ContestedDocumentsTemporarilyNotAllowedError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractTokenConfigurationUpdateError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractTokenConfigurationUpdateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_token_configuration_update_error :: dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_token_configuration_update_error :: DataContractTokenConfigurationUpdateError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: NonContiguousContractTokenPositionsError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: NonContiguousContractTokenPositionsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_token_positions_error :: dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_token_positions_error :: NonContiguousContractTokenPositionsError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: NonContiguousContractGroupPositionsError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: NonContiguousContractGroupPositionsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_group_positions_error :: dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_group_positions_error :: NonContiguousContractGroupPositionsError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenBaseSupplyError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenBaseSupplyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_base_supply_error :: dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_base_supply_error :: InvalidTokenBaseSupplyError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenIdError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenIdError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_id_error :: dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: invalid_token_id_error :: InvalidTokenIdError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenAmountError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenAmountError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_amount_error :: dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: invalid_token_amount_error :: InvalidTokenAmountError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenPositionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenPositionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_position_error :: dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: invalid_token_position_error :: InvalidTokenPositionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenConfigUpdateNoChangeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenConfigUpdateNoChangeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_config_update_no_change_error :: dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: invalid_token_config_update_no_change_error :: InvalidTokenConfigUpdateNoChangeError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionDivideByZeroError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionFunctionDivideByZeroError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_divide_by_zero_error :: dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_divide_by_zero_error :: InvalidTokenDistributionFunctionDivideByZeroError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionInvalidParameterError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionFunctionInvalidParameterError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_error :: dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_error :: InvalidTokenDistributionFunctionInvalidParameterError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionInvalidParameterTupleError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionFunctionInvalidParameterTupleError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_tuple_error :: dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_tuple_error :: InvalidTokenDistributionFunctionInvalidParameterTupleError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionIncoherenceError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionFunctionIncoherenceError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_incoherence_error :: dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_incoherence_error :: InvalidTokenDistributionFunctionIncoherenceError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: TokenTransferToOurselfError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: TokenTransferToOurselfError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: token_transfer_to_ourselves_error :: dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: token_transfer_to_ourselves_error :: TokenTransferToOurselfError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenNoteTooBigError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenNoteTooBigError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_note_too_big_error :: dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: invalid_token_note_too_big_error :: InvalidTokenNoteTooBigError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: ContractHasNoTokensError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ContractHasNoTokensError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: contract_has_no_tokens_error :: dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: contract_has_no_tokens_error :: ContractHasNoTokensError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: GroupPositionDoesNotExistError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupPositionDoesNotExistError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_position_does_not_exist_error :: dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_position_does_not_exist_error :: GroupPositionDoesNotExistError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidActionIdError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidActionIdError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_action_id_error :: dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: invalid_action_id_error :: InvalidActionIdError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DestinationIdentityForTokenMintingNotSetError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DestinationIdentityForTokenMintingNotSetError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: destination_identity_for_token_minting_not_set_error :: dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: destination_identity_for_token_minting_not_set_error :: DestinationIdentityForTokenMintingNotSetError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: ChoosingTokenMintRecipientNotAllowedError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ChoosingTokenMintRecipientNotAllowedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: choosing_token_mint_recipient_not_allowed_error :: dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: choosing_token_mint_recipient_not_allowed_error :: ChoosingTokenMintRecipientNotAllowedError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: GroupActionNotAllowedOnTransitionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupActionNotAllowedOnTransitionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: group :: group_action_not_allowed_on_transition_error :: dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: group :: group_action_not_allowed_on_transition_error :: GroupActionNotAllowedOnTransitionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: GroupExceedsMaxMembersError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupExceedsMaxMembersError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_exceeds_max_members_error :: dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_exceeds_max_members_error :: GroupExceedsMaxMembersError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: GroupMemberHasPowerOfZeroError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupMemberHasPowerOfZeroError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_of_zero_error :: dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_of_zero_error :: GroupMemberHasPowerOfZeroError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: GroupMemberHasPowerOverLimitError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupMemberHasPowerOverLimitError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_over_limit_error :: dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_over_limit_error :: GroupMemberHasPowerOverLimitError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: GroupTotalPowerLessThanRequiredError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupTotalPowerLessThanRequiredError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_total_power_has_less_than_required_power_error :: dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_total_power_has_less_than_required_power_error :: GroupTotalPowerLessThanRequiredError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_non_unilateral_member_power_has_less_than_required_power_error :: dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_non_unilateral_member_power_has_less_than_required_power_error :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: MissingDefaultLocalizationError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingDefaultLocalizationError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: missing_default_localization :: dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: missing_default_localization :: MissingDefaultLocalizationError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownGasFeesPaidByError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownGasFeesPaidByError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_gas_fees_paid_by_error :: dpp_errors_consensus_basic_data_contract_unknown_gas_fees_paid_by_error_UnknownGasFeesPaidByError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unknown_gas_fees_paid_by_error :: UnknownGasFeesPaidByError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownDocumentActionTokenEffectError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownDocumentActionTokenEffectError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_action_token_effect_error :: dpp_errors_consensus_basic_data_contract_unknown_document_action_token_effect_error_UnknownDocumentActionTokenEffectError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_action_token_effect_error :: UnknownDocumentActionTokenEffectError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: TokenPaymentByBurningOnlyAllowedOnInternalTokenError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: TokenPaymentByBurningOnlyAllowedOnInternalTokenError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: token_payment_by_burning_only_allowed_on_internal_token_error :: dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: token_payment_by_burning_only_allowed_on_internal_token_error :: TokenPaymentByBurningOnlyAllowedOnInternalTokenError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: TooManyKeywordsError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: TooManyKeywordsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: keywords_over_limit :: dpp_errors_consensus_basic_data_contract_keywords_over_limit_TooManyKeywordsError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: keywords_over_limit :: TooManyKeywordsError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateKeywordsError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicateKeywordsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: duplicate_keywords_error :: dpp_errors_consensus_basic_data_contract_duplicate_keywords_error_DuplicateKeywordsError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: duplicate_keywords_error :: DuplicateKeywordsError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidKeywordLengthError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidKeywordLengthError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_keyword_length_error :: dpp_errors_consensus_basic_data_contract_invalid_keyword_length_error_InvalidKeywordLengthError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_keyword_length_error :: InvalidKeywordLengthError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDescriptionLengthError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDescriptionLengthError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_description_length_error :: dpp_errors_consensus_basic_data_contract_invalid_description_length_error_InvalidDescriptionLengthError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_description_length_error :: InvalidDescriptionLengthError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: NewTokensDestinationIdentityOptionRequiredError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: NewTokensDestinationIdentityOptionRequiredError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: new_tokens_destination_identity_option_required_error :: dpp_errors_consensus_basic_data_contract_new_tokens_destination_identity_option_required_error_NewTokensDestinationIdentityOptionRequiredError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: new_tokens_destination_identity_option_required_error :: NewTokensDestinationIdentityOptionRequiredError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidKeywordCharacterError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidKeywordCharacterError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_keyword_character_error :: dpp_errors_consensus_basic_data_contract_invalid_keyword_character_error_InvalidKeywordCharacterError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_keyword_character_error :: InvalidKeywordCharacterError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenNameCharacterError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenNameCharacterError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_name_character_error :: dpp_errors_consensus_basic_data_contract_invalid_token_name_character_error_InvalidTokenNameCharacterError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_name_character_error :: InvalidTokenNameCharacterError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DecimalsOverLimitError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DecimalsOverLimitError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: token_decimals_over_limit_error :: dpp_errors_consensus_basic_data_contract_token_decimals_over_limit_error_DecimalsOverLimitError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: token_decimals_over_limit_error :: DecimalsOverLimitError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenNameLengthError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenNameLengthError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_name_length_error :: dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_name_length_error :: InvalidTokenNameLengthError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenLanguageCodeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenLanguageCodeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_language_code_error :: dpp_errors_consensus_basic_data_contract_invalid_token_language_code_error_InvalidTokenLanguageCodeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_language_code_error :: InvalidTokenLanguageCodeError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: MainGroupIsNotDefinedError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MainGroupIsNotDefinedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: main_group_is_not_defined :: dpp_errors_consensus_basic_data_contract_main_group_is_not_defined_MainGroupIsNotDefinedError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: main_group_is_not_defined :: MainGroupIsNotDefinedError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: GroupRequiredPowerIsInvalidError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupRequiredPowerIsInvalidError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_required_power_is_invalid_error :: dpp_errors_consensus_basic_data_contract_group_required_power_is_invalid_error_GroupRequiredPowerIsInvalidError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_required_power_is_invalid_error :: GroupRequiredPowerIsInvalidError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: TokenNoteOnlyAllowedWhenProposerError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: TokenNoteOnlyAllowedWhenProposerError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: token_note_only_allowed_on_proposer_error :: dpp_errors_consensus_basic_token_token_note_only_allowed_on_proposer_error_TokenNoteOnlyAllowedWhenProposerError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: token_note_only_allowed_on_proposer_error :: TokenNoteOnlyAllowedWhenProposerError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionBlockIntervalTooShortError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionBlockIntervalTooShortError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionTimeIntervalTooShortError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionTimeIntervalTooShortError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionTimeIntervalNotMinuteAlignedError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionTimeIntervalNotMinuteAlignedError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: RedundantDocumentPaidForByTokenWithContractId (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: RedundantDocumentPaidForByTokenWithContractId (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: redundant_document_paid_for_by_token_with_contract_id :: dpp_errors_consensus_basic_data_contract_redundant_document_paid_for_by_token_with_contract_id_RedundantDocumentPaidForByTokenWithContractId as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: redundant_document_paid_for_by_token_with_contract_id :: RedundantDocumentPaidForByTokenWithContractId >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: GroupHasTooFewMembersError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupHasTooFewMembersError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidKeyPurposeForContractBoundsError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidKeyPurposeForContractBoundsError (std :: ptr :: read (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: basic_error :: BasicError > for dpp_errors_consensus_basic_basic_error_BasicError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: basic_error :: BasicError) -> * const dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (match obj { dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ProtocolVersionParsingError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: ProtocolVersionParsingError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: protocol_version_parsing_error :: dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: decode :: protocol_version_parsing_error :: ProtocolVersionParsingError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: VersionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: VersionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: version_error :: dpp_errors_consensus_basic_decode_version_error_VersionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: decode :: version_error :: VersionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ContractError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: ContractError (< crate :: fermented :: types :: dpp :: data_contract :: errors :: contract :: dpp_data_contract_errors_contract_DataContractError as ferment :: FFIConversionTo < dpp :: data_contract :: errors :: contract :: DataContractError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownSecurityLevelError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UnknownSecurityLevelError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_security_level_error :: dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unknown_security_level_error :: UnknownSecurityLevelError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownStorageKeyRequirementsError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UnknownStorageKeyRequirementsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_storage_key_requirements_error :: dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unknown_storage_key_requirements_error :: UnknownStorageKeyRequirementsError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownTransferableTypeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UnknownTransferableTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_transferable_type_error :: dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unknown_transferable_type_error :: UnknownTransferableTypeError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownTradeModeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UnknownTradeModeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_trade_mode_error :: dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unknown_trade_mode_error :: UnknownTradeModeError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownDocumentCreationRestrictionModeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UnknownDocumentCreationRestrictionModeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_creation_restriction_mode_error :: dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_creation_restriction_mode_error :: UnknownDocumentCreationRestrictionModeError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: SerializedObjectParsingError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: SerializedObjectParsingError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: serialized_object_parsing_error :: dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: decode :: serialized_object_parsing_error :: SerializedObjectParsingError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnsupportedProtocolVersionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedProtocolVersionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: unsupported_protocol_version_error :: dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: unsupported_protocol_version_error :: UnsupportedProtocolVersionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnsupportedVersionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedVersionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: unsupported_version_error :: dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: unsupported_version_error :: UnsupportedVersionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IncompatibleProtocolVersionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleProtocolVersionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: incompatible_protocol_version_error :: dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: incompatible_protocol_version_error :: IncompatibleProtocolVersionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: JsonSchemaCompilationError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: JsonSchemaCompilationError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: json_schema_compilation_error :: dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: json_schema_compilation_error :: JsonSchemaCompilationError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: JsonSchemaError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: JsonSchemaError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: json_schema_error :: error :: dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: json_schema_error :: error :: JsonSchemaError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentifierError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentifierError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: invalid_identifier_error :: dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: invalid_identifier_error :: InvalidIdentifierError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ValueError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: ValueError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: value_error :: dpp_errors_consensus_basic_value_error_ValueError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: value_error :: ValueError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractMaxDepthExceedError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DataContractMaxDepthExceedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_max_depth_exceed_error :: dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_max_depth_exceed_error :: DataContractMaxDepthExceedError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicateIndexError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateIndexError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_error :: dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_error :: DuplicateIndexError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IncompatibleRe2PatternError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleRe2PatternError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: incompatible_re2_pattern_error :: dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: incompatible_re2_pattern_error :: IncompatibleRe2PatternError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidCompoundIndexError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidCompoundIndexError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_compound_index_error :: dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_compound_index_error :: InvalidCompoundIndexError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDataContractIdError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDataContractIdError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_id_error :: dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_id_error :: InvalidDataContractIdError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIndexedPropertyConstraintError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIndexedPropertyConstraintError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_indexed_property_constraint_error :: dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_indexed_property_constraint_error :: InvalidIndexedPropertyConstraintError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIndexPropertyTypeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIndexPropertyTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_index_property_type_error :: dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_index_property_type_error :: InvalidIndexPropertyTypeError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidJsonSchemaRefError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidJsonSchemaRefError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_json_schema_ref_error :: dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_json_schema_ref_error :: InvalidJsonSchemaRefError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: SystemPropertyIndexAlreadyPresentError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: SystemPropertyIndexAlreadyPresentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: system_property_index_already_present_error :: dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: system_property_index_already_present_error :: SystemPropertyIndexAlreadyPresentError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UndefinedIndexPropertyError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UndefinedIndexPropertyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: undefined_index_property_error :: dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: undefined_index_property_error :: UndefinedIndexPropertyError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UniqueIndicesLimitReachedError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UniqueIndicesLimitReachedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unique_indices_limit_reached_error :: dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unique_indices_limit_reached_error :: UniqueIndicesLimitReachedError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicateIndexNameError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateIndexNameError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_name_error :: dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_name_error :: DuplicateIndexNameError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDataContractVersionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDataContractVersionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_version_error :: dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_version_error :: InvalidDataContractVersionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IncompatibleDataContractSchemaError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleDataContractSchemaError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: incompatible_data_contract_schema_error :: dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: incompatible_data_contract_schema_error :: IncompatibleDataContractSchemaError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractImmutablePropertiesUpdateError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DataContractImmutablePropertiesUpdateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_immutable_properties_update_error :: dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_immutable_properties_update_error :: DataContractImmutablePropertiesUpdateError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractUniqueIndicesChangedError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DataContractUniqueIndicesChangedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_unique_indices_changed_error :: dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_unique_indices_changed_error :: DataContractUniqueIndicesChangedError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractInvalidIndexDefinitionUpdateError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DataContractInvalidIndexDefinitionUpdateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_invalid_index_definition_update_error :: dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_invalid_index_definition_update_error :: DataContractInvalidIndexDefinitionUpdateError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractHaveNewUniqueIndexError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DataContractHaveNewUniqueIndexError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_have_new_unique_index_error :: dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_have_new_unique_index_error :: DataContractHaveNewUniqueIndexError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractNotPresentError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DataContractNotPresentError (< crate :: fermented :: types :: dpp :: data_contract :: errors :: data_contract_not_present_error :: dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError as ferment :: FFIConversionTo < dpp :: data_contract :: errors :: data_contract_not_present_error :: DataContractNotPresentError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DocumentCreationNotAllowedError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DocumentCreationNotAllowedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: document_creation_not_allowed_error :: dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: document_creation_not_allowed_error :: DocumentCreationNotAllowedError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractBoundsNotPresentError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DataContractBoundsNotPresentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: data_contract_bounds_not_present_error :: dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: data_contract_bounds_not_present_error :: DataContractBoundsNotPresentError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicateDocumentTransitionsWithIdsError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateDocumentTransitionsWithIdsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_ids_error :: dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_ids_error :: DuplicateDocumentTransitionsWithIdsError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicateDocumentTransitionsWithIndicesError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateDocumentTransitionsWithIndicesError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_indices_error :: dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_indices_error :: DuplicateDocumentTransitionsWithIndicesError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: NonceOutOfBoundsError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: NonceOutOfBoundsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: identity_contract_nonce_out_of_bounds_error :: dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: identity_contract_nonce_out_of_bounds_error :: NonceOutOfBoundsError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InconsistentCompoundIndexDataError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InconsistentCompoundIndexDataError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: inconsistent_compound_index_data_error :: dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: inconsistent_compound_index_data_error :: InconsistentCompoundIndexDataError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDocumentTransitionActionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTransitionActionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_action_error :: dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_action_error :: InvalidDocumentTransitionActionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDocumentTransitionIdError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTransitionIdError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_id_error :: dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_id_error :: InvalidDocumentTransitionIdError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDocumentTypeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeError (< crate :: fermented :: types :: dpp :: data_contract :: errors :: invalid_document_type_error :: dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError as ferment :: FFIConversionTo < dpp :: data_contract :: errors :: invalid_document_type_error :: InvalidDocumentTypeError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingPositionsInDocumentTypePropertiesError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: MissingPositionsInDocumentTypePropertiesError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_positions_in_document_type_properties_error :: dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: missing_positions_in_document_type_properties_error :: MissingPositionsInDocumentTypePropertiesError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingDataContractIdBasicError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: MissingDataContractIdBasicError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_data_contract_id_basic_error :: dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: missing_data_contract_id_basic_error :: MissingDataContractIdBasicError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingDocumentTransitionActionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTransitionActionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_document_transition_action_error :: dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: missing_document_transition_action_error :: MissingDocumentTransitionActionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingDocumentTransitionTypeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTransitionTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_document_transition_type_error :: dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: missing_document_transition_type_error :: MissingDocumentTransitionTypeError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingDocumentTypeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_document_type_error :: dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: missing_document_type_error :: MissingDocumentTypeError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MaxDocumentsTransitionsExceededError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: MaxDocumentsTransitionsExceededError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: max_documents_transitions_exceeded_error :: dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: max_documents_transitions_exceeded_error :: MaxDocumentsTransitionsExceededError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicatedIdentityPublicKeyBasicError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DuplicatedIdentityPublicKeyBasicError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_basic_error :: dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_basic_error :: DuplicatedIdentityPublicKeyBasicError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicatedIdentityPublicKeyIdBasicError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DuplicatedIdentityPublicKeyIdBasicError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_id_basic_error :: dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_id_basic_error :: DuplicatedIdentityPublicKeyIdBasicError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DisablingKeyIdAlsoBeingAddedInSameTransitionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DisablingKeyIdAlsoBeingAddedInSameTransitionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: disabling_key_id_also_being_added_in_same_transition_error :: dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: disabling_key_id_also_being_added_in_same_transition_error :: DisablingKeyIdAlsoBeingAddedInSameTransitionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockProofLockedTransactionMismatchError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockProofLockedTransactionMismatchError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_proof_locked_transaction_mismatch_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_proof_locked_transaction_mismatch_error :: IdentityAssetLockProofLockedTransactionMismatchError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockTransactionIsNotFoundError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionIsNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_is_not_found_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_is_not_found_error :: IdentityAssetLockTransactionIsNotFoundError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockTransactionOutPointAlreadyConsumedError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutPointAlreadyConsumedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_already_consumed_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_already_consumed_error :: IdentityAssetLockTransactionOutPointAlreadyConsumedError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_not_enough_balance_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_not_enough_balance_error :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockStateTransitionReplayError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockStateTransitionReplayError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_state_transition_replay_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_state_transition_replay_error :: IdentityAssetLockStateTransitionReplayError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockTransactionOutputNotFoundError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutputNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_output_not_found_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_output_not_found_error :: IdentityAssetLockTransactionOutputNotFoundError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidAssetLockProofCoreChainHeightError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockProofCoreChainHeightError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_core_chain_height_error :: dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_core_chain_height_error :: InvalidAssetLockProofCoreChainHeightError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityAssetLockProofChainLockValidationError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockProofChainLockValidationError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_proof_chain_lock_validation_error :: dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_proof_chain_lock_validation_error :: InvalidIdentityAssetLockProofChainLockValidationError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidAssetLockProofTransactionHeightError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockProofTransactionHeightError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_transaction_height_error :: dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_transaction_height_error :: InvalidAssetLockProofTransactionHeightError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidAssetLockTransactionOutputReturnSizeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockTransactionOutputReturnSizeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_transaction_output_return_size :: dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_transaction_output_return_size :: InvalidAssetLockTransactionOutputReturnSizeError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityAssetLockTransactionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockTransactionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_error :: dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_error :: InvalidIdentityAssetLockTransactionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityAssetLockTransactionOutputError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockTransactionOutputError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_output_error :: dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_output_error :: InvalidIdentityAssetLockTransactionOutputError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityPublicKeyDataError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityPublicKeyDataError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_data_error :: dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_data_error :: InvalidIdentityPublicKeyDataError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidInstantAssetLockProofError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidInstantAssetLockProofError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_error :: dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_error :: InvalidInstantAssetLockProofError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidInstantAssetLockProofSignatureError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidInstantAssetLockProofSignatureError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_signature_error :: dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_signature_error :: InvalidInstantAssetLockProofSignatureError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingMasterPublicKeyError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: MissingMasterPublicKeyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: missing_master_public_key_error :: dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: missing_master_public_key_error :: MissingMasterPublicKeyError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: TooManyMasterPublicKeyError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: TooManyMasterPublicKeyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: too_many_master_public_key_error :: dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: too_many_master_public_key_error :: TooManyMasterPublicKeyError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MasterPublicKeyUpdateError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: MasterPublicKeyUpdateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: master_public_key_update_error :: dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: master_public_key_update_error :: MasterPublicKeyUpdateError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDocumentTypeRequiredSecurityLevelError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeRequiredSecurityLevelError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_required_security_level :: dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_required_security_level :: InvalidDocumentTypeRequiredSecurityLevelError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityPublicKeySecurityLevelError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityPublicKeySecurityLevelError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_security_level_error :: dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_security_level_error :: InvalidIdentityPublicKeySecurityLevelError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityKeySignatureError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityKeySignatureError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_key_signature_error :: dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_key_signature_error :: InvalidIdentityKeySignatureError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityCreditTransferAmountError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditTransferAmountError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_transfer_amount_error :: dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_transfer_amount_error :: InvalidIdentityCreditTransferAmountError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_output_script_error :: dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_output_script_error :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: withdrawal_output_script_not_allowed_when_signing_with_owner_key :: dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: withdrawal_output_script_not_allowed_when_signing_with_owner_key :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_core_fee_error :: dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_core_fee_error :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityCreditWithdrawalTransitionAmountError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionAmountError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_amount_error :: dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_amount_error :: InvalidIdentityCreditWithdrawalTransitionAmountError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityUpdateTransitionEmptyError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityUpdateTransitionEmptyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_empty_error :: dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_empty_error :: InvalidIdentityUpdateTransitionEmptyError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityUpdateTransitionDisableKeysError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityUpdateTransitionDisableKeysError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_disable_keys_error :: dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_disable_keys_error :: InvalidIdentityUpdateTransitionDisableKeysError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: not_implemented_identity_credit_withdrawal_transition_pooling_error :: dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: not_implemented_identity_credit_withdrawal_transition_pooling_error :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidStateTransitionTypeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidStateTransitionTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: InvalidStateTransitionTypeError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingStateTransitionTypeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: MissingStateTransitionTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: state_transition :: missing_state_transition_type_error :: dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: state_transition :: missing_state_transition_type_error :: MissingStateTransitionTypeError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DocumentFieldMaxSizeExceededError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DocumentFieldMaxSizeExceededError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: document_field_max_size_exceeded_error :: dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: document_field_max_size_exceeded_error :: DocumentFieldMaxSizeExceededError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: StateTransitionMaxSizeExceededError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: StateTransitionMaxSizeExceededError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: state_transition :: state_transition_max_size_exceeded_error :: dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: state_transition :: state_transition_max_size_exceeded_error :: StateTransitionMaxSizeExceededError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DocumentTransitionsAreAbsentError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DocumentTransitionsAreAbsentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: document_transitions_are_absent_error :: dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: document_transitions_are_absent_error :: DocumentTransitionsAreAbsentError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityCreditTransferToSelfError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IdentityCreditTransferToSelfError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_credit_transfer_to_self_error :: dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_credit_transfer_to_self_error :: IdentityCreditTransferToSelfError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDocumentTypeNameError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeNameError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_name_error :: dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_name_error :: InvalidDocumentTypeNameError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IncompatibleDocumentTypeSchemaError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleDocumentTypeSchemaError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: incompatible_document_type_schema_error :: dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: incompatible_document_type_schema_error :: IncompatibleDocumentTypeSchemaError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ContestedUniqueIndexOnMutableDocumentTypeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: ContestedUniqueIndexOnMutableDocumentTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_on_mutable_document_type_error :: dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_on_mutable_document_type_error :: ContestedUniqueIndexOnMutableDocumentTypeError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ContestedUniqueIndexWithUniqueIndexError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: ContestedUniqueIndexWithUniqueIndexError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_with_unique_index_error :: dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_with_unique_index_error :: ContestedUniqueIndexWithUniqueIndexError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: OverflowError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: OverflowError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: overflow_error :: dpp_errors_consensus_basic_overflow_error_OverflowError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: overflow_error :: OverflowError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnsupportedFeatureError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedFeatureError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: unsupported_feature_error :: dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: unsupported_feature_error :: UnsupportedFeatureError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ContestedDocumentsTemporarilyNotAllowedError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: ContestedDocumentsTemporarilyNotAllowedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: contested_documents_temporarily_not_allowed_error :: dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: contested_documents_temporarily_not_allowed_error :: ContestedDocumentsTemporarilyNotAllowedError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractTokenConfigurationUpdateError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DataContractTokenConfigurationUpdateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_token_configuration_update_error :: dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_token_configuration_update_error :: DataContractTokenConfigurationUpdateError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: NonContiguousContractTokenPositionsError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: NonContiguousContractTokenPositionsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_token_positions_error :: dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_token_positions_error :: NonContiguousContractTokenPositionsError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: NonContiguousContractGroupPositionsError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: NonContiguousContractGroupPositionsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_group_positions_error :: dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_group_positions_error :: NonContiguousContractGroupPositionsError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenBaseSupplyError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenBaseSupplyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_base_supply_error :: dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_base_supply_error :: InvalidTokenBaseSupplyError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenIdError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenIdError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_id_error :: dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: invalid_token_id_error :: InvalidTokenIdError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenAmountError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenAmountError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_amount_error :: dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: invalid_token_amount_error :: InvalidTokenAmountError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenPositionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenPositionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_position_error :: dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: invalid_token_position_error :: InvalidTokenPositionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenConfigUpdateNoChangeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenConfigUpdateNoChangeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_config_update_no_change_error :: dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: invalid_token_config_update_no_change_error :: InvalidTokenConfigUpdateNoChangeError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionFunctionDivideByZeroError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionDivideByZeroError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_divide_by_zero_error :: dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_divide_by_zero_error :: InvalidTokenDistributionFunctionDivideByZeroError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionFunctionInvalidParameterError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionInvalidParameterError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_error :: dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_error :: InvalidTokenDistributionFunctionInvalidParameterError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionFunctionInvalidParameterTupleError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionInvalidParameterTupleError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_tuple_error :: dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_tuple_error :: InvalidTokenDistributionFunctionInvalidParameterTupleError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionFunctionIncoherenceError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionIncoherenceError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_incoherence_error :: dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_incoherence_error :: InvalidTokenDistributionFunctionIncoherenceError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: TokenTransferToOurselfError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: TokenTransferToOurselfError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: token_transfer_to_ourselves_error :: dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: token_transfer_to_ourselves_error :: TokenTransferToOurselfError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenNoteTooBigError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenNoteTooBigError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_note_too_big_error :: dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: invalid_token_note_too_big_error :: InvalidTokenNoteTooBigError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ContractHasNoTokensError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: ContractHasNoTokensError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: contract_has_no_tokens_error :: dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: contract_has_no_tokens_error :: ContractHasNoTokensError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupPositionDoesNotExistError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: GroupPositionDoesNotExistError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_position_does_not_exist_error :: dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_position_does_not_exist_error :: GroupPositionDoesNotExistError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidActionIdError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidActionIdError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_action_id_error :: dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: invalid_action_id_error :: InvalidActionIdError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DestinationIdentityForTokenMintingNotSetError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DestinationIdentityForTokenMintingNotSetError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: destination_identity_for_token_minting_not_set_error :: dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: destination_identity_for_token_minting_not_set_error :: DestinationIdentityForTokenMintingNotSetError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ChoosingTokenMintRecipientNotAllowedError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: ChoosingTokenMintRecipientNotAllowedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: choosing_token_mint_recipient_not_allowed_error :: dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: choosing_token_mint_recipient_not_allowed_error :: ChoosingTokenMintRecipientNotAllowedError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupActionNotAllowedOnTransitionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: GroupActionNotAllowedOnTransitionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: group :: group_action_not_allowed_on_transition_error :: dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: group :: group_action_not_allowed_on_transition_error :: GroupActionNotAllowedOnTransitionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupExceedsMaxMembersError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: GroupExceedsMaxMembersError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_exceeds_max_members_error :: dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_exceeds_max_members_error :: GroupExceedsMaxMembersError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupMemberHasPowerOfZeroError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: GroupMemberHasPowerOfZeroError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_of_zero_error :: dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_of_zero_error :: GroupMemberHasPowerOfZeroError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupMemberHasPowerOverLimitError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: GroupMemberHasPowerOverLimitError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_over_limit_error :: dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_over_limit_error :: GroupMemberHasPowerOverLimitError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupTotalPowerLessThanRequiredError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: GroupTotalPowerLessThanRequiredError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_total_power_has_less_than_required_power_error :: dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_total_power_has_less_than_required_power_error :: GroupTotalPowerLessThanRequiredError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_non_unilateral_member_power_has_less_than_required_power_error :: dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_non_unilateral_member_power_has_less_than_required_power_error :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingDefaultLocalizationError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: MissingDefaultLocalizationError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: missing_default_localization :: dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: missing_default_localization :: MissingDefaultLocalizationError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownGasFeesPaidByError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UnknownGasFeesPaidByError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_gas_fees_paid_by_error :: dpp_errors_consensus_basic_data_contract_unknown_gas_fees_paid_by_error_UnknownGasFeesPaidByError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unknown_gas_fees_paid_by_error :: UnknownGasFeesPaidByError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownDocumentActionTokenEffectError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UnknownDocumentActionTokenEffectError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_action_token_effect_error :: dpp_errors_consensus_basic_data_contract_unknown_document_action_token_effect_error_UnknownDocumentActionTokenEffectError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_action_token_effect_error :: UnknownDocumentActionTokenEffectError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: TokenPaymentByBurningOnlyAllowedOnInternalTokenError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: TokenPaymentByBurningOnlyAllowedOnInternalTokenError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: token_payment_by_burning_only_allowed_on_internal_token_error :: dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: token_payment_by_burning_only_allowed_on_internal_token_error :: TokenPaymentByBurningOnlyAllowedOnInternalTokenError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: TooManyKeywordsError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: TooManyKeywordsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: keywords_over_limit :: dpp_errors_consensus_basic_data_contract_keywords_over_limit_TooManyKeywordsError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: keywords_over_limit :: TooManyKeywordsError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicateKeywordsError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateKeywordsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: duplicate_keywords_error :: dpp_errors_consensus_basic_data_contract_duplicate_keywords_error_DuplicateKeywordsError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: duplicate_keywords_error :: DuplicateKeywordsError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidKeywordLengthError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidKeywordLengthError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_keyword_length_error :: dpp_errors_consensus_basic_data_contract_invalid_keyword_length_error_InvalidKeywordLengthError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_keyword_length_error :: InvalidKeywordLengthError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDescriptionLengthError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDescriptionLengthError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_description_length_error :: dpp_errors_consensus_basic_data_contract_invalid_description_length_error_InvalidDescriptionLengthError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_description_length_error :: InvalidDescriptionLengthError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: NewTokensDestinationIdentityOptionRequiredError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: NewTokensDestinationIdentityOptionRequiredError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: new_tokens_destination_identity_option_required_error :: dpp_errors_consensus_basic_data_contract_new_tokens_destination_identity_option_required_error_NewTokensDestinationIdentityOptionRequiredError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: new_tokens_destination_identity_option_required_error :: NewTokensDestinationIdentityOptionRequiredError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidKeywordCharacterError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidKeywordCharacterError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_keyword_character_error :: dpp_errors_consensus_basic_data_contract_invalid_keyword_character_error_InvalidKeywordCharacterError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_keyword_character_error :: InvalidKeywordCharacterError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenNameCharacterError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenNameCharacterError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_name_character_error :: dpp_errors_consensus_basic_data_contract_invalid_token_name_character_error_InvalidTokenNameCharacterError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_name_character_error :: InvalidTokenNameCharacterError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DecimalsOverLimitError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DecimalsOverLimitError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: token_decimals_over_limit_error :: dpp_errors_consensus_basic_data_contract_token_decimals_over_limit_error_DecimalsOverLimitError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: token_decimals_over_limit_error :: DecimalsOverLimitError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenNameLengthError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenNameLengthError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_name_length_error :: dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_name_length_error :: InvalidTokenNameLengthError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenLanguageCodeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenLanguageCodeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_language_code_error :: dpp_errors_consensus_basic_data_contract_invalid_token_language_code_error_InvalidTokenLanguageCodeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_language_code_error :: InvalidTokenLanguageCodeError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MainGroupIsNotDefinedError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: MainGroupIsNotDefinedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: main_group_is_not_defined :: dpp_errors_consensus_basic_data_contract_main_group_is_not_defined_MainGroupIsNotDefinedError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: main_group_is_not_defined :: MainGroupIsNotDefinedError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupRequiredPowerIsInvalidError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: GroupRequiredPowerIsInvalidError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_required_power_is_invalid_error :: dpp_errors_consensus_basic_data_contract_group_required_power_is_invalid_error_GroupRequiredPowerIsInvalidError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_required_power_is_invalid_error :: GroupRequiredPowerIsInvalidError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: TokenNoteOnlyAllowedWhenProposerError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: TokenNoteOnlyAllowedWhenProposerError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: token_note_only_allowed_on_proposer_error :: dpp_errors_consensus_basic_token_token_note_only_allowed_on_proposer_error_TokenNoteOnlyAllowedWhenProposerError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: token_note_only_allowed_on_proposer_error :: TokenNoteOnlyAllowedWhenProposerError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionBlockIntervalTooShortError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionBlockIntervalTooShortError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionTimeIntervalTooShortError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionTimeIntervalTooShortError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionTimeIntervalNotMinuteAlignedError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionTimeIntervalNotMinuteAlignedError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: RedundantDocumentPaidForByTokenWithContractId (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: RedundantDocumentPaidForByTokenWithContractId (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: redundant_document_paid_for_by_token_with_contract_id :: dpp_errors_consensus_basic_data_contract_redundant_document_paid_for_by_token_with_contract_id_RedundantDocumentPaidForByTokenWithContractId as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: redundant_document_paid_for_by_token_with_contract_id :: RedundantDocumentPaidForByTokenWithContractId >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupHasTooFewMembersError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: GroupHasTooFewMembersError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidKeyPurposeForContractBoundsError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidKeyPurposeForContractBoundsError (ferment :: boxed (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_errors_consensus_basic_basic_error_BasicError { fn drop (& mut self) { unsafe { match self { dpp_errors_consensus_basic_basic_error_BasicError :: ProtocolVersionParsingError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: VersionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: ContractError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownSecurityLevelError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownStorageKeyRequirementsError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownTransferableTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownTradeModeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownDocumentCreationRestrictionModeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: SerializedObjectParsingError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedProtocolVersionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedVersionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleProtocolVersionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: JsonSchemaCompilationError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: JsonSchemaError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentifierError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: ValueError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractMaxDepthExceedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateIndexError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleRe2PatternError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidCompoundIndexError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDataContractIdError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIndexedPropertyConstraintError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIndexPropertyTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidJsonSchemaRefError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: SystemPropertyIndexAlreadyPresentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UndefinedIndexPropertyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UniqueIndicesLimitReachedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateIndexNameError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDataContractVersionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleDataContractSchemaError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractImmutablePropertiesUpdateError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractUniqueIndicesChangedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractInvalidIndexDefinitionUpdateError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractHaveNewUniqueIndexError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractNotPresentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DocumentCreationNotAllowedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractBoundsNotPresentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateDocumentTransitionsWithIdsError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateDocumentTransitionsWithIndicesError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: NonceOutOfBoundsError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InconsistentCompoundIndexDataError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTransitionActionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTransitionIdError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: MissingPositionsInDocumentTypePropertiesError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: MissingDataContractIdBasicError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTransitionActionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTransitionTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: MaxDocumentsTransitionsExceededError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicatedIdentityPublicKeyBasicError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicatedIdentityPublicKeyIdBasicError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DisablingKeyIdAlsoBeingAddedInSameTransitionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockProofLockedTransactionMismatchError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionIsNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutPointAlreadyConsumedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockStateTransitionReplayError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutputNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockProofCoreChainHeightError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockProofChainLockValidationError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockProofTransactionHeightError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockTransactionOutputReturnSizeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockTransactionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockTransactionOutputError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityPublicKeyDataError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidInstantAssetLockProofError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidInstantAssetLockProofSignatureError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: MissingMasterPublicKeyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: TooManyMasterPublicKeyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: MasterPublicKeyUpdateError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeRequiredSecurityLevelError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityPublicKeySecurityLevelError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityKeySignatureError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditTransferAmountError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionAmountError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityUpdateTransitionEmptyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityUpdateTransitionDisableKeysError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidStateTransitionTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: MissingStateTransitionTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DocumentFieldMaxSizeExceededError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: StateTransitionMaxSizeExceededError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DocumentTransitionsAreAbsentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityCreditTransferToSelfError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeNameError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleDocumentTypeSchemaError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: ContestedUniqueIndexOnMutableDocumentTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: ContestedUniqueIndexWithUniqueIndexError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: OverflowError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedFeatureError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: ContestedDocumentsTemporarilyNotAllowedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractTokenConfigurationUpdateError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: NonContiguousContractTokenPositionsError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: NonContiguousContractGroupPositionsError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenBaseSupplyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenIdError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenAmountError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenPositionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenConfigUpdateNoChangeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionDivideByZeroError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionInvalidParameterError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionInvalidParameterTupleError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionIncoherenceError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: TokenTransferToOurselfError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenNoteTooBigError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: ContractHasNoTokensError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: GroupPositionDoesNotExistError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidActionIdError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DestinationIdentityForTokenMintingNotSetError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: ChoosingTokenMintRecipientNotAllowedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: GroupActionNotAllowedOnTransitionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: GroupExceedsMaxMembersError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: GroupMemberHasPowerOfZeroError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: GroupMemberHasPowerOverLimitError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: GroupTotalPowerLessThanRequiredError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: MissingDefaultLocalizationError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownGasFeesPaidByError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownDocumentActionTokenEffectError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: TokenPaymentByBurningOnlyAllowedOnInternalTokenError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: TooManyKeywordsError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateKeywordsError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidKeywordLengthError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDescriptionLengthError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: NewTokensDestinationIdentityOptionRequiredError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidKeywordCharacterError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenNameCharacterError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DecimalsOverLimitError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenNameLengthError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenLanguageCodeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: MainGroupIsNotDefinedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: GroupRequiredPowerIsInvalidError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: TokenNoteOnlyAllowedWhenProposerError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionBlockIntervalTooShortError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionTimeIntervalTooShortError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionTimeIntervalNotMinuteAlignedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: RedundantDocumentPaidForByTokenWithContractId (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: GroupHasTooFewMembersError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidKeyPurposeForContractBoundsError (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod group { pub mod group_action_not_allowed_on_transition_error { use crate as example_platform ; # [doc = "FFI-representation of the [`GroupActionNotAllowedOnTransitionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError { pub transition_type : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: group :: group_action_not_allowed_on_transition_error :: GroupActionNotAllowedOnTransitionError > for dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError) -> dpp :: errors :: consensus :: basic :: group :: group_action_not_allowed_on_transition_error :: GroupActionNotAllowedOnTransitionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: group :: group_action_not_allowed_on_transition_error :: GroupActionNotAllowedOnTransitionError { transition_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . transition_type) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: group :: group_action_not_allowed_on_transition_error :: GroupActionNotAllowedOnTransitionError > for dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: group :: group_action_not_allowed_on_transition_error :: GroupActionNotAllowedOnTransitionError) -> * const dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError { ferment :: boxed (dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError { transition_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . transition_type) }) } } impl Drop for dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . transition_type) ; } } } } } pub mod invalid_identifier_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidIdentifierError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError { pub identifier_name : * mut std :: os :: raw :: c_char , pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: invalid_identifier_error :: InvalidIdentifierError > for dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError) -> dpp :: errors :: consensus :: basic :: invalid_identifier_error :: InvalidIdentifierError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: invalid_identifier_error :: InvalidIdentifierError { identifier_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . identifier_name) , message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: invalid_identifier_error :: InvalidIdentifierError > for dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: invalid_identifier_error :: InvalidIdentifierError) -> * const dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError { ferment :: boxed (dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError { identifier_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . identifier_name) , message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . identifier_name) ; ferment :: unbox_string (ffi_ref . message) ; } } } } pub mod json_schema_compilation_error { use crate as example_platform ; # [doc = "FFI-representation of the [`JsonSchemaCompilationError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError { pub compilation_error : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: json_schema_compilation_error :: JsonSchemaCompilationError > for dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError) -> dpp :: errors :: consensus :: basic :: json_schema_compilation_error :: JsonSchemaCompilationError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: json_schema_compilation_error :: JsonSchemaCompilationError { compilation_error : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . compilation_error) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: json_schema_compilation_error :: JsonSchemaCompilationError > for dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: json_schema_compilation_error :: JsonSchemaCompilationError) -> * const dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError { ferment :: boxed (dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError { compilation_error : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . compilation_error) }) } } impl Drop for dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . compilation_error) ; } } } } pub mod json_schema_error { pub mod error { use crate as example_platform ; # [doc = "FFI-representation of the [`JsonSchemaError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError { pub error_summary : * mut std :: os :: raw :: c_char , pub keyword : * mut std :: os :: raw :: c_char , pub instance_path : * mut std :: os :: raw :: c_char , pub schema_path : * mut std :: os :: raw :: c_char , pub params : * mut crate :: fermented :: types :: platform_value :: platform_value_Value , pub property_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: json_schema_error :: error :: JsonSchemaError > for dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError) -> dpp :: errors :: consensus :: basic :: json_schema_error :: error :: JsonSchemaError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: json_schema_error :: error :: JsonSchemaError { error_summary : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . error_summary) , keyword : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . keyword) , instance_path : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . instance_path) , schema_path : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . schema_path) , params : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (ffi_ref . params) , property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . property_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: json_schema_error :: error :: JsonSchemaError > for dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: json_schema_error :: error :: JsonSchemaError) -> * const dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError { ferment :: boxed (dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError { error_summary : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . error_summary) , keyword : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . keyword) , instance_path : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . instance_path) , schema_path : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . schema_path) , params : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (obj . params) , property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . property_name) }) } } impl Drop for dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . error_summary) ; ferment :: unbox_string (ffi_ref . keyword) ; ferment :: unbox_string (ffi_ref . instance_path) ; ferment :: unbox_string (ffi_ref . schema_path) ; ferment :: unbox_any (ffi_ref . params) ; ferment :: unbox_string (ffi_ref . property_name) ; } } } } } pub mod overflow_error { use crate as example_platform ; # [doc = "FFI-representation of the [`OverflowError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_overflow_error_OverflowError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: overflow_error :: OverflowError > for dpp_errors_consensus_basic_overflow_error_OverflowError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_overflow_error_OverflowError) -> dpp :: errors :: consensus :: basic :: overflow_error :: OverflowError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: overflow_error :: OverflowError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: overflow_error :: OverflowError > for dpp_errors_consensus_basic_overflow_error_OverflowError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: overflow_error :: OverflowError) -> * const dpp_errors_consensus_basic_overflow_error_OverflowError { ferment :: boxed (dpp_errors_consensus_basic_overflow_error_OverflowError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_basic_overflow_error_OverflowError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } } pub mod state_transition { pub mod invalid_state_transition_type_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidStateTransitionTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError { pub transition_type : u8 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: InvalidStateTransitionTypeError > for dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError) -> dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: InvalidStateTransitionTypeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: InvalidStateTransitionTypeError { transition_type : ffi_ref . transition_type } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: InvalidStateTransitionTypeError > for dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: InvalidStateTransitionTypeError) -> * const dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError { ferment :: boxed (dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError { transition_type : obj . transition_type }) } } } pub mod missing_state_transition_type_error { use crate as example_platform ; # [doc = "FFI-representation of the [`MissingStateTransitionTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: state_transition :: missing_state_transition_type_error :: MissingStateTransitionTypeError > for dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError) -> dpp :: errors :: consensus :: basic :: state_transition :: missing_state_transition_type_error :: MissingStateTransitionTypeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: state_transition :: missing_state_transition_type_error :: MissingStateTransitionTypeError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: state_transition :: missing_state_transition_type_error :: MissingStateTransitionTypeError > for dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: state_transition :: missing_state_transition_type_error :: MissingStateTransitionTypeError) -> * const dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError { ferment :: boxed (dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError { }) } } } pub mod state_transition_max_size_exceeded_error { use crate as example_platform ; # [doc = "FFI-representation of the [`StateTransitionMaxSizeExceededError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError { pub actual_size_bytes : u64 , pub max_size_bytes : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: state_transition :: state_transition_max_size_exceeded_error :: StateTransitionMaxSizeExceededError > for dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError) -> dpp :: errors :: consensus :: basic :: state_transition :: state_transition_max_size_exceeded_error :: StateTransitionMaxSizeExceededError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: state_transition :: state_transition_max_size_exceeded_error :: StateTransitionMaxSizeExceededError { actual_size_bytes : ffi_ref . actual_size_bytes , max_size_bytes : ffi_ref . max_size_bytes } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: state_transition :: state_transition_max_size_exceeded_error :: StateTransitionMaxSizeExceededError > for dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: state_transition :: state_transition_max_size_exceeded_error :: StateTransitionMaxSizeExceededError) -> * const dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError { ferment :: boxed (dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError { actual_size_bytes : obj . actual_size_bytes , max_size_bytes : obj . max_size_bytes }) } } } } pub mod unsupported_feature_error { use crate as example_platform ; # [doc = "FFI-representation of the [`UnsupportedFeatureError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError { pub feature_name : * mut std :: os :: raw :: c_char , pub current_protocol_version : u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: unsupported_feature_error :: UnsupportedFeatureError > for dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError) -> dpp :: errors :: consensus :: basic :: unsupported_feature_error :: UnsupportedFeatureError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: unsupported_feature_error :: UnsupportedFeatureError { feature_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . feature_name) , current_protocol_version : ffi_ref . current_protocol_version } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: unsupported_feature_error :: UnsupportedFeatureError > for dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: unsupported_feature_error :: UnsupportedFeatureError) -> * const dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError { ferment :: boxed (dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError { feature_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . feature_name) , current_protocol_version : obj . current_protocol_version }) } } impl Drop for dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . feature_name) ; ; } } } } pub mod unsupported_version_error { use crate as example_platform ; # [doc = "FFI-representation of the [`UnsupportedVersionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError { pub received_version : u16 , pub min_version : u16 , pub max_version : u16 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: unsupported_version_error :: UnsupportedVersionError > for dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError) -> dpp :: errors :: consensus :: basic :: unsupported_version_error :: UnsupportedVersionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: unsupported_version_error :: UnsupportedVersionError { received_version : ffi_ref . received_version , min_version : ffi_ref . min_version , max_version : ffi_ref . max_version } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: unsupported_version_error :: UnsupportedVersionError > for dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: unsupported_version_error :: UnsupportedVersionError) -> * const dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError { ferment :: boxed (dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError { received_version : obj . received_version , min_version : obj . min_version , max_version : obj . max_version }) } } } pub mod value_error { use crate as example_platform ; # [doc = "FFI-representation of the [`ValueError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_value_error_ValueError { pub value_error : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: value_error :: ValueError > for dpp_errors_consensus_basic_value_error_ValueError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_value_error_ValueError) -> dpp :: errors :: consensus :: basic :: value_error :: ValueError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: value_error :: ValueError { value_error : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . value_error) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: value_error :: ValueError > for dpp_errors_consensus_basic_value_error_ValueError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: value_error :: ValueError) -> * const dpp_errors_consensus_basic_value_error_ValueError { ferment :: boxed (dpp_errors_consensus_basic_value_error_ValueError { value_error : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . value_error) }) } } impl Drop for dpp_errors_consensus_basic_value_error_ValueError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . value_error) ; } } } } } pub mod consensus_error { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ConsensusError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_errors_consensus_consensus_error_ConsensusError { DefaultError , BasicError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: basic_error :: dpp_errors_consensus_basic_basic_error_BasicError) , StateError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: state_error :: dpp_errors_consensus_state_state_error_StateError) , SignatureError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: signature_error :: dpp_errors_consensus_signature_signature_error_SignatureError) , FeeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: fee :: fee_error :: dpp_errors_consensus_fee_fee_error_FeeError) , # [cfg (test)] TestConsensusError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: test_consensus_error :: dpp_errors_consensus_test_consensus_error_TestConsensusError) } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: consensus_error :: ConsensusError > for dpp_errors_consensus_consensus_error_ConsensusError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_consensus_error_ConsensusError) -> dpp :: errors :: consensus :: consensus_error :: ConsensusError { let ffi_ref = & * ffi ; match ffi_ref { dpp_errors_consensus_consensus_error_ConsensusError :: DefaultError => dpp :: errors :: consensus :: consensus_error :: ConsensusError :: DefaultError , dpp_errors_consensus_consensus_error_ConsensusError :: BasicError (o_0) => dpp :: errors :: consensus :: consensus_error :: ConsensusError :: BasicError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: basic_error :: dpp_errors_consensus_basic_basic_error_BasicError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: basic_error :: BasicError >> :: ffi_from (* o_0)) , dpp_errors_consensus_consensus_error_ConsensusError :: StateError (o_0) => dpp :: errors :: consensus :: consensus_error :: ConsensusError :: StateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: state_error :: dpp_errors_consensus_state_state_error_StateError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: state_error :: StateError >> :: ffi_from (* o_0)) , dpp_errors_consensus_consensus_error_ConsensusError :: SignatureError (o_0) => dpp :: errors :: consensus :: consensus_error :: ConsensusError :: SignatureError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: signature_error :: dpp_errors_consensus_signature_signature_error_SignatureError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: signature_error :: SignatureError >> :: ffi_from (* o_0)) , dpp_errors_consensus_consensus_error_ConsensusError :: FeeError (o_0) => dpp :: errors :: consensus :: consensus_error :: ConsensusError :: FeeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: fee :: fee_error :: dpp_errors_consensus_fee_fee_error_FeeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: fee :: fee_error :: FeeError >> :: ffi_from (* o_0)) , # [cfg (test)] dpp_errors_consensus_consensus_error_ConsensusError :: TestConsensusError (o_0) => dpp :: errors :: consensus :: consensus_error :: ConsensusError :: TestConsensusError (< crate :: fermented :: types :: dpp :: errors :: consensus :: test_consensus_error :: dpp_errors_consensus_test_consensus_error_TestConsensusError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: test_consensus_error :: TestConsensusError >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: consensus_error :: ConsensusError > for dpp_errors_consensus_consensus_error_ConsensusError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: consensus_error :: ConsensusError) -> * const dpp_errors_consensus_consensus_error_ConsensusError { ferment :: boxed (match obj { dpp :: errors :: consensus :: consensus_error :: ConsensusError :: DefaultError => dpp_errors_consensus_consensus_error_ConsensusError :: DefaultError , dpp :: errors :: consensus :: consensus_error :: ConsensusError :: BasicError (o_0) => dpp_errors_consensus_consensus_error_ConsensusError :: BasicError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: basic_error :: dpp_errors_consensus_basic_basic_error_BasicError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: basic_error :: BasicError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: consensus_error :: ConsensusError :: StateError (o_0) => dpp_errors_consensus_consensus_error_ConsensusError :: StateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: state_error :: dpp_errors_consensus_state_state_error_StateError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: state_error :: StateError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: consensus_error :: ConsensusError :: SignatureError (o_0) => dpp_errors_consensus_consensus_error_ConsensusError :: SignatureError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: signature_error :: dpp_errors_consensus_signature_signature_error_SignatureError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: signature_error :: SignatureError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: consensus_error :: ConsensusError :: FeeError (o_0) => dpp_errors_consensus_consensus_error_ConsensusError :: FeeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: fee :: fee_error :: dpp_errors_consensus_fee_fee_error_FeeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: fee :: fee_error :: FeeError >> :: ffi_to (o_0)) , # [cfg (test)] dpp :: errors :: consensus :: consensus_error :: ConsensusError :: TestConsensusError (o_0) => dpp_errors_consensus_consensus_error_ConsensusError :: TestConsensusError (< crate :: fermented :: types :: dpp :: errors :: consensus :: test_consensus_error :: dpp_errors_consensus_test_consensus_error_TestConsensusError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: test_consensus_error :: TestConsensusError >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_errors_consensus_consensus_error_ConsensusError { fn drop (& mut self) { unsafe { match self { dpp_errors_consensus_consensus_error_ConsensusError :: DefaultError => { } , dpp_errors_consensus_consensus_error_ConsensusError :: BasicError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_consensus_error_ConsensusError :: StateError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_consensus_error_ConsensusError :: SignatureError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_consensus_error_ConsensusError :: FeeError (o_0) => { ferment :: unbox_any (* o_0) ; } , # [cfg (test)] dpp_errors_consensus_consensus_error_ConsensusError :: TestConsensusError (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod fee { pub mod balance_is_not_enough_error { use crate as example_platform ; # [doc = "FFI-representation of the [`BalanceIsNotEnoughError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError { pub balance : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , pub fee : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: fee :: balance_is_not_enough_error :: BalanceIsNotEnoughError > for dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError) -> dpp :: errors :: consensus :: fee :: balance_is_not_enough_error :: BalanceIsNotEnoughError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: fee :: balance_is_not_enough_error :: BalanceIsNotEnoughError { balance : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . balance) , fee : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . fee) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: fee :: balance_is_not_enough_error :: BalanceIsNotEnoughError > for dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: fee :: balance_is_not_enough_error :: BalanceIsNotEnoughError) -> * const dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError { ferment :: boxed (dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError { balance : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . balance) , fee : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . fee) }) } } impl Drop for dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . balance) ; ferment :: unbox_any (ffi_ref . fee) ; } } } } pub mod fee_error { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`FeeError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_errors_consensus_fee_fee_error_FeeError { BalanceIsNotEnoughError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: fee :: balance_is_not_enough_error :: dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError) } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: fee :: fee_error :: FeeError > for dpp_errors_consensus_fee_fee_error_FeeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_fee_fee_error_FeeError) -> dpp :: errors :: consensus :: fee :: fee_error :: FeeError { let ffi_ref = & * ffi ; match ffi_ref { dpp_errors_consensus_fee_fee_error_FeeError :: BalanceIsNotEnoughError (o_0) => dpp :: errors :: consensus :: fee :: fee_error :: FeeError :: BalanceIsNotEnoughError (< crate :: fermented :: types :: dpp :: errors :: consensus :: fee :: balance_is_not_enough_error :: dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: fee :: balance_is_not_enough_error :: BalanceIsNotEnoughError >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: fee :: fee_error :: FeeError > for dpp_errors_consensus_fee_fee_error_FeeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: fee :: fee_error :: FeeError) -> * const dpp_errors_consensus_fee_fee_error_FeeError { ferment :: boxed (match obj { dpp :: errors :: consensus :: fee :: fee_error :: FeeError :: BalanceIsNotEnoughError (o_0) => dpp_errors_consensus_fee_fee_error_FeeError :: BalanceIsNotEnoughError (< crate :: fermented :: types :: dpp :: errors :: consensus :: fee :: balance_is_not_enough_error :: dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: fee :: balance_is_not_enough_error :: BalanceIsNotEnoughError >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_errors_consensus_fee_fee_error_FeeError { fn drop (& mut self) { unsafe { match self { dpp_errors_consensus_fee_fee_error_FeeError :: BalanceIsNotEnoughError (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } } pub mod signature { pub mod basic_bls_error { use crate as example_platform ; # [doc = "FFI-representation of the [`BasicBLSError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_basic_bls_error_BasicBLSError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: basic_bls_error :: BasicBLSError > for dpp_errors_consensus_signature_basic_bls_error_BasicBLSError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_basic_bls_error_BasicBLSError) -> dpp :: errors :: consensus :: signature :: basic_bls_error :: BasicBLSError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: basic_bls_error :: BasicBLSError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: basic_bls_error :: BasicBLSError > for dpp_errors_consensus_signature_basic_bls_error_BasicBLSError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: basic_bls_error :: BasicBLSError) -> * const dpp_errors_consensus_signature_basic_bls_error_BasicBLSError { ferment :: boxed (dpp_errors_consensus_signature_basic_bls_error_BasicBLSError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_signature_basic_bls_error_BasicBLSError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } } pub mod basic_ecdsa_error { use crate as example_platform ; # [doc = "FFI-representation of the [`BasicECDSAError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: basic_ecdsa_error :: BasicECDSAError > for dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError) -> dpp :: errors :: consensus :: signature :: basic_ecdsa_error :: BasicECDSAError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: basic_ecdsa_error :: BasicECDSAError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: basic_ecdsa_error :: BasicECDSAError > for dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: basic_ecdsa_error :: BasicECDSAError) -> * const dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError { ferment :: boxed (dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } } pub mod identity_not_found_error { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: identity_not_found_error :: IdentityNotFoundError > for dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError) -> dpp :: errors :: consensus :: signature :: identity_not_found_error :: IdentityNotFoundError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: identity_not_found_error :: IdentityNotFoundError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: identity_not_found_error :: IdentityNotFoundError > for dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: identity_not_found_error :: IdentityNotFoundError) -> * const dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError { ferment :: boxed (dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) }) } } impl Drop for dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; } } } } pub mod invalid_identity_public_key_type_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidIdentityPublicKeyTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { pub public_key_type : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError > for dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) -> dpp :: errors :: consensus :: signature :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError { public_key_type : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: key_type :: KeyType >> :: ffi_from (ffi_ref . public_key_type) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError > for dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError) -> * const dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { ferment :: boxed (dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { public_key_type : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: key_type :: KeyType >> :: ffi_to (obj . public_key_type) }) } } impl Drop for dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_type) ; } } } } pub mod invalid_signature_public_key_purpose_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidSignaturePublicKeyPurposeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError { pub public_key_purpose : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose , pub allowed_key_purposes : * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_purpose_Purpose } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: invalid_signature_public_key_purpose_error :: InvalidSignaturePublicKeyPurposeError > for dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError) -> dpp :: errors :: consensus :: signature :: invalid_signature_public_key_purpose_error :: InvalidSignaturePublicKeyPurposeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: invalid_signature_public_key_purpose_error :: InvalidSignaturePublicKeyPurposeError { public_key_purpose : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: purpose :: Purpose >> :: ffi_from (ffi_ref . public_key_purpose) , allowed_key_purposes : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionFrom < Vec < dpp :: identity :: identity_public_key :: purpose :: Purpose > >> :: ffi_from (ffi_ref . allowed_key_purposes) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: invalid_signature_public_key_purpose_error :: InvalidSignaturePublicKeyPurposeError > for dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: invalid_signature_public_key_purpose_error :: InvalidSignaturePublicKeyPurposeError) -> * const dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError { ferment :: boxed (dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError { public_key_purpose : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: purpose :: Purpose >> :: ffi_to (obj . public_key_purpose) , allowed_key_purposes : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionTo < Vec < dpp :: identity :: identity_public_key :: purpose :: Purpose > >> :: ffi_to (obj . allowed_key_purposes) }) } } impl Drop for dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_purpose) ; ferment :: unbox_any (ffi_ref . allowed_key_purposes) ; } } } } pub mod invalid_signature_public_key_security_level_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidSignaturePublicKeySecurityLevelError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError { pub public_key_security_level : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel , pub allowed_key_security_levels : * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_security_level_SecurityLevel } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: InvalidSignaturePublicKeySecurityLevelError > for dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError) -> dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: InvalidSignaturePublicKeySecurityLevelError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: InvalidSignaturePublicKeySecurityLevelError { public_key_security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_from (ffi_ref . public_key_security_level) , allowed_key_security_levels : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionFrom < Vec < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel > >> :: ffi_from (ffi_ref . allowed_key_security_levels) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: InvalidSignaturePublicKeySecurityLevelError > for dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: InvalidSignaturePublicKeySecurityLevelError) -> * const dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError { ferment :: boxed (dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError { public_key_security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_to (obj . public_key_security_level) , allowed_key_security_levels : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionTo < Vec < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel > >> :: ffi_to (obj . allowed_key_security_levels) }) } } impl Drop for dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_security_level) ; ferment :: unbox_any (ffi_ref . allowed_key_security_levels) ; } } } } pub mod invalid_state_transition_signature_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidStateTransitionSignatureError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: invalid_state_transition_signature_error :: InvalidStateTransitionSignatureError > for dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError) -> dpp :: errors :: consensus :: signature :: invalid_state_transition_signature_error :: InvalidStateTransitionSignatureError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: invalid_state_transition_signature_error :: InvalidStateTransitionSignatureError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: invalid_state_transition_signature_error :: InvalidStateTransitionSignatureError > for dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: invalid_state_transition_signature_error :: InvalidStateTransitionSignatureError) -> * const dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError { ferment :: boxed (dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } } pub mod missing_public_key_error { use crate as example_platform ; # [doc = "FFI-representation of the [`MissingPublicKeyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError { pub public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: missing_public_key_error :: MissingPublicKeyError > for dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError) -> dpp :: errors :: consensus :: signature :: missing_public_key_error :: MissingPublicKeyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: missing_public_key_error :: MissingPublicKeyError { public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . public_key_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: missing_public_key_error :: MissingPublicKeyError > for dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: missing_public_key_error :: MissingPublicKeyError) -> * const dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError { ferment :: boxed (dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError { public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . public_key_id) }) } } impl Drop for dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_id) ; } } } } pub mod public_key_is_disabled_error { use crate as example_platform ; # [doc = "FFI-representation of the [`PublicKeyIsDisabledError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError { pub public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: PublicKeyIsDisabledError > for dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError) -> dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: PublicKeyIsDisabledError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: PublicKeyIsDisabledError { public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . public_key_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: PublicKeyIsDisabledError > for dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: PublicKeyIsDisabledError) -> * const dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError { ferment :: boxed (dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError { public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . public_key_id) }) } } impl Drop for dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_id) ; } } } } pub mod public_key_security_level_not_met_error { use crate as example_platform ; # [doc = "FFI-representation of the [`PublicKeySecurityLevelNotMetError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { pub public_key_security_level : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel , pub required_security_level : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError > for dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError) -> dpp :: errors :: consensus :: signature :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError { public_key_security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_from (ffi_ref . public_key_security_level) , required_security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_from (ffi_ref . required_security_level) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError > for dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError) -> * const dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { ferment :: boxed (dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { public_key_security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_to (obj . public_key_security_level) , required_security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_to (obj . required_security_level) }) } } impl Drop for dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_security_level) ; ferment :: unbox_any (ffi_ref . required_security_level) ; } } } } pub mod signature_error { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`SignatureError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_errors_consensus_signature_signature_error_SignatureError { IdentityNotFoundError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: identity_not_found_error :: dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError) , InvalidIdentityPublicKeyTypeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_identity_public_key_type_error :: dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) , InvalidStateTransitionSignatureError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_state_transition_signature_error :: dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError) , MissingPublicKeyError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: missing_public_key_error :: dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError) , InvalidSignaturePublicKeyPurposeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_signature_public_key_purpose_error :: dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError) , InvalidSignaturePublicKeySecurityLevelError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError) , WrongPublicKeyPurposeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: wrong_public_key_purpose_error :: dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError) , PublicKeyIsDisabledError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError) , PublicKeySecurityLevelNotMetError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: public_key_security_level_not_met_error :: dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError) , SignatureShouldNotBePresentError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: signature_should_not_be_present_error :: dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError) , BasicECDSAError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: basic_ecdsa_error :: dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError) , BasicBLSError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: basic_bls_error :: dpp_errors_consensus_signature_basic_bls_error_BasicBLSError) } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: signature_error :: SignatureError > for dpp_errors_consensus_signature_signature_error_SignatureError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_signature_error_SignatureError) -> dpp :: errors :: consensus :: signature :: signature_error :: SignatureError { let ffi_ref = & * ffi ; match ffi_ref { dpp_errors_consensus_signature_signature_error_SignatureError :: IdentityNotFoundError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: IdentityNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: identity_not_found_error :: dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: identity_not_found_error :: IdentityNotFoundError >> :: ffi_from (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidIdentityPublicKeyTypeError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: InvalidIdentityPublicKeyTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_identity_public_key_type_error :: dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError >> :: ffi_from (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidStateTransitionSignatureError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: InvalidStateTransitionSignatureError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_state_transition_signature_error :: dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: invalid_state_transition_signature_error :: InvalidStateTransitionSignatureError >> :: ffi_from (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: MissingPublicKeyError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: MissingPublicKeyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: missing_public_key_error :: dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: missing_public_key_error :: MissingPublicKeyError >> :: ffi_from (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidSignaturePublicKeyPurposeError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: InvalidSignaturePublicKeyPurposeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_signature_public_key_purpose_error :: dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: invalid_signature_public_key_purpose_error :: InvalidSignaturePublicKeyPurposeError >> :: ffi_from (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidSignaturePublicKeySecurityLevelError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: InvalidSignaturePublicKeySecurityLevelError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: InvalidSignaturePublicKeySecurityLevelError >> :: ffi_from (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: WrongPublicKeyPurposeError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: WrongPublicKeyPurposeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: wrong_public_key_purpose_error :: dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError >> :: ffi_from (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: PublicKeyIsDisabledError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: PublicKeyIsDisabledError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: PublicKeyIsDisabledError >> :: ffi_from (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: PublicKeySecurityLevelNotMetError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: PublicKeySecurityLevelNotMetError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: public_key_security_level_not_met_error :: dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError >> :: ffi_from (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: SignatureShouldNotBePresentError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: SignatureShouldNotBePresentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: signature_should_not_be_present_error :: dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: signature_should_not_be_present_error :: SignatureShouldNotBePresentError >> :: ffi_from (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: BasicECDSAError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: BasicECDSAError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: basic_ecdsa_error :: dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: basic_ecdsa_error :: BasicECDSAError >> :: ffi_from (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: BasicBLSError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: BasicBLSError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: basic_bls_error :: dpp_errors_consensus_signature_basic_bls_error_BasicBLSError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: basic_bls_error :: BasicBLSError >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: signature_error :: SignatureError > for dpp_errors_consensus_signature_signature_error_SignatureError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: signature_error :: SignatureError) -> * const dpp_errors_consensus_signature_signature_error_SignatureError { ferment :: boxed (match obj { dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: IdentityNotFoundError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: IdentityNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: identity_not_found_error :: dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: identity_not_found_error :: IdentityNotFoundError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: InvalidIdentityPublicKeyTypeError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidIdentityPublicKeyTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_identity_public_key_type_error :: dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: InvalidStateTransitionSignatureError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidStateTransitionSignatureError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_state_transition_signature_error :: dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: invalid_state_transition_signature_error :: InvalidStateTransitionSignatureError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: MissingPublicKeyError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: MissingPublicKeyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: missing_public_key_error :: dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: missing_public_key_error :: MissingPublicKeyError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: InvalidSignaturePublicKeyPurposeError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidSignaturePublicKeyPurposeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_signature_public_key_purpose_error :: dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: invalid_signature_public_key_purpose_error :: InvalidSignaturePublicKeyPurposeError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: InvalidSignaturePublicKeySecurityLevelError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidSignaturePublicKeySecurityLevelError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: InvalidSignaturePublicKeySecurityLevelError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: WrongPublicKeyPurposeError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: WrongPublicKeyPurposeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: wrong_public_key_purpose_error :: dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: PublicKeyIsDisabledError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: PublicKeyIsDisabledError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: PublicKeyIsDisabledError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: PublicKeySecurityLevelNotMetError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: PublicKeySecurityLevelNotMetError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: public_key_security_level_not_met_error :: dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: SignatureShouldNotBePresentError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: SignatureShouldNotBePresentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: signature_should_not_be_present_error :: dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: signature_should_not_be_present_error :: SignatureShouldNotBePresentError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: BasicECDSAError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: BasicECDSAError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: basic_ecdsa_error :: dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: basic_ecdsa_error :: BasicECDSAError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: BasicBLSError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: BasicBLSError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: basic_bls_error :: dpp_errors_consensus_signature_basic_bls_error_BasicBLSError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: basic_bls_error :: BasicBLSError >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_errors_consensus_signature_signature_error_SignatureError { fn drop (& mut self) { unsafe { match self { dpp_errors_consensus_signature_signature_error_SignatureError :: IdentityNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidIdentityPublicKeyTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidStateTransitionSignatureError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: MissingPublicKeyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidSignaturePublicKeyPurposeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidSignaturePublicKeySecurityLevelError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: WrongPublicKeyPurposeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: PublicKeyIsDisabledError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: PublicKeySecurityLevelNotMetError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: SignatureShouldNotBePresentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: BasicECDSAError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: BasicBLSError (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod signature_should_not_be_present_error { use crate as example_platform ; # [doc = "FFI-representation of the [`SignatureShouldNotBePresentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: signature_should_not_be_present_error :: SignatureShouldNotBePresentError > for dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError) -> dpp :: errors :: consensus :: signature :: signature_should_not_be_present_error :: SignatureShouldNotBePresentError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: signature_should_not_be_present_error :: SignatureShouldNotBePresentError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: signature_should_not_be_present_error :: SignatureShouldNotBePresentError > for dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: signature_should_not_be_present_error :: SignatureShouldNotBePresentError) -> * const dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError { ferment :: boxed (dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } } pub mod wrong_public_key_purpose_error { use crate as example_platform ; # [doc = "FFI-representation of the [`WrongPublicKeyPurposeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { pub public_key_purpose : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose , pub allowed_key_purposes : * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_purpose_Purpose } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError > for dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError) -> dpp :: errors :: consensus :: signature :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError { public_key_purpose : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: purpose :: Purpose >> :: ffi_from (ffi_ref . public_key_purpose) , allowed_key_purposes : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionFrom < Vec < dpp :: identity :: identity_public_key :: purpose :: Purpose > >> :: ffi_from (ffi_ref . allowed_key_purposes) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError > for dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError) -> * const dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { ferment :: boxed (dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { public_key_purpose : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: purpose :: Purpose >> :: ffi_to (obj . public_key_purpose) , allowed_key_purposes : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionTo < Vec < dpp :: identity :: identity_public_key :: purpose :: Purpose > >> :: ffi_to (obj . allowed_key_purposes) }) } } impl Drop for dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_purpose) ; ferment :: unbox_any (ffi_ref . allowed_key_purposes) ; } } } } } pub mod state { pub mod data_contract { pub mod data_contract_already_present_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DataContractAlreadyPresentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: data_contract_already_present_error :: DataContractAlreadyPresentError > for dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError) -> dpp :: errors :: consensus :: state :: data_contract :: data_contract_already_present_error :: DataContractAlreadyPresentError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: data_contract :: data_contract_already_present_error :: DataContractAlreadyPresentError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: data_contract_already_present_error :: DataContractAlreadyPresentError > for dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: data_contract :: data_contract_already_present_error :: DataContractAlreadyPresentError) -> * const dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError { ferment :: boxed (dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) }) } } impl Drop for dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; } } } } pub mod data_contract_config_update_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DataContractConfigUpdateError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub additional_message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: data_contract_config_update_error :: DataContractConfigUpdateError > for dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError) -> dpp :: errors :: consensus :: state :: data_contract :: data_contract_config_update_error :: DataContractConfigUpdateError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: data_contract :: data_contract_config_update_error :: DataContractConfigUpdateError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , additional_message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . additional_message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: data_contract_config_update_error :: DataContractConfigUpdateError > for dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: data_contract :: data_contract_config_update_error :: DataContractConfigUpdateError) -> * const dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError { ferment :: boxed (dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , additional_message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . additional_message) }) } } impl Drop for dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_string (ffi_ref . additional_message) ; } } } } pub mod data_contract_is_readonly_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DataContractIsReadonlyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: data_contract_is_readonly_error :: DataContractIsReadonlyError > for dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError) -> dpp :: errors :: consensus :: state :: data_contract :: data_contract_is_readonly_error :: DataContractIsReadonlyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: data_contract :: data_contract_is_readonly_error :: DataContractIsReadonlyError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: data_contract_is_readonly_error :: DataContractIsReadonlyError > for dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: data_contract :: data_contract_is_readonly_error :: DataContractIsReadonlyError) -> * const dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError { ferment :: boxed (dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) }) } } impl Drop for dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; } } } } pub mod data_contract_not_found_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DataContractNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_data_contract_data_contract_not_found_error_DataContractNotFoundError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: data_contract_not_found_error :: DataContractNotFoundError > for dpp_errors_consensus_state_data_contract_data_contract_not_found_error_DataContractNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_data_contract_data_contract_not_found_error_DataContractNotFoundError) -> dpp :: errors :: consensus :: state :: data_contract :: data_contract_not_found_error :: DataContractNotFoundError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: data_contract :: data_contract_not_found_error :: DataContractNotFoundError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: data_contract_not_found_error :: DataContractNotFoundError > for dpp_errors_consensus_state_data_contract_data_contract_not_found_error_DataContractNotFoundError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: data_contract :: data_contract_not_found_error :: DataContractNotFoundError) -> * const dpp_errors_consensus_state_data_contract_data_contract_not_found_error_DataContractNotFoundError { ferment :: boxed (dpp_errors_consensus_state_data_contract_data_contract_not_found_error_DataContractNotFoundError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) }) } } impl Drop for dpp_errors_consensus_state_data_contract_data_contract_not_found_error_DataContractNotFoundError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; } } } } pub mod data_contract_update_action_not_allowed_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DataContractUpdateActionNotAllowedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub action : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_action_not_allowed_error :: DataContractUpdateActionNotAllowedError > for dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError) -> dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_action_not_allowed_error :: DataContractUpdateActionNotAllowedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_action_not_allowed_error :: DataContractUpdateActionNotAllowedError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_action_not_allowed_error :: DataContractUpdateActionNotAllowedError > for dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_action_not_allowed_error :: DataContractUpdateActionNotAllowedError) -> * const dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError { ferment :: boxed (dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) }) } } impl Drop for dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_string (ffi_ref . action) ; } } } } pub mod data_contract_update_permission_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DataContractUpdatePermissionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_permission_error :: DataContractUpdatePermissionError > for dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError) -> dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_permission_error :: DataContractUpdatePermissionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_permission_error :: DataContractUpdatePermissionError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_permission_error :: DataContractUpdatePermissionError > for dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_permission_error :: DataContractUpdatePermissionError) -> * const dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError { ferment :: boxed (dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) }) } } impl Drop for dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any (ffi_ref . identity_id) ; } } } } pub mod document_type_update_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DocumentTypeUpdateError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub document_type_name : * mut std :: os :: raw :: c_char , pub additional_message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: document_type_update_error :: DocumentTypeUpdateError > for dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError) -> dpp :: errors :: consensus :: state :: data_contract :: document_type_update_error :: DocumentTypeUpdateError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: data_contract :: document_type_update_error :: DocumentTypeUpdateError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type_name) , additional_message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . additional_message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: document_type_update_error :: DocumentTypeUpdateError > for dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: data_contract :: document_type_update_error :: DocumentTypeUpdateError) -> * const dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError { ferment :: boxed (dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type_name) , additional_message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . additional_message) }) } } impl Drop for dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_string (ffi_ref . document_type_name) ; ferment :: unbox_string (ffi_ref . additional_message) ; } } } } } pub mod data_trigger { use crate as example_platform ; pub mod data_trigger_condition_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DataTriggerConditionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_condition_error :: DataTriggerConditionError > for dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError) -> dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_condition_error :: DataTriggerConditionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_condition_error :: DataTriggerConditionError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . document_id) , message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_condition_error :: DataTriggerConditionError > for dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_condition_error :: DataTriggerConditionError) -> * const dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError { ferment :: boxed (dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . document_id) , message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any (ffi_ref . document_id) ; ferment :: unbox_string (ffi_ref . message) ; } } } } pub mod data_trigger_execution_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DataTriggerExecutionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_execution_error :: DataTriggerExecutionError > for dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError) -> dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_execution_error :: DataTriggerExecutionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_execution_error :: DataTriggerExecutionError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . document_id) , message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_execution_error :: DataTriggerExecutionError > for dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_execution_error :: DataTriggerExecutionError) -> * const dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError { ferment :: boxed (dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . document_id) , message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any (ffi_ref . document_id) ; ferment :: unbox_string (ffi_ref . message) ; } } } } pub mod data_trigger_invalid_result_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DataTriggerInvalidResultError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_invalid_result_error :: DataTriggerInvalidResultError > for dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError) -> dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_invalid_result_error :: DataTriggerInvalidResultError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_invalid_result_error :: DataTriggerInvalidResultError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . document_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_invalid_result_error :: DataTriggerInvalidResultError > for dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_invalid_result_error :: DataTriggerInvalidResultError) -> * const dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError { ferment :: boxed (dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . document_id) }) } } impl Drop for dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any (ffi_ref . document_id) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DataTriggerError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_errors_consensus_state_data_trigger_DataTriggerError { DataTriggerConditionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_condition_error :: dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError) , DataTriggerExecutionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_execution_error :: dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError) , DataTriggerInvalidResultError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_invalid_result_error :: dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError) } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError > for dpp_errors_consensus_state_data_trigger_DataTriggerError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_data_trigger_DataTriggerError) -> dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError { let ffi_ref = & * ffi ; match ffi_ref { dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerConditionError (o_0) => dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError :: DataTriggerConditionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_condition_error :: dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_condition_error :: DataTriggerConditionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerExecutionError (o_0) => dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError :: DataTriggerExecutionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_execution_error :: dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_execution_error :: DataTriggerExecutionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerInvalidResultError (o_0) => dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError :: DataTriggerInvalidResultError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_invalid_result_error :: dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_invalid_result_error :: DataTriggerInvalidResultError >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError > for dpp_errors_consensus_state_data_trigger_DataTriggerError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError) -> * const dpp_errors_consensus_state_data_trigger_DataTriggerError { ferment :: boxed (match obj { dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError :: DataTriggerConditionError (o_0) => dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerConditionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_condition_error :: dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_condition_error :: DataTriggerConditionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError :: DataTriggerExecutionError (o_0) => dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerExecutionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_execution_error :: dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_execution_error :: DataTriggerExecutionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError :: DataTriggerInvalidResultError (o_0) => dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerInvalidResultError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_invalid_result_error :: dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_invalid_result_error :: DataTriggerInvalidResultError >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_errors_consensus_state_data_trigger_DataTriggerError { fn drop (& mut self) { unsafe { match self { dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerConditionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerExecutionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerInvalidResultError (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod document { pub mod document_already_present_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DocumentAlreadyPresentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError { pub document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_already_present_error :: DocumentAlreadyPresentError > for dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError) -> dpp :: errors :: consensus :: state :: document :: document_already_present_error :: DocumentAlreadyPresentError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_already_present_error :: DocumentAlreadyPresentError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . document_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_already_present_error :: DocumentAlreadyPresentError > for dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_already_present_error :: DocumentAlreadyPresentError) -> * const dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError { ferment :: boxed (dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . document_id) }) } } impl Drop for dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; } } } } pub mod document_contest_currently_locked_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DocumentContestCurrentlyLockedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError { pub vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll , pub stored_info : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo , pub unlock_cost : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_contest_currently_locked_error :: DocumentContestCurrentlyLockedError > for dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError) -> dpp :: errors :: consensus :: state :: document :: document_contest_currently_locked_error :: DocumentContestCurrentlyLockedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_contest_currently_locked_error :: DocumentContestCurrentlyLockedError { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll as ferment :: FFIConversionFrom < dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll >> :: ffi_from (ffi_ref . vote_poll) , stored_info : < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo as ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStoredInfo >> :: ffi_from (ffi_ref . stored_info) , unlock_cost : ffi_ref . unlock_cost } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_contest_currently_locked_error :: DocumentContestCurrentlyLockedError > for dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_contest_currently_locked_error :: DocumentContestCurrentlyLockedError) -> * const dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError { ferment :: boxed (dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll as ferment :: FFIConversionTo < dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll >> :: ffi_to (obj . vote_poll) , stored_info : < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo as ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStoredInfo >> :: ffi_to (obj . stored_info) , unlock_cost : obj . unlock_cost }) } } impl Drop for dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . vote_poll) ; ferment :: unbox_any (ffi_ref . stored_info) ; ; } } } } pub mod document_contest_document_with_same_id_already_present_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DocumentContestDocumentWithSameIdAlreadyPresentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError { pub document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_contest_document_with_same_id_already_present_error :: DocumentContestDocumentWithSameIdAlreadyPresentError > for dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError) -> dpp :: errors :: consensus :: state :: document :: document_contest_document_with_same_id_already_present_error :: DocumentContestDocumentWithSameIdAlreadyPresentError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_contest_document_with_same_id_already_present_error :: DocumentContestDocumentWithSameIdAlreadyPresentError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . document_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_contest_document_with_same_id_already_present_error :: DocumentContestDocumentWithSameIdAlreadyPresentError > for dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_contest_document_with_same_id_already_present_error :: DocumentContestDocumentWithSameIdAlreadyPresentError) -> * const dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError { ferment :: boxed (dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . document_id) }) } } impl Drop for dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; } } } } pub mod document_contest_identity_already_contestant { use crate as example_platform ; # [doc = "FFI-representation of the [`DocumentContestIdentityAlreadyContestantError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError { pub vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll , pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_contest_identity_already_contestant :: DocumentContestIdentityAlreadyContestantError > for dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError) -> dpp :: errors :: consensus :: state :: document :: document_contest_identity_already_contestant :: DocumentContestIdentityAlreadyContestantError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_contest_identity_already_contestant :: DocumentContestIdentityAlreadyContestantError { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll as ferment :: FFIConversionFrom < dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll >> :: ffi_from (ffi_ref . vote_poll) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_contest_identity_already_contestant :: DocumentContestIdentityAlreadyContestantError > for dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_contest_identity_already_contestant :: DocumentContestIdentityAlreadyContestantError) -> * const dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError { ferment :: boxed (dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll as ferment :: FFIConversionTo < dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll >> :: ffi_to (obj . vote_poll) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) }) } } impl Drop for dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . vote_poll) ; ferment :: unbox_any (ffi_ref . identity_id) ; } } } } pub mod document_contest_not_joinable_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DocumentContestNotJoinableError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError { pub vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll , pub stored_info : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo , pub start_time : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis , pub current_time : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis , pub joinable_time : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_contest_not_joinable_error :: DocumentContestNotJoinableError > for dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError) -> dpp :: errors :: consensus :: state :: document :: document_contest_not_joinable_error :: DocumentContestNotJoinableError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_contest_not_joinable_error :: DocumentContestNotJoinableError { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll as ferment :: FFIConversionFrom < dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll >> :: ffi_from (ffi_ref . vote_poll) , stored_info : < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo as ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStoredInfo >> :: ffi_from (ffi_ref . stored_info) , start_time : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionFrom < dpp :: prelude :: TimestampMillis >> :: ffi_from (ffi_ref . start_time) , current_time : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionFrom < dpp :: prelude :: TimestampMillis >> :: ffi_from (ffi_ref . current_time) , joinable_time : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionFrom < dpp :: prelude :: TimestampMillis >> :: ffi_from (ffi_ref . joinable_time) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_contest_not_joinable_error :: DocumentContestNotJoinableError > for dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_contest_not_joinable_error :: DocumentContestNotJoinableError) -> * const dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError { ferment :: boxed (dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll as ferment :: FFIConversionTo < dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll >> :: ffi_to (obj . vote_poll) , stored_info : < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo as ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStoredInfo >> :: ffi_to (obj . stored_info) , start_time : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionTo < dpp :: prelude :: TimestampMillis >> :: ffi_to (obj . start_time) , current_time : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionTo < dpp :: prelude :: TimestampMillis >> :: ffi_to (obj . current_time) , joinable_time : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionTo < dpp :: prelude :: TimestampMillis >> :: ffi_to (obj . joinable_time) }) } } impl Drop for dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . vote_poll) ; ferment :: unbox_any (ffi_ref . stored_info) ; ferment :: unbox_any (ffi_ref . start_time) ; ferment :: unbox_any (ffi_ref . current_time) ; ferment :: unbox_any (ffi_ref . joinable_time) ; } } } } pub mod document_contest_not_paid_for_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DocumentContestNotPaidForError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError { pub document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub expected_amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , pub paid_amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_contest_not_paid_for_error :: DocumentContestNotPaidForError > for dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError) -> dpp :: errors :: consensus :: state :: document :: document_contest_not_paid_for_error :: DocumentContestNotPaidForError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_contest_not_paid_for_error :: DocumentContestNotPaidForError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . document_id) , expected_amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . expected_amount) , paid_amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . paid_amount) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_contest_not_paid_for_error :: DocumentContestNotPaidForError > for dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_contest_not_paid_for_error :: DocumentContestNotPaidForError) -> * const dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError { ferment :: boxed (dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . document_id) , expected_amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . expected_amount) , paid_amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . paid_amount) }) } } impl Drop for dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; ferment :: unbox_any (ffi_ref . expected_amount) ; ferment :: unbox_any (ffi_ref . paid_amount) ; } } } } pub mod document_incorrect_purchase_price_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DocumentIncorrectPurchasePriceError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError { pub document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub trying_to_purchase_at_price : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , pub actual_price : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_incorrect_purchase_price_error :: DocumentIncorrectPurchasePriceError > for dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError) -> dpp :: errors :: consensus :: state :: document :: document_incorrect_purchase_price_error :: DocumentIncorrectPurchasePriceError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_incorrect_purchase_price_error :: DocumentIncorrectPurchasePriceError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . document_id) , trying_to_purchase_at_price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . trying_to_purchase_at_price) , actual_price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . actual_price) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_incorrect_purchase_price_error :: DocumentIncorrectPurchasePriceError > for dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_incorrect_purchase_price_error :: DocumentIncorrectPurchasePriceError) -> * const dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError { ferment :: boxed (dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . document_id) , trying_to_purchase_at_price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . trying_to_purchase_at_price) , actual_price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . actual_price) }) } } impl Drop for dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; ferment :: unbox_any (ffi_ref . trying_to_purchase_at_price) ; ferment :: unbox_any (ffi_ref . actual_price) ; } } } } pub mod document_not_for_sale_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DocumentNotForSaleError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError { pub document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_not_for_sale_error :: DocumentNotForSaleError > for dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError) -> dpp :: errors :: consensus :: state :: document :: document_not_for_sale_error :: DocumentNotForSaleError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_not_for_sale_error :: DocumentNotForSaleError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . document_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_not_for_sale_error :: DocumentNotForSaleError > for dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_not_for_sale_error :: DocumentNotForSaleError) -> * const dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError { ferment :: boxed (dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . document_id) }) } } impl Drop for dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; } } } } pub mod document_not_found_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DocumentNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError { pub document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_not_found_error :: DocumentNotFoundError > for dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError) -> dpp :: errors :: consensus :: state :: document :: document_not_found_error :: DocumentNotFoundError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_not_found_error :: DocumentNotFoundError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . document_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_not_found_error :: DocumentNotFoundError > for dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_not_found_error :: DocumentNotFoundError) -> * const dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError { ferment :: boxed (dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . document_id) }) } } impl Drop for dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; } } } } pub mod document_owner_id_mismatch_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DocumentOwnerIdMismatchError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError { pub document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub document_owner_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub existing_document_owner_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_owner_id_mismatch_error :: DocumentOwnerIdMismatchError > for dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError) -> dpp :: errors :: consensus :: state :: document :: document_owner_id_mismatch_error :: DocumentOwnerIdMismatchError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_owner_id_mismatch_error :: DocumentOwnerIdMismatchError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . document_id) , document_owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . document_owner_id) , existing_document_owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . existing_document_owner_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_owner_id_mismatch_error :: DocumentOwnerIdMismatchError > for dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_owner_id_mismatch_error :: DocumentOwnerIdMismatchError) -> * const dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError { ferment :: boxed (dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . document_id) , document_owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . document_owner_id) , existing_document_owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . existing_document_owner_id) }) } } impl Drop for dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; ferment :: unbox_any (ffi_ref . document_owner_id) ; ferment :: unbox_any (ffi_ref . existing_document_owner_id) ; } } } } pub mod document_timestamp_window_violation_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DocumentTimestampWindowViolationError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError { pub timestamp_name : * mut std :: os :: raw :: c_char , pub document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub timestamp : i64 , pub time_window_start : i64 , pub time_window_end : i64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_timestamp_window_violation_error :: DocumentTimestampWindowViolationError > for dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError) -> dpp :: errors :: consensus :: state :: document :: document_timestamp_window_violation_error :: DocumentTimestampWindowViolationError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_timestamp_window_violation_error :: DocumentTimestampWindowViolationError { timestamp_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . timestamp_name) , document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . document_id) , timestamp : ffi_ref . timestamp , time_window_start : ffi_ref . time_window_start , time_window_end : ffi_ref . time_window_end } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_timestamp_window_violation_error :: DocumentTimestampWindowViolationError > for dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_timestamp_window_violation_error :: DocumentTimestampWindowViolationError) -> * const dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError { ferment :: boxed (dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError { timestamp_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . timestamp_name) , document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . document_id) , timestamp : obj . timestamp , time_window_start : obj . time_window_start , time_window_end : obj . time_window_end }) } } impl Drop for dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . timestamp_name) ; ferment :: unbox_any (ffi_ref . document_id) ; ; ; ; } } } } pub mod document_timestamps_are_equal_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DocumentTimestampsAreEqualError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError { pub document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_timestamps_are_equal_error :: DocumentTimestampsAreEqualError > for dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError) -> dpp :: errors :: consensus :: state :: document :: document_timestamps_are_equal_error :: DocumentTimestampsAreEqualError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_timestamps_are_equal_error :: DocumentTimestampsAreEqualError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . document_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_timestamps_are_equal_error :: DocumentTimestampsAreEqualError > for dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_timestamps_are_equal_error :: DocumentTimestampsAreEqualError) -> * const dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError { ferment :: boxed (dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . document_id) }) } } impl Drop for dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; } } } } pub mod document_timestamps_mismatch_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DocumentTimestampsMismatchError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError { pub document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_timestamps_mismatch_error :: DocumentTimestampsMismatchError > for dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError) -> dpp :: errors :: consensus :: state :: document :: document_timestamps_mismatch_error :: DocumentTimestampsMismatchError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_timestamps_mismatch_error :: DocumentTimestampsMismatchError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . document_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_timestamps_mismatch_error :: DocumentTimestampsMismatchError > for dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_timestamps_mismatch_error :: DocumentTimestampsMismatchError) -> * const dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError { ferment :: boxed (dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . document_id) }) } } impl Drop for dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; } } } } pub mod duplicate_unique_index_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DuplicateUniqueIndexError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError { pub document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub duplicating_properties : * mut crate :: fermented :: generics :: Vec_String } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: duplicate_unique_index_error :: DuplicateUniqueIndexError > for dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError) -> dpp :: errors :: consensus :: state :: document :: duplicate_unique_index_error :: DuplicateUniqueIndexError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: duplicate_unique_index_error :: DuplicateUniqueIndexError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . document_id) , duplicating_properties : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionFrom < Vec < String > >> :: ffi_from (ffi_ref . duplicating_properties) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: duplicate_unique_index_error :: DuplicateUniqueIndexError > for dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: duplicate_unique_index_error :: DuplicateUniqueIndexError) -> * const dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError { ferment :: boxed (dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . document_id) , duplicating_properties : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionTo < Vec < String > >> :: ffi_to (obj . duplicating_properties) }) } } impl Drop for dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; ferment :: unbox_any (ffi_ref . duplicating_properties) ; } } } } pub mod invalid_document_revision_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidDocumentRevisionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError { pub document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub previous_revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , pub desired_revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: invalid_document_revision_error :: InvalidDocumentRevisionError > for dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError) -> dpp :: errors :: consensus :: state :: document :: invalid_document_revision_error :: InvalidDocumentRevisionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: invalid_document_revision_error :: InvalidDocumentRevisionError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . document_id) , previous_revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from_opt (ffi_ref . previous_revision) , desired_revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from (ffi_ref . desired_revision) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: invalid_document_revision_error :: InvalidDocumentRevisionError > for dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: invalid_document_revision_error :: InvalidDocumentRevisionError) -> * const dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError { ferment :: boxed (dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . document_id) , previous_revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to_opt (obj . previous_revision) , desired_revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to (obj . desired_revision) }) } } impl Drop for dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; ferment :: unbox_any_opt (ffi_ref . previous_revision) ; ferment :: unbox_any (ffi_ref . desired_revision) ; } } } } } pub mod group { pub mod group_action_already_completed_error { use crate as example_platform ; # [doc = "FFI-representation of the [`GroupActionAlreadyCompletedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub group_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , pub action_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: group :: group_action_already_completed_error :: GroupActionAlreadyCompletedError > for dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError) -> dpp :: errors :: consensus :: state :: group :: group_action_already_completed_error :: GroupActionAlreadyCompletedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: group :: group_action_already_completed_error :: GroupActionAlreadyCompletedError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (ffi_ref . group_contract_position) , action_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . action_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: group :: group_action_already_completed_error :: GroupActionAlreadyCompletedError > for dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: group :: group_action_already_completed_error :: GroupActionAlreadyCompletedError) -> * const dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError { ferment :: boxed (dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (obj . group_contract_position) , action_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . action_id) }) } } impl Drop for dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any (ffi_ref . group_contract_position) ; ferment :: unbox_any (ffi_ref . action_id) ; } } } } pub mod group_action_already_signed_by_identity_error { use crate as example_platform ; # [doc = "FFI-representation of the [`GroupActionAlreadySignedByIdentityError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub group_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , pub action_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: group :: group_action_already_signed_by_identity_error :: GroupActionAlreadySignedByIdentityError > for dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError) -> dpp :: errors :: consensus :: state :: group :: group_action_already_signed_by_identity_error :: GroupActionAlreadySignedByIdentityError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: group :: group_action_already_signed_by_identity_error :: GroupActionAlreadySignedByIdentityError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (ffi_ref . group_contract_position) , action_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . action_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: group :: group_action_already_signed_by_identity_error :: GroupActionAlreadySignedByIdentityError > for dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: group :: group_action_already_signed_by_identity_error :: GroupActionAlreadySignedByIdentityError) -> * const dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError { ferment :: boxed (dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (obj . group_contract_position) , action_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . action_id) }) } } impl Drop for dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any (ffi_ref . group_contract_position) ; ferment :: unbox_any (ffi_ref . action_id) ; } } } } pub mod group_action_does_not_exist_error { use crate as example_platform ; # [doc = "FFI-representation of the [`GroupActionDoesNotExistError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub group_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , pub action_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: group :: group_action_does_not_exist_error :: GroupActionDoesNotExistError > for dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError) -> dpp :: errors :: consensus :: state :: group :: group_action_does_not_exist_error :: GroupActionDoesNotExistError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: group :: group_action_does_not_exist_error :: GroupActionDoesNotExistError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (ffi_ref . group_contract_position) , action_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . action_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: group :: group_action_does_not_exist_error :: GroupActionDoesNotExistError > for dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: group :: group_action_does_not_exist_error :: GroupActionDoesNotExistError) -> * const dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError { ferment :: boxed (dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (obj . group_contract_position) , action_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . action_id) }) } } impl Drop for dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any (ffi_ref . group_contract_position) ; ferment :: unbox_any (ffi_ref . action_id) ; } } } } pub mod identity_not_member_of_group_error { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityNotMemberOfGroupError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub group_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: group :: identity_not_member_of_group_error :: IdentityNotMemberOfGroupError > for dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError) -> dpp :: errors :: consensus :: state :: group :: identity_not_member_of_group_error :: IdentityNotMemberOfGroupError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: group :: identity_not_member_of_group_error :: IdentityNotMemberOfGroupError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (ffi_ref . group_contract_position) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: group :: identity_not_member_of_group_error :: IdentityNotMemberOfGroupError > for dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: group :: identity_not_member_of_group_error :: IdentityNotMemberOfGroupError) -> * const dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError { ferment :: boxed (dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (obj . group_contract_position) }) } } impl Drop for dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any (ffi_ref . group_contract_position) ; } } } } pub mod identity_for_group_not_found_error { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityMemberOfGroupNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError { pub contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub group_position : u16 , pub member_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: group :: identity_for_group_not_found_error :: IdentityMemberOfGroupNotFoundError > for dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError) -> dpp :: errors :: consensus :: state :: group :: identity_for_group_not_found_error :: IdentityMemberOfGroupNotFoundError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: group :: identity_for_group_not_found_error :: IdentityMemberOfGroupNotFoundError { contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . contract_id) , group_position : ffi_ref . group_position , member_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . member_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: group :: identity_for_group_not_found_error :: IdentityMemberOfGroupNotFoundError > for dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: group :: identity_for_group_not_found_error :: IdentityMemberOfGroupNotFoundError) -> * const dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError { ferment :: boxed (dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError { contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . contract_id) , group_position : obj . group_position , member_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . member_id) }) } } impl Drop for dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . contract_id) ; ; ferment :: unbox_any (ffi_ref . member_id) ; } } } } pub mod modification_of_group_action_main_parameters_not_permitted_error { use crate as example_platform ; # [doc = "FFI-representation of the [`ModificationOfGroupActionMainParametersNotPermittedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError { pub original : * mut std :: os :: raw :: c_char , pub modified : * mut std :: os :: raw :: c_char , pub changed_internal_fields : * mut crate :: fermented :: generics :: Vec_String } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: group :: modification_of_group_action_main_parameters_not_permitted_error :: ModificationOfGroupActionMainParametersNotPermittedError > for dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError) -> dpp :: errors :: consensus :: state :: group :: modification_of_group_action_main_parameters_not_permitted_error :: ModificationOfGroupActionMainParametersNotPermittedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: group :: modification_of_group_action_main_parameters_not_permitted_error :: ModificationOfGroupActionMainParametersNotPermittedError { original : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . original) , modified : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . modified) , changed_internal_fields : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionFrom < Vec < String > >> :: ffi_from (ffi_ref . changed_internal_fields) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: group :: modification_of_group_action_main_parameters_not_permitted_error :: ModificationOfGroupActionMainParametersNotPermittedError > for dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: group :: modification_of_group_action_main_parameters_not_permitted_error :: ModificationOfGroupActionMainParametersNotPermittedError) -> * const dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError { ferment :: boxed (dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError { original : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . original) , modified : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . modified) , changed_internal_fields : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionTo < Vec < String > >> :: ffi_to (obj . changed_internal_fields) }) } } impl Drop for dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . original) ; ferment :: unbox_string (ffi_ref . modified) ; ferment :: unbox_any (ffi_ref . changed_internal_fields) ; } } } } } pub mod identity { pub mod duplicated_identity_public_key_id_state_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DuplicatedIdentityPublicKeyIdStateError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError { pub duplicated_ids : * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_id_state_error :: DuplicatedIdentityPublicKeyIdStateError > for dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError) -> dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_id_state_error :: DuplicatedIdentityPublicKeyIdStateError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_id_state_error :: DuplicatedIdentityPublicKeyIdStateError { duplicated_ids : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < Vec < dpp :: identity :: identity_public_key :: KeyID > >> :: ffi_from (ffi_ref . duplicated_ids) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_id_state_error :: DuplicatedIdentityPublicKeyIdStateError > for dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_id_state_error :: DuplicatedIdentityPublicKeyIdStateError) -> * const dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError { ferment :: boxed (dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError { duplicated_ids : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < Vec < dpp :: identity :: identity_public_key :: KeyID > >> :: ffi_to (obj . duplicated_ids) }) } } impl Drop for dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . duplicated_ids) ; } } } } pub mod duplicated_identity_public_key_state_error { use crate as example_platform ; # [doc = "FFI-representation of the [`DuplicatedIdentityPublicKeyStateError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError { pub duplicated_public_key_ids : * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_state_error :: DuplicatedIdentityPublicKeyStateError > for dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError) -> dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_state_error :: DuplicatedIdentityPublicKeyStateError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_state_error :: DuplicatedIdentityPublicKeyStateError { duplicated_public_key_ids : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < Vec < dpp :: identity :: identity_public_key :: KeyID > >> :: ffi_from (ffi_ref . duplicated_public_key_ids) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_state_error :: DuplicatedIdentityPublicKeyStateError > for dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_state_error :: DuplicatedIdentityPublicKeyStateError) -> * const dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError { ferment :: boxed (dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError { duplicated_public_key_ids : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < Vec < dpp :: identity :: identity_public_key :: KeyID > >> :: ffi_to (obj . duplicated_public_key_ids) }) } } impl Drop for dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . duplicated_public_key_ids) ; } } } } pub mod identity_already_exists_error { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityAlreadyExistsError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_already_exists_error :: IdentityAlreadyExistsError > for dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError) -> dpp :: errors :: consensus :: state :: identity :: identity_already_exists_error :: IdentityAlreadyExistsError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: identity_already_exists_error :: IdentityAlreadyExistsError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_already_exists_error :: IdentityAlreadyExistsError > for dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: identity_already_exists_error :: IdentityAlreadyExistsError) -> * const dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError { ferment :: boxed (dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) }) } } impl Drop for dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; } } } } pub mod identity_insufficient_balance_error { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityInsufficientBalanceError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub balance : u64 , pub required_balance : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_insufficient_balance_error :: IdentityInsufficientBalanceError > for dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError) -> dpp :: errors :: consensus :: state :: identity :: identity_insufficient_balance_error :: IdentityInsufficientBalanceError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: identity_insufficient_balance_error :: IdentityInsufficientBalanceError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , balance : ffi_ref . balance , required_balance : ffi_ref . required_balance } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_insufficient_balance_error :: IdentityInsufficientBalanceError > for dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: identity_insufficient_balance_error :: IdentityInsufficientBalanceError) -> * const dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError { ferment :: boxed (dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , balance : obj . balance , required_balance : obj . required_balance }) } } impl Drop for dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; ; ; } } } } pub mod identity_public_key_already_exists_for_unique_contract_bounds_error { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub purpose : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose , pub new_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , pub old_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_public_key_already_exists_for_unique_contract_bounds_error :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError > for dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError) -> dpp :: errors :: consensus :: state :: identity :: identity_public_key_already_exists_for_unique_contract_bounds_error :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: identity_public_key_already_exists_for_unique_contract_bounds_error :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . contract_id) , purpose : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: purpose :: Purpose >> :: ffi_from (ffi_ref . purpose) , new_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . new_key_id) , old_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . old_key_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_public_key_already_exists_for_unique_contract_bounds_error :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError > for dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: identity_public_key_already_exists_for_unique_contract_bounds_error :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError) -> * const dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError { ferment :: boxed (dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . contract_id) , purpose : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: purpose :: Purpose >> :: ffi_to (obj . purpose) , new_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . new_key_id) , old_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . old_key_id) }) } } impl Drop for dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_any (ffi_ref . contract_id) ; ferment :: unbox_any (ffi_ref . purpose) ; ferment :: unbox_any (ffi_ref . new_key_id) ; ferment :: unbox_any (ffi_ref . old_key_id) ; } } } } pub mod identity_public_key_is_disabled_error { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityPublicKeyIsDisabledError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError { pub public_key_index : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_disabled_error :: IdentityPublicKeyIsDisabledError > for dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError) -> dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_disabled_error :: IdentityPublicKeyIsDisabledError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_disabled_error :: IdentityPublicKeyIsDisabledError { public_key_index : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . public_key_index) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_disabled_error :: IdentityPublicKeyIsDisabledError > for dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_disabled_error :: IdentityPublicKeyIsDisabledError) -> * const dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError { ferment :: boxed (dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError { public_key_index : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . public_key_index) }) } } impl Drop for dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_index) ; } } } } pub mod identity_public_key_is_read_only_error { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityPublicKeyIsReadOnlyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError { pub public_key_index : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_read_only_error :: IdentityPublicKeyIsReadOnlyError > for dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError) -> dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_read_only_error :: IdentityPublicKeyIsReadOnlyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_read_only_error :: IdentityPublicKeyIsReadOnlyError { public_key_index : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . public_key_index) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_read_only_error :: IdentityPublicKeyIsReadOnlyError > for dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_read_only_error :: IdentityPublicKeyIsReadOnlyError) -> * const dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError { ferment :: boxed (dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError { public_key_index : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . public_key_index) }) } } impl Drop for dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_index) ; } } } } pub mod invalid_identity_contract_nonce_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidIdentityNonceError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub current_identity_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub setting_identity_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub error : * mut crate :: fermented :: types :: dpp :: identity :: identity_nonce :: dpp_identity_identity_nonce_MergeIdentityNonceResult } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: invalid_identity_contract_nonce_error :: InvalidIdentityNonceError > for dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError) -> dpp :: errors :: consensus :: state :: identity :: invalid_identity_contract_nonce_error :: InvalidIdentityNonceError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: invalid_identity_contract_nonce_error :: InvalidIdentityNonceError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , current_identity_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from_opt (ffi_ref . current_identity_nonce) , setting_identity_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . setting_identity_nonce) , error : < crate :: fermented :: types :: dpp :: identity :: identity_nonce :: dpp_identity_identity_nonce_MergeIdentityNonceResult as ferment :: FFIConversionFrom < dpp :: identity :: identity_nonce :: MergeIdentityNonceResult >> :: ffi_from (ffi_ref . error) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: invalid_identity_contract_nonce_error :: InvalidIdentityNonceError > for dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: invalid_identity_contract_nonce_error :: InvalidIdentityNonceError) -> * const dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError { ferment :: boxed (dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , current_identity_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to_opt (obj . current_identity_nonce) , setting_identity_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . setting_identity_nonce) , error : < crate :: fermented :: types :: dpp :: identity :: identity_nonce :: dpp_identity_identity_nonce_MergeIdentityNonceResult as ferment :: FFIConversionTo < dpp :: identity :: identity_nonce :: MergeIdentityNonceResult >> :: ffi_to (obj . error) }) } } impl Drop for dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_any_opt (ffi_ref . current_identity_nonce) ; ferment :: unbox_any (ffi_ref . setting_identity_nonce) ; ferment :: unbox_any (ffi_ref . error) ; } } } } pub mod invalid_identity_public_key_id_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidIdentityPublicKeyIdError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError { pub id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: invalid_identity_public_key_id_error :: InvalidIdentityPublicKeyIdError > for dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError) -> dpp :: errors :: consensus :: state :: identity :: invalid_identity_public_key_id_error :: InvalidIdentityPublicKeyIdError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: invalid_identity_public_key_id_error :: InvalidIdentityPublicKeyIdError { id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: invalid_identity_public_key_id_error :: InvalidIdentityPublicKeyIdError > for dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: invalid_identity_public_key_id_error :: InvalidIdentityPublicKeyIdError) -> * const dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError { ferment :: boxed (dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError { id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . id) }) } } impl Drop for dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; } } } } pub mod invalid_identity_revision_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidIdentityRevisionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub current_revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: invalid_identity_revision_error :: InvalidIdentityRevisionError > for dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError) -> dpp :: errors :: consensus :: state :: identity :: invalid_identity_revision_error :: InvalidIdentityRevisionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: invalid_identity_revision_error :: InvalidIdentityRevisionError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , current_revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from (ffi_ref . current_revision) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: invalid_identity_revision_error :: InvalidIdentityRevisionError > for dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: invalid_identity_revision_error :: InvalidIdentityRevisionError) -> * const dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError { ferment :: boxed (dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , current_revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to (obj . current_revision) }) } } impl Drop for dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_any (ffi_ref . current_revision) ; } } } } pub mod master_public_key_update_error { use crate as example_platform ; # [doc = "FFI-representation of the [`MasterPublicKeyUpdateError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError { pub adding : usize , pub removing : usize , pub description : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: master_public_key_update_error :: MasterPublicKeyUpdateError > for dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError) -> dpp :: errors :: consensus :: state :: identity :: master_public_key_update_error :: MasterPublicKeyUpdateError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: master_public_key_update_error :: MasterPublicKeyUpdateError { adding : ffi_ref . adding , removing : ffi_ref . removing , description : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . description) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: master_public_key_update_error :: MasterPublicKeyUpdateError > for dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: master_public_key_update_error :: MasterPublicKeyUpdateError) -> * const dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError { ferment :: boxed (dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError { adding : obj . adding , removing : obj . removing , description : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . description) }) } } impl Drop for dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ferment :: unbox_string (ffi_ref . description) ; } } } } pub mod max_identity_public_key_limit_reached_error { use crate as example_platform ; # [doc = "FFI-representation of the [`MaxIdentityPublicKeyLimitReachedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError { pub max_items : usize } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: max_identity_public_key_limit_reached_error :: MaxIdentityPublicKeyLimitReachedError > for dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError) -> dpp :: errors :: consensus :: state :: identity :: max_identity_public_key_limit_reached_error :: MaxIdentityPublicKeyLimitReachedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: max_identity_public_key_limit_reached_error :: MaxIdentityPublicKeyLimitReachedError { max_items : ffi_ref . max_items } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: max_identity_public_key_limit_reached_error :: MaxIdentityPublicKeyLimitReachedError > for dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: max_identity_public_key_limit_reached_error :: MaxIdentityPublicKeyLimitReachedError) -> * const dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError { ferment :: boxed (dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError { max_items : obj . max_items }) } } } pub mod missing_identity_public_key_ids_error { use crate as example_platform ; # [doc = "FFI-representation of the [`MissingIdentityPublicKeyIdsError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError { pub ids : * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: missing_identity_public_key_ids_error :: MissingIdentityPublicKeyIdsError > for dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError) -> dpp :: errors :: consensus :: state :: identity :: missing_identity_public_key_ids_error :: MissingIdentityPublicKeyIdsError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: missing_identity_public_key_ids_error :: MissingIdentityPublicKeyIdsError { ids : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < Vec < dpp :: identity :: identity_public_key :: KeyID > >> :: ffi_from (ffi_ref . ids) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: missing_identity_public_key_ids_error :: MissingIdentityPublicKeyIdsError > for dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: missing_identity_public_key_ids_error :: MissingIdentityPublicKeyIdsError) -> * const dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError { ferment :: boxed (dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError { ids : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < Vec < dpp :: identity :: identity_public_key :: KeyID > >> :: ffi_to (obj . ids) }) } } impl Drop for dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . ids) ; } } } } pub mod missing_transfer_key_error { use crate as example_platform ; # [doc = "FFI-representation of the [`MissingTransferKeyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: missing_transfer_key_error :: MissingTransferKeyError > for dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError) -> dpp :: errors :: consensus :: state :: identity :: missing_transfer_key_error :: MissingTransferKeyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: missing_transfer_key_error :: MissingTransferKeyError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: missing_transfer_key_error :: MissingTransferKeyError > for dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: missing_transfer_key_error :: MissingTransferKeyError) -> * const dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError { ferment :: boxed (dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) }) } } impl Drop for dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; } } } } pub mod no_transfer_key_for_core_withdrawal_available_error { use crate as example_platform ; # [doc = "FFI-representation of the [`NoTransferKeyForCoreWithdrawalAvailableError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: no_transfer_key_for_core_withdrawal_available_error :: NoTransferKeyForCoreWithdrawalAvailableError > for dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError) -> dpp :: errors :: consensus :: state :: identity :: no_transfer_key_for_core_withdrawal_available_error :: NoTransferKeyForCoreWithdrawalAvailableError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: no_transfer_key_for_core_withdrawal_available_error :: NoTransferKeyForCoreWithdrawalAvailableError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: no_transfer_key_for_core_withdrawal_available_error :: NoTransferKeyForCoreWithdrawalAvailableError > for dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: no_transfer_key_for_core_withdrawal_available_error :: NoTransferKeyForCoreWithdrawalAvailableError) -> * const dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError { ferment :: boxed (dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) }) } } impl Drop for dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; } } } } pub mod identity_for_token_configuration_not_found_error { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenConfigurationIdentityContext`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext { ChangeControlRule (* mut std :: os :: raw :: c_char) , DefaultMintingRecipient , PerpetualDistributionRecipient , PreProgrammedDistributionRecipient } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: TokenConfigurationIdentityContext > for dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext) -> dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: TokenConfigurationIdentityContext { let ffi_ref = & * ffi ; match ffi_ref { dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext :: ChangeControlRule (o_0) => dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: TokenConfigurationIdentityContext :: ChangeControlRule (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext :: DefaultMintingRecipient => dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: TokenConfigurationIdentityContext :: DefaultMintingRecipient , dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext :: PerpetualDistributionRecipient => dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: TokenConfigurationIdentityContext :: PerpetualDistributionRecipient , dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext :: PreProgrammedDistributionRecipient => dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: TokenConfigurationIdentityContext :: PreProgrammedDistributionRecipient } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: TokenConfigurationIdentityContext > for dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: TokenConfigurationIdentityContext) -> * const dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext { ferment :: boxed (match obj { dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: TokenConfigurationIdentityContext :: ChangeControlRule (o_0) => dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext :: ChangeControlRule (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: TokenConfigurationIdentityContext :: DefaultMintingRecipient => dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext :: DefaultMintingRecipient , dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: TokenConfigurationIdentityContext :: PerpetualDistributionRecipient => dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext :: PerpetualDistributionRecipient , dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: TokenConfigurationIdentityContext :: PreProgrammedDistributionRecipient => dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext :: PreProgrammedDistributionRecipient , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext { fn drop (& mut self) { unsafe { match self { dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext :: ChangeControlRule (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext :: DefaultMintingRecipient => { } , dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext :: PerpetualDistributionRecipient => { } , dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext :: PreProgrammedDistributionRecipient => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [doc = "FFI-representation of the [`IdentityInTokenConfigurationNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError { pub contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub token_position : u16 , pub context : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext , pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: IdentityInTokenConfigurationNotFoundError > for dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError) -> dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: IdentityInTokenConfigurationNotFoundError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: IdentityInTokenConfigurationNotFoundError { contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . contract_id) , token_position : ffi_ref . token_position , context : < crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: TokenConfigurationIdentityContext >> :: ffi_from (ffi_ref . context) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: IdentityInTokenConfigurationNotFoundError > for dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: IdentityInTokenConfigurationNotFoundError) -> * const dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError { ferment :: boxed (dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError { contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . contract_id) , token_position : obj . token_position , context : < crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: TokenConfigurationIdentityContext >> :: ffi_to (obj . context) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) }) } } impl Drop for dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . contract_id) ; ; ferment :: unbox_any (ffi_ref . context) ; ferment :: unbox_any (ffi_ref . identity_id) ; } } } } pub mod identity_to_freeze_does_not_exist_error { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityToFreezeDoesNotExistError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_identity_to_freeze_does_not_exist_error_IdentityToFreezeDoesNotExistError { pub identity_to_freeze_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_to_freeze_does_not_exist_error :: IdentityToFreezeDoesNotExistError > for dpp_errors_consensus_state_identity_identity_to_freeze_does_not_exist_error_IdentityToFreezeDoesNotExistError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_identity_to_freeze_does_not_exist_error_IdentityToFreezeDoesNotExistError) -> dpp :: errors :: consensus :: state :: identity :: identity_to_freeze_does_not_exist_error :: IdentityToFreezeDoesNotExistError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: identity_to_freeze_does_not_exist_error :: IdentityToFreezeDoesNotExistError { identity_to_freeze_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_to_freeze_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_to_freeze_does_not_exist_error :: IdentityToFreezeDoesNotExistError > for dpp_errors_consensus_state_identity_identity_to_freeze_does_not_exist_error_IdentityToFreezeDoesNotExistError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: identity_to_freeze_does_not_exist_error :: IdentityToFreezeDoesNotExistError) -> * const dpp_errors_consensus_state_identity_identity_to_freeze_does_not_exist_error_IdentityToFreezeDoesNotExistError { ferment :: boxed (dpp_errors_consensus_state_identity_identity_to_freeze_does_not_exist_error_IdentityToFreezeDoesNotExistError { identity_to_freeze_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_to_freeze_id) }) } } impl Drop for dpp_errors_consensus_state_identity_identity_to_freeze_does_not_exist_error_IdentityToFreezeDoesNotExistError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_to_freeze_id) ; } } } } pub mod recipient_identity_does_not_exist_error { use crate as example_platform ; # [doc = "FFI-representation of the [`RecipientIdentityDoesNotExistError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError { pub recipient_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: recipient_identity_does_not_exist_error :: RecipientIdentityDoesNotExistError > for dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError) -> dpp :: errors :: consensus :: state :: identity :: recipient_identity_does_not_exist_error :: RecipientIdentityDoesNotExistError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: recipient_identity_does_not_exist_error :: RecipientIdentityDoesNotExistError { recipient_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . recipient_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: recipient_identity_does_not_exist_error :: RecipientIdentityDoesNotExistError > for dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: recipient_identity_does_not_exist_error :: RecipientIdentityDoesNotExistError) -> * const dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError { ferment :: boxed (dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError { recipient_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . recipient_id) }) } } impl Drop for dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . recipient_id) ; } } } } } pub mod prefunded_specialized_balances { pub mod prefunded_specialized_balance_insufficient_error { use crate as example_platform ; # [doc = "FFI-representation of the [`PrefundedSpecializedBalanceInsufficientError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError { pub balance_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub balance : u64 , pub required_balance : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_insufficient_error :: PrefundedSpecializedBalanceInsufficientError > for dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError) -> dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_insufficient_error :: PrefundedSpecializedBalanceInsufficientError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_insufficient_error :: PrefundedSpecializedBalanceInsufficientError { balance_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . balance_id) , balance : ffi_ref . balance , required_balance : ffi_ref . required_balance } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_insufficient_error :: PrefundedSpecializedBalanceInsufficientError > for dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_insufficient_error :: PrefundedSpecializedBalanceInsufficientError) -> * const dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError { ferment :: boxed (dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError { balance_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . balance_id) , balance : obj . balance , required_balance : obj . required_balance }) } } impl Drop for dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . balance_id) ; ; ; } } } } pub mod prefunded_specialized_balance_not_found_error { use crate as example_platform ; # [doc = "FFI-representation of the [`PrefundedSpecializedBalanceNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError { pub balance_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_not_found_error :: PrefundedSpecializedBalanceNotFoundError > for dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError) -> dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_not_found_error :: PrefundedSpecializedBalanceNotFoundError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_not_found_error :: PrefundedSpecializedBalanceNotFoundError { balance_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . balance_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_not_found_error :: PrefundedSpecializedBalanceNotFoundError > for dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_not_found_error :: PrefundedSpecializedBalanceNotFoundError) -> * const dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError { ferment :: boxed (dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError { balance_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . balance_id) }) } } impl Drop for dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . balance_id) ; } } } } } pub mod state_error { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`StateError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_errors_consensus_state_state_error_StateError { DataContractAlreadyPresentError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_already_present_error :: dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError) , DataTriggerError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_trigger :: dpp_errors_consensus_state_data_trigger_DataTriggerError) , DocumentAlreadyPresentError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_already_present_error :: dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError) , DocumentContestCurrentlyLockedError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_currently_locked_error :: dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError) , DocumentContestNotJoinableError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_not_joinable_error :: dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError) , DocumentContestIdentityAlreadyContestantError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_identity_already_contestant :: dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError) , DocumentContestNotPaidForError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_not_paid_for_error :: dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError) , DocumentContestDocumentWithSameIdAlreadyPresentError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_document_with_same_id_already_present_error :: dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError) , DocumentNotFoundError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_not_found_error :: dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError) , DocumentNotForSaleError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_not_for_sale_error :: dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError) , DocumentIncorrectPurchasePriceError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_incorrect_purchase_price_error :: dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError) , DocumentOwnerIdMismatchError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_owner_id_mismatch_error :: dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError) , DocumentTimestampsMismatchError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_timestamps_mismatch_error :: dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError) , DocumentTimestampWindowViolationError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_timestamp_window_violation_error :: dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError) , DuplicateUniqueIndexError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: duplicate_unique_index_error :: dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError) , InvalidDocumentRevisionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: invalid_document_revision_error :: dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError) , IdentityAlreadyExistsError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_already_exists_error :: dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError) , IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_public_key_already_exists_for_unique_contract_bounds_error :: dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError) , IdentityPublicKeyIsReadOnlyError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_read_only_error :: dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError) , MissingIdentityPublicKeyIdsError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: missing_identity_public_key_ids_error :: dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError) , MissingTransferKeyError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: missing_transfer_key_error :: dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError) , NoTransferKeyForCoreWithdrawalAvailableError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: no_transfer_key_for_core_withdrawal_available_error :: dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError) , InvalidIdentityPublicKeyIdError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: invalid_identity_public_key_id_error :: dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError) , InvalidIdentityRevisionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: invalid_identity_revision_error :: dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError) , InvalidIdentityNonceError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: invalid_identity_contract_nonce_error :: dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError) , MaxIdentityPublicKeyLimitReachedError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: max_identity_public_key_limit_reached_error :: dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError) , DuplicatedIdentityPublicKeyStateError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_state_error :: dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError) , DuplicatedIdentityPublicKeyIdStateError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_id_state_error :: dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError) , IdentityPublicKeyIsDisabledError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_disabled_error :: dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError) , IdentityInsufficientBalanceError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_insufficient_balance_error :: dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError) , DocumentTimestampsAreEqualError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_timestamps_are_equal_error :: dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError) , DataContractIsReadonlyError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_is_readonly_error :: dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError) , DataContractConfigUpdateError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_config_update_error :: dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError) , DocumentTypeUpdateError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: document_type_update_error :: dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError) , PrefundedSpecializedBalanceInsufficientError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_insufficient_error :: dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError) , PrefundedSpecializedBalanceNotFoundError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_not_found_error :: dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError) , DataContractUpdatePermissionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_permission_error :: dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError) , MasternodeNotFoundError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_not_found_error :: dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError) , MasternodeIncorrectVoterIdentityIdError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voter_identity_id_error :: dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError) , MasternodeIncorrectVotingAddressError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voting_address_error :: dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError) , VotePollNotFoundError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: vote_poll_not_found_error :: dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError) , VotePollNotAvailableForVotingError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: vote_poll_not_available_for_voting_error :: dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError) , MasternodeVotedTooManyTimesError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_voted_too_many_times :: dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError) , MasternodeVoteAlreadyPresentError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_vote_already_present_error :: dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError) , RecipientIdentityDoesNotExistError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: recipient_identity_does_not_exist_error :: dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError) , IdentityDoesNotHaveEnoughTokenBalanceError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_does_not_have_enough_token_balance_error :: dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError) , UnauthorizedTokenActionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: unauthorized_token_action_error :: dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError) , IdentityTokenAccountFrozenError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_token_account_frozen_error :: dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError) , IdentityTokenAccountNotFrozenError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_token_account_not_frozen_error :: dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError) , IdentityNotMemberOfGroupError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: identity_not_member_of_group_error :: dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError) , GroupActionDoesNotExistError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: group_action_does_not_exist_error :: dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError) , GroupActionAlreadyCompletedError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: group_action_already_completed_error :: dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError) , GroupActionAlreadySignedByIdentityError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: group_action_already_signed_by_identity_error :: dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError) , DataContractUpdateActionNotAllowedError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_action_not_allowed_error :: dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError) , TokenSettingMaxSupplyToLessThanCurrentSupplyError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_setting_max_supply_to_less_than_current_supply_error :: dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError) , TokenMintPastMaxSupplyError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_mint_past_max_supply_error :: dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError) , InvalidTokenClaimPropertyMismatch (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: invalid_token_claim_property_mismatch :: dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch) , InvalidTokenClaimNoCurrentRewards (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: invalid_token_claim_no_current_rewards :: dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards) , InvalidTokenClaimWrongClaimant (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: invalid_token_claim_wrong_claimant :: dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant) , NewTokensDestinationIdentityDoesNotExistError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: new_tokens_destination_identity_does_not_exist_error :: dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError) , NewAuthorizedActionTakerIdentityDoesNotExistError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_identity_does_not_exist_error :: dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError) , NewAuthorizedActionTakerGroupDoesNotExistError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_group_does_not_exist_error :: dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError) , NewAuthorizedActionTakerMainGroupNotSetError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_main_group_not_set_error :: dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError) , InvalidGroupPositionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: invalid_group_position_error :: dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError) , TokenIsPausedError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_is_paused_error :: dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError) , IdentityTokenAccountAlreadyFrozenError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_token_account_already_frozen_error :: dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError) , TokenAlreadyPausedError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_already_paused_error :: dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError) , TokenNotPausedError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_not_paused_error :: dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError) , TokenTransferRecipientIdentityNotExistError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_transfer_recipient_identity_not_exist_error :: dpp_errors_consensus_state_token_token_transfer_recipient_identity_not_exist_error_TokenTransferRecipientIdentityNotExistError) , PreProgrammedDistributionTimestampInPastError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: pre_programmed_distribution_timestamp_in_past_error :: dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError) , IdentityHasNotAgreedToPayRequiredTokenAmountError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_has_not_agreed_to_pay_required_token_amount_error :: dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError) , RequiredTokenPaymentInfoNotSetError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: required_token_payment_info_not_set_error :: dpp_errors_consensus_state_token_required_token_payment_info_not_set_error_RequiredTokenPaymentInfoNotSetError) , IdentityTryingToPayWithWrongTokenError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_trying_to_pay_with_wrong_token_error :: dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError) , TokenDirectPurchaseUserPriceTooLow (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_direct_purchase_user_price_too_low :: dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow) , TokenAmountUnderMinimumSaleAmount (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_amount_under_minimum_sale_amount :: dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount) , TokenNotForDirectSale (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_not_for_direct_sale :: dpp_errors_consensus_state_token_token_not_for_direct_sale_TokenNotForDirectSale) , IdentityInTokenConfigurationNotFoundError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError) , IdentityMemberOfGroupNotFoundError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: identity_for_group_not_found_error :: dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError) , ModificationOfGroupActionMainParametersNotPermittedError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: modification_of_group_action_main_parameters_not_permitted_error :: dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError) , IdentityToFreezeDoesNotExistError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_to_freeze_does_not_exist_error :: dpp_errors_consensus_state_identity_identity_to_freeze_does_not_exist_error_IdentityToFreezeDoesNotExistError) , DataContractNotFoundError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_not_found_error :: dpp_errors_consensus_state_data_contract_data_contract_not_found_error_DataContractNotFoundError) , InvalidTokenPositionStateError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: invalid_token_position_error :: dpp_errors_consensus_state_token_invalid_token_position_error_InvalidTokenPositionStateError) } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: state_error :: StateError > for dpp_errors_consensus_state_state_error_StateError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_state_error_StateError) -> dpp :: errors :: consensus :: state :: state_error :: StateError { let ffi_ref = & * ffi ; match ffi_ref { dpp_errors_consensus_state_state_error_StateError :: DataContractAlreadyPresentError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractAlreadyPresentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_already_present_error :: dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: data_contract_already_present_error :: DataContractAlreadyPresentError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DataTriggerError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DataTriggerError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_trigger :: dpp_errors_consensus_state_data_trigger_DataTriggerError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentAlreadyPresentError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentAlreadyPresentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_already_present_error :: dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_already_present_error :: DocumentAlreadyPresentError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentContestCurrentlyLockedError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentContestCurrentlyLockedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_currently_locked_error :: dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_contest_currently_locked_error :: DocumentContestCurrentlyLockedError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentContestNotJoinableError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentContestNotJoinableError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_not_joinable_error :: dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_contest_not_joinable_error :: DocumentContestNotJoinableError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentContestIdentityAlreadyContestantError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentContestIdentityAlreadyContestantError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_identity_already_contestant :: dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_contest_identity_already_contestant :: DocumentContestIdentityAlreadyContestantError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentContestNotPaidForError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentContestNotPaidForError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_not_paid_for_error :: dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_contest_not_paid_for_error :: DocumentContestNotPaidForError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentContestDocumentWithSameIdAlreadyPresentError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentContestDocumentWithSameIdAlreadyPresentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_document_with_same_id_already_present_error :: dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_contest_document_with_same_id_already_present_error :: DocumentContestDocumentWithSameIdAlreadyPresentError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentNotFoundError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_not_found_error :: dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_not_found_error :: DocumentNotFoundError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentNotForSaleError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentNotForSaleError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_not_for_sale_error :: dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_not_for_sale_error :: DocumentNotForSaleError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentIncorrectPurchasePriceError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentIncorrectPurchasePriceError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_incorrect_purchase_price_error :: dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_incorrect_purchase_price_error :: DocumentIncorrectPurchasePriceError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentOwnerIdMismatchError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentOwnerIdMismatchError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_owner_id_mismatch_error :: dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_owner_id_mismatch_error :: DocumentOwnerIdMismatchError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampsMismatchError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentTimestampsMismatchError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_timestamps_mismatch_error :: dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_timestamps_mismatch_error :: DocumentTimestampsMismatchError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampWindowViolationError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentTimestampWindowViolationError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_timestamp_window_violation_error :: dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_timestamp_window_violation_error :: DocumentTimestampWindowViolationError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DuplicateUniqueIndexError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DuplicateUniqueIndexError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: duplicate_unique_index_error :: dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: duplicate_unique_index_error :: DuplicateUniqueIndexError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: InvalidDocumentRevisionError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidDocumentRevisionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: invalid_document_revision_error :: dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: invalid_document_revision_error :: InvalidDocumentRevisionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityAlreadyExistsError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityAlreadyExistsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_already_exists_error :: dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_already_exists_error :: IdentityAlreadyExistsError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_public_key_already_exists_for_unique_contract_bounds_error :: dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_public_key_already_exists_for_unique_contract_bounds_error :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyIsReadOnlyError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityPublicKeyIsReadOnlyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_read_only_error :: dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_read_only_error :: IdentityPublicKeyIsReadOnlyError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: MissingIdentityPublicKeyIdsError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: MissingIdentityPublicKeyIdsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: missing_identity_public_key_ids_error :: dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: missing_identity_public_key_ids_error :: MissingIdentityPublicKeyIdsError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: MissingTransferKeyError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: MissingTransferKeyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: missing_transfer_key_error :: dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: missing_transfer_key_error :: MissingTransferKeyError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: NoTransferKeyForCoreWithdrawalAvailableError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: NoTransferKeyForCoreWithdrawalAvailableError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: no_transfer_key_for_core_withdrawal_available_error :: dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: no_transfer_key_for_core_withdrawal_available_error :: NoTransferKeyForCoreWithdrawalAvailableError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityPublicKeyIdError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidIdentityPublicKeyIdError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: invalid_identity_public_key_id_error :: dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: invalid_identity_public_key_id_error :: InvalidIdentityPublicKeyIdError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityRevisionError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidIdentityRevisionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: invalid_identity_revision_error :: dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: invalid_identity_revision_error :: InvalidIdentityRevisionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityNonceError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidIdentityNonceError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: invalid_identity_contract_nonce_error :: dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: invalid_identity_contract_nonce_error :: InvalidIdentityNonceError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: MaxIdentityPublicKeyLimitReachedError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: MaxIdentityPublicKeyLimitReachedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: max_identity_public_key_limit_reached_error :: dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: max_identity_public_key_limit_reached_error :: MaxIdentityPublicKeyLimitReachedError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DuplicatedIdentityPublicKeyStateError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DuplicatedIdentityPublicKeyStateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_state_error :: dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_state_error :: DuplicatedIdentityPublicKeyStateError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DuplicatedIdentityPublicKeyIdStateError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DuplicatedIdentityPublicKeyIdStateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_id_state_error :: dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_id_state_error :: DuplicatedIdentityPublicKeyIdStateError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyIsDisabledError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityPublicKeyIsDisabledError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_disabled_error :: dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_disabled_error :: IdentityPublicKeyIsDisabledError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityInsufficientBalanceError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityInsufficientBalanceError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_insufficient_balance_error :: dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_insufficient_balance_error :: IdentityInsufficientBalanceError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampsAreEqualError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentTimestampsAreEqualError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_timestamps_are_equal_error :: dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_timestamps_are_equal_error :: DocumentTimestampsAreEqualError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DataContractIsReadonlyError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractIsReadonlyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_is_readonly_error :: dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: data_contract_is_readonly_error :: DataContractIsReadonlyError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DataContractConfigUpdateError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractConfigUpdateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_config_update_error :: dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: data_contract_config_update_error :: DataContractConfigUpdateError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentTypeUpdateError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentTypeUpdateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: document_type_update_error :: dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: document_type_update_error :: DocumentTypeUpdateError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: PrefundedSpecializedBalanceInsufficientError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: PrefundedSpecializedBalanceInsufficientError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_insufficient_error :: dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_insufficient_error :: PrefundedSpecializedBalanceInsufficientError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: PrefundedSpecializedBalanceNotFoundError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: PrefundedSpecializedBalanceNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_not_found_error :: dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_not_found_error :: PrefundedSpecializedBalanceNotFoundError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DataContractUpdatePermissionError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractUpdatePermissionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_permission_error :: dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_permission_error :: DataContractUpdatePermissionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: MasternodeNotFoundError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: MasternodeNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_not_found_error :: dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: masternode_not_found_error :: MasternodeNotFoundError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: MasternodeIncorrectVoterIdentityIdError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: MasternodeIncorrectVoterIdentityIdError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voter_identity_id_error :: dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voter_identity_id_error :: MasternodeIncorrectVoterIdentityIdError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: MasternodeIncorrectVotingAddressError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: MasternodeIncorrectVotingAddressError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voting_address_error :: dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voting_address_error :: MasternodeIncorrectVotingAddressError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: VotePollNotFoundError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: VotePollNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: vote_poll_not_found_error :: dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: vote_poll_not_found_error :: VotePollNotFoundError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: VotePollNotAvailableForVotingError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: VotePollNotAvailableForVotingError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: vote_poll_not_available_for_voting_error :: dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: vote_poll_not_available_for_voting_error :: VotePollNotAvailableForVotingError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: MasternodeVotedTooManyTimesError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: MasternodeVotedTooManyTimesError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_voted_too_many_times :: dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: masternode_voted_too_many_times :: MasternodeVotedTooManyTimesError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: MasternodeVoteAlreadyPresentError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: MasternodeVoteAlreadyPresentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_vote_already_present_error :: dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: masternode_vote_already_present_error :: MasternodeVoteAlreadyPresentError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: RecipientIdentityDoesNotExistError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: RecipientIdentityDoesNotExistError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: recipient_identity_does_not_exist_error :: dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: recipient_identity_does_not_exist_error :: RecipientIdentityDoesNotExistError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityDoesNotHaveEnoughTokenBalanceError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityDoesNotHaveEnoughTokenBalanceError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_does_not_have_enough_token_balance_error :: dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: identity_does_not_have_enough_token_balance_error :: IdentityDoesNotHaveEnoughTokenBalanceError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: UnauthorizedTokenActionError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: UnauthorizedTokenActionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: unauthorized_token_action_error :: dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: unauthorized_token_action_error :: UnauthorizedTokenActionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountFrozenError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityTokenAccountFrozenError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_token_account_frozen_error :: dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: identity_token_account_frozen_error :: IdentityTokenAccountFrozenError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountNotFrozenError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityTokenAccountNotFrozenError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_token_account_not_frozen_error :: dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: identity_token_account_not_frozen_error :: IdentityTokenAccountNotFrozenError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityNotMemberOfGroupError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityNotMemberOfGroupError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: identity_not_member_of_group_error :: dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: group :: identity_not_member_of_group_error :: IdentityNotMemberOfGroupError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: GroupActionDoesNotExistError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: GroupActionDoesNotExistError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: group_action_does_not_exist_error :: dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: group :: group_action_does_not_exist_error :: GroupActionDoesNotExistError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: GroupActionAlreadyCompletedError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: GroupActionAlreadyCompletedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: group_action_already_completed_error :: dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: group :: group_action_already_completed_error :: GroupActionAlreadyCompletedError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: GroupActionAlreadySignedByIdentityError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: GroupActionAlreadySignedByIdentityError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: group_action_already_signed_by_identity_error :: dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: group :: group_action_already_signed_by_identity_error :: GroupActionAlreadySignedByIdentityError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DataContractUpdateActionNotAllowedError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractUpdateActionNotAllowedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_action_not_allowed_error :: dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_action_not_allowed_error :: DataContractUpdateActionNotAllowedError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: TokenSettingMaxSupplyToLessThanCurrentSupplyError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenSettingMaxSupplyToLessThanCurrentSupplyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_setting_max_supply_to_less_than_current_supply_error :: dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_setting_max_supply_to_less_than_current_supply_error :: TokenSettingMaxSupplyToLessThanCurrentSupplyError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: TokenMintPastMaxSupplyError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenMintPastMaxSupplyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_mint_past_max_supply_error :: dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_mint_past_max_supply_error :: TokenMintPastMaxSupplyError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimPropertyMismatch (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidTokenClaimPropertyMismatch (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: invalid_token_claim_property_mismatch :: dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: invalid_token_claim_property_mismatch :: InvalidTokenClaimPropertyMismatch >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimNoCurrentRewards (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidTokenClaimNoCurrentRewards (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: invalid_token_claim_no_current_rewards :: dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: invalid_token_claim_no_current_rewards :: InvalidTokenClaimNoCurrentRewards >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimWrongClaimant (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidTokenClaimWrongClaimant (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: invalid_token_claim_wrong_claimant :: dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: invalid_token_claim_wrong_claimant :: InvalidTokenClaimWrongClaimant >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: NewTokensDestinationIdentityDoesNotExistError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: NewTokensDestinationIdentityDoesNotExistError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: new_tokens_destination_identity_does_not_exist_error :: dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: new_tokens_destination_identity_does_not_exist_error :: NewTokensDestinationIdentityDoesNotExistError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerIdentityDoesNotExistError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: NewAuthorizedActionTakerIdentityDoesNotExistError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_identity_does_not_exist_error :: dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_identity_does_not_exist_error :: NewAuthorizedActionTakerIdentityDoesNotExistError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerGroupDoesNotExistError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: NewAuthorizedActionTakerGroupDoesNotExistError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_group_does_not_exist_error :: dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_group_does_not_exist_error :: NewAuthorizedActionTakerGroupDoesNotExistError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerMainGroupNotSetError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: NewAuthorizedActionTakerMainGroupNotSetError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_main_group_not_set_error :: dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_main_group_not_set_error :: NewAuthorizedActionTakerMainGroupNotSetError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: InvalidGroupPositionError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidGroupPositionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: invalid_group_position_error :: dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: invalid_group_position_error :: InvalidGroupPositionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: TokenIsPausedError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenIsPausedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_is_paused_error :: dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_is_paused_error :: TokenIsPausedError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountAlreadyFrozenError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityTokenAccountAlreadyFrozenError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_token_account_already_frozen_error :: dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: identity_token_account_already_frozen_error :: IdentityTokenAccountAlreadyFrozenError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: TokenAlreadyPausedError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenAlreadyPausedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_already_paused_error :: dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_already_paused_error :: TokenAlreadyPausedError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: TokenNotPausedError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenNotPausedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_not_paused_error :: dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_not_paused_error :: TokenNotPausedError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: TokenTransferRecipientIdentityNotExistError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenTransferRecipientIdentityNotExistError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_transfer_recipient_identity_not_exist_error :: dpp_errors_consensus_state_token_token_transfer_recipient_identity_not_exist_error_TokenTransferRecipientIdentityNotExistError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_transfer_recipient_identity_not_exist_error :: TokenTransferRecipientIdentityNotExistError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: PreProgrammedDistributionTimestampInPastError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: PreProgrammedDistributionTimestampInPastError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: pre_programmed_distribution_timestamp_in_past_error :: dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: pre_programmed_distribution_timestamp_in_past_error :: PreProgrammedDistributionTimestampInPastError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityHasNotAgreedToPayRequiredTokenAmountError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityHasNotAgreedToPayRequiredTokenAmountError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_has_not_agreed_to_pay_required_token_amount_error :: dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: identity_has_not_agreed_to_pay_required_token_amount_error :: IdentityHasNotAgreedToPayRequiredTokenAmountError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: RequiredTokenPaymentInfoNotSetError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: RequiredTokenPaymentInfoNotSetError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: required_token_payment_info_not_set_error :: dpp_errors_consensus_state_token_required_token_payment_info_not_set_error_RequiredTokenPaymentInfoNotSetError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: required_token_payment_info_not_set_error :: RequiredTokenPaymentInfoNotSetError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityTryingToPayWithWrongTokenError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityTryingToPayWithWrongTokenError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_trying_to_pay_with_wrong_token_error :: dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: identity_trying_to_pay_with_wrong_token_error :: IdentityTryingToPayWithWrongTokenError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: TokenDirectPurchaseUserPriceTooLow (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenDirectPurchaseUserPriceTooLow (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_direct_purchase_user_price_too_low :: dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_direct_purchase_user_price_too_low :: TokenDirectPurchaseUserPriceTooLow >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: TokenAmountUnderMinimumSaleAmount (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenAmountUnderMinimumSaleAmount (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_amount_under_minimum_sale_amount :: dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_amount_under_minimum_sale_amount :: TokenAmountUnderMinimumSaleAmount >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: TokenNotForDirectSale (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenNotForDirectSale (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_not_for_direct_sale :: dpp_errors_consensus_state_token_token_not_for_direct_sale_TokenNotForDirectSale as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_not_for_direct_sale :: TokenNotForDirectSale >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityInTokenConfigurationNotFoundError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityInTokenConfigurationNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: IdentityInTokenConfigurationNotFoundError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityMemberOfGroupNotFoundError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityMemberOfGroupNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: identity_for_group_not_found_error :: dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: group :: identity_for_group_not_found_error :: IdentityMemberOfGroupNotFoundError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: ModificationOfGroupActionMainParametersNotPermittedError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: ModificationOfGroupActionMainParametersNotPermittedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: modification_of_group_action_main_parameters_not_permitted_error :: dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: group :: modification_of_group_action_main_parameters_not_permitted_error :: ModificationOfGroupActionMainParametersNotPermittedError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityToFreezeDoesNotExistError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityToFreezeDoesNotExistError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_to_freeze_does_not_exist_error :: dpp_errors_consensus_state_identity_identity_to_freeze_does_not_exist_error_IdentityToFreezeDoesNotExistError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_to_freeze_does_not_exist_error :: IdentityToFreezeDoesNotExistError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DataContractNotFoundError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_not_found_error :: dpp_errors_consensus_state_data_contract_data_contract_not_found_error_DataContractNotFoundError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: data_contract_not_found_error :: DataContractNotFoundError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: InvalidTokenPositionStateError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidTokenPositionStateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: invalid_token_position_error :: dpp_errors_consensus_state_token_invalid_token_position_error_InvalidTokenPositionStateError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: invalid_token_position_error :: InvalidTokenPositionStateError >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: state_error :: StateError > for dpp_errors_consensus_state_state_error_StateError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: state_error :: StateError) -> * const dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (match obj { dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractAlreadyPresentError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DataContractAlreadyPresentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_already_present_error :: dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: data_contract_already_present_error :: DataContractAlreadyPresentError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DataTriggerError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DataTriggerError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_trigger :: dpp_errors_consensus_state_data_trigger_DataTriggerError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentAlreadyPresentError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentAlreadyPresentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_already_present_error :: dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_already_present_error :: DocumentAlreadyPresentError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentContestCurrentlyLockedError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentContestCurrentlyLockedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_currently_locked_error :: dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_contest_currently_locked_error :: DocumentContestCurrentlyLockedError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentContestNotJoinableError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentContestNotJoinableError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_not_joinable_error :: dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_contest_not_joinable_error :: DocumentContestNotJoinableError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentContestIdentityAlreadyContestantError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentContestIdentityAlreadyContestantError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_identity_already_contestant :: dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_contest_identity_already_contestant :: DocumentContestIdentityAlreadyContestantError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentContestNotPaidForError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentContestNotPaidForError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_not_paid_for_error :: dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_contest_not_paid_for_error :: DocumentContestNotPaidForError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentContestDocumentWithSameIdAlreadyPresentError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentContestDocumentWithSameIdAlreadyPresentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_document_with_same_id_already_present_error :: dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_contest_document_with_same_id_already_present_error :: DocumentContestDocumentWithSameIdAlreadyPresentError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentNotFoundError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_not_found_error :: dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_not_found_error :: DocumentNotFoundError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentNotForSaleError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentNotForSaleError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_not_for_sale_error :: dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_not_for_sale_error :: DocumentNotForSaleError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentIncorrectPurchasePriceError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentIncorrectPurchasePriceError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_incorrect_purchase_price_error :: dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_incorrect_purchase_price_error :: DocumentIncorrectPurchasePriceError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentOwnerIdMismatchError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentOwnerIdMismatchError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_owner_id_mismatch_error :: dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_owner_id_mismatch_error :: DocumentOwnerIdMismatchError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentTimestampsMismatchError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampsMismatchError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_timestamps_mismatch_error :: dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_timestamps_mismatch_error :: DocumentTimestampsMismatchError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentTimestampWindowViolationError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampWindowViolationError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_timestamp_window_violation_error :: dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_timestamp_window_violation_error :: DocumentTimestampWindowViolationError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DuplicateUniqueIndexError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DuplicateUniqueIndexError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: duplicate_unique_index_error :: dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: duplicate_unique_index_error :: DuplicateUniqueIndexError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidDocumentRevisionError (o_0) => dpp_errors_consensus_state_state_error_StateError :: InvalidDocumentRevisionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: invalid_document_revision_error :: dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: invalid_document_revision_error :: InvalidDocumentRevisionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityAlreadyExistsError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityAlreadyExistsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_already_exists_error :: dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_already_exists_error :: IdentityAlreadyExistsError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_public_key_already_exists_for_unique_contract_bounds_error :: dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_public_key_already_exists_for_unique_contract_bounds_error :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityPublicKeyIsReadOnlyError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyIsReadOnlyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_read_only_error :: dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_read_only_error :: IdentityPublicKeyIsReadOnlyError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: MissingIdentityPublicKeyIdsError (o_0) => dpp_errors_consensus_state_state_error_StateError :: MissingIdentityPublicKeyIdsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: missing_identity_public_key_ids_error :: dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: missing_identity_public_key_ids_error :: MissingIdentityPublicKeyIdsError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: MissingTransferKeyError (o_0) => dpp_errors_consensus_state_state_error_StateError :: MissingTransferKeyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: missing_transfer_key_error :: dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: missing_transfer_key_error :: MissingTransferKeyError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: NoTransferKeyForCoreWithdrawalAvailableError (o_0) => dpp_errors_consensus_state_state_error_StateError :: NoTransferKeyForCoreWithdrawalAvailableError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: no_transfer_key_for_core_withdrawal_available_error :: dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: no_transfer_key_for_core_withdrawal_available_error :: NoTransferKeyForCoreWithdrawalAvailableError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidIdentityPublicKeyIdError (o_0) => dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityPublicKeyIdError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: invalid_identity_public_key_id_error :: dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: invalid_identity_public_key_id_error :: InvalidIdentityPublicKeyIdError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidIdentityRevisionError (o_0) => dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityRevisionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: invalid_identity_revision_error :: dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: invalid_identity_revision_error :: InvalidIdentityRevisionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidIdentityNonceError (o_0) => dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityNonceError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: invalid_identity_contract_nonce_error :: dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: invalid_identity_contract_nonce_error :: InvalidIdentityNonceError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: MaxIdentityPublicKeyLimitReachedError (o_0) => dpp_errors_consensus_state_state_error_StateError :: MaxIdentityPublicKeyLimitReachedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: max_identity_public_key_limit_reached_error :: dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: max_identity_public_key_limit_reached_error :: MaxIdentityPublicKeyLimitReachedError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DuplicatedIdentityPublicKeyStateError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DuplicatedIdentityPublicKeyStateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_state_error :: dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_state_error :: DuplicatedIdentityPublicKeyStateError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DuplicatedIdentityPublicKeyIdStateError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DuplicatedIdentityPublicKeyIdStateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_id_state_error :: dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_id_state_error :: DuplicatedIdentityPublicKeyIdStateError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityPublicKeyIsDisabledError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyIsDisabledError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_disabled_error :: dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_disabled_error :: IdentityPublicKeyIsDisabledError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityInsufficientBalanceError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityInsufficientBalanceError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_insufficient_balance_error :: dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_insufficient_balance_error :: IdentityInsufficientBalanceError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentTimestampsAreEqualError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampsAreEqualError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_timestamps_are_equal_error :: dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_timestamps_are_equal_error :: DocumentTimestampsAreEqualError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractIsReadonlyError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DataContractIsReadonlyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_is_readonly_error :: dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: data_contract_is_readonly_error :: DataContractIsReadonlyError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractConfigUpdateError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DataContractConfigUpdateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_config_update_error :: dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: data_contract_config_update_error :: DataContractConfigUpdateError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentTypeUpdateError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentTypeUpdateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: document_type_update_error :: dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: document_type_update_error :: DocumentTypeUpdateError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: PrefundedSpecializedBalanceInsufficientError (o_0) => dpp_errors_consensus_state_state_error_StateError :: PrefundedSpecializedBalanceInsufficientError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_insufficient_error :: dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_insufficient_error :: PrefundedSpecializedBalanceInsufficientError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: PrefundedSpecializedBalanceNotFoundError (o_0) => dpp_errors_consensus_state_state_error_StateError :: PrefundedSpecializedBalanceNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_not_found_error :: dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_not_found_error :: PrefundedSpecializedBalanceNotFoundError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractUpdatePermissionError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DataContractUpdatePermissionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_permission_error :: dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_permission_error :: DataContractUpdatePermissionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: MasternodeNotFoundError (o_0) => dpp_errors_consensus_state_state_error_StateError :: MasternodeNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_not_found_error :: dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: masternode_not_found_error :: MasternodeNotFoundError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: MasternodeIncorrectVoterIdentityIdError (o_0) => dpp_errors_consensus_state_state_error_StateError :: MasternodeIncorrectVoterIdentityIdError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voter_identity_id_error :: dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voter_identity_id_error :: MasternodeIncorrectVoterIdentityIdError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: MasternodeIncorrectVotingAddressError (o_0) => dpp_errors_consensus_state_state_error_StateError :: MasternodeIncorrectVotingAddressError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voting_address_error :: dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voting_address_error :: MasternodeIncorrectVotingAddressError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: VotePollNotFoundError (o_0) => dpp_errors_consensus_state_state_error_StateError :: VotePollNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: vote_poll_not_found_error :: dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: vote_poll_not_found_error :: VotePollNotFoundError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: VotePollNotAvailableForVotingError (o_0) => dpp_errors_consensus_state_state_error_StateError :: VotePollNotAvailableForVotingError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: vote_poll_not_available_for_voting_error :: dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: vote_poll_not_available_for_voting_error :: VotePollNotAvailableForVotingError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: MasternodeVotedTooManyTimesError (o_0) => dpp_errors_consensus_state_state_error_StateError :: MasternodeVotedTooManyTimesError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_voted_too_many_times :: dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: masternode_voted_too_many_times :: MasternodeVotedTooManyTimesError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: MasternodeVoteAlreadyPresentError (o_0) => dpp_errors_consensus_state_state_error_StateError :: MasternodeVoteAlreadyPresentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_vote_already_present_error :: dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: masternode_vote_already_present_error :: MasternodeVoteAlreadyPresentError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: RecipientIdentityDoesNotExistError (o_0) => dpp_errors_consensus_state_state_error_StateError :: RecipientIdentityDoesNotExistError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: recipient_identity_does_not_exist_error :: dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: recipient_identity_does_not_exist_error :: RecipientIdentityDoesNotExistError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityDoesNotHaveEnoughTokenBalanceError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityDoesNotHaveEnoughTokenBalanceError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_does_not_have_enough_token_balance_error :: dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: identity_does_not_have_enough_token_balance_error :: IdentityDoesNotHaveEnoughTokenBalanceError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: UnauthorizedTokenActionError (o_0) => dpp_errors_consensus_state_state_error_StateError :: UnauthorizedTokenActionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: unauthorized_token_action_error :: dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: unauthorized_token_action_error :: UnauthorizedTokenActionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityTokenAccountFrozenError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountFrozenError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_token_account_frozen_error :: dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: identity_token_account_frozen_error :: IdentityTokenAccountFrozenError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityTokenAccountNotFrozenError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountNotFrozenError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_token_account_not_frozen_error :: dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: identity_token_account_not_frozen_error :: IdentityTokenAccountNotFrozenError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityNotMemberOfGroupError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityNotMemberOfGroupError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: identity_not_member_of_group_error :: dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: group :: identity_not_member_of_group_error :: IdentityNotMemberOfGroupError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: GroupActionDoesNotExistError (o_0) => dpp_errors_consensus_state_state_error_StateError :: GroupActionDoesNotExistError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: group_action_does_not_exist_error :: dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: group :: group_action_does_not_exist_error :: GroupActionDoesNotExistError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: GroupActionAlreadyCompletedError (o_0) => dpp_errors_consensus_state_state_error_StateError :: GroupActionAlreadyCompletedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: group_action_already_completed_error :: dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: group :: group_action_already_completed_error :: GroupActionAlreadyCompletedError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: GroupActionAlreadySignedByIdentityError (o_0) => dpp_errors_consensus_state_state_error_StateError :: GroupActionAlreadySignedByIdentityError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: group_action_already_signed_by_identity_error :: dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: group :: group_action_already_signed_by_identity_error :: GroupActionAlreadySignedByIdentityError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractUpdateActionNotAllowedError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DataContractUpdateActionNotAllowedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_action_not_allowed_error :: dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_action_not_allowed_error :: DataContractUpdateActionNotAllowedError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenSettingMaxSupplyToLessThanCurrentSupplyError (o_0) => dpp_errors_consensus_state_state_error_StateError :: TokenSettingMaxSupplyToLessThanCurrentSupplyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_setting_max_supply_to_less_than_current_supply_error :: dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_setting_max_supply_to_less_than_current_supply_error :: TokenSettingMaxSupplyToLessThanCurrentSupplyError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenMintPastMaxSupplyError (o_0) => dpp_errors_consensus_state_state_error_StateError :: TokenMintPastMaxSupplyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_mint_past_max_supply_error :: dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_mint_past_max_supply_error :: TokenMintPastMaxSupplyError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidTokenClaimPropertyMismatch (o_0) => dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimPropertyMismatch (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: invalid_token_claim_property_mismatch :: dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: invalid_token_claim_property_mismatch :: InvalidTokenClaimPropertyMismatch >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidTokenClaimNoCurrentRewards (o_0) => dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimNoCurrentRewards (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: invalid_token_claim_no_current_rewards :: dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: invalid_token_claim_no_current_rewards :: InvalidTokenClaimNoCurrentRewards >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidTokenClaimWrongClaimant (o_0) => dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimWrongClaimant (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: invalid_token_claim_wrong_claimant :: dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: invalid_token_claim_wrong_claimant :: InvalidTokenClaimWrongClaimant >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: NewTokensDestinationIdentityDoesNotExistError (o_0) => dpp_errors_consensus_state_state_error_StateError :: NewTokensDestinationIdentityDoesNotExistError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: new_tokens_destination_identity_does_not_exist_error :: dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: new_tokens_destination_identity_does_not_exist_error :: NewTokensDestinationIdentityDoesNotExistError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: NewAuthorizedActionTakerIdentityDoesNotExistError (o_0) => dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerIdentityDoesNotExistError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_identity_does_not_exist_error :: dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_identity_does_not_exist_error :: NewAuthorizedActionTakerIdentityDoesNotExistError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: NewAuthorizedActionTakerGroupDoesNotExistError (o_0) => dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerGroupDoesNotExistError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_group_does_not_exist_error :: dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_group_does_not_exist_error :: NewAuthorizedActionTakerGroupDoesNotExistError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: NewAuthorizedActionTakerMainGroupNotSetError (o_0) => dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerMainGroupNotSetError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_main_group_not_set_error :: dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_main_group_not_set_error :: NewAuthorizedActionTakerMainGroupNotSetError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidGroupPositionError (o_0) => dpp_errors_consensus_state_state_error_StateError :: InvalidGroupPositionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: invalid_group_position_error :: dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: invalid_group_position_error :: InvalidGroupPositionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenIsPausedError (o_0) => dpp_errors_consensus_state_state_error_StateError :: TokenIsPausedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_is_paused_error :: dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_is_paused_error :: TokenIsPausedError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityTokenAccountAlreadyFrozenError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountAlreadyFrozenError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_token_account_already_frozen_error :: dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: identity_token_account_already_frozen_error :: IdentityTokenAccountAlreadyFrozenError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenAlreadyPausedError (o_0) => dpp_errors_consensus_state_state_error_StateError :: TokenAlreadyPausedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_already_paused_error :: dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_already_paused_error :: TokenAlreadyPausedError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenNotPausedError (o_0) => dpp_errors_consensus_state_state_error_StateError :: TokenNotPausedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_not_paused_error :: dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_not_paused_error :: TokenNotPausedError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenTransferRecipientIdentityNotExistError (o_0) => dpp_errors_consensus_state_state_error_StateError :: TokenTransferRecipientIdentityNotExistError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_transfer_recipient_identity_not_exist_error :: dpp_errors_consensus_state_token_token_transfer_recipient_identity_not_exist_error_TokenTransferRecipientIdentityNotExistError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_transfer_recipient_identity_not_exist_error :: TokenTransferRecipientIdentityNotExistError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: PreProgrammedDistributionTimestampInPastError (o_0) => dpp_errors_consensus_state_state_error_StateError :: PreProgrammedDistributionTimestampInPastError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: pre_programmed_distribution_timestamp_in_past_error :: dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: pre_programmed_distribution_timestamp_in_past_error :: PreProgrammedDistributionTimestampInPastError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityHasNotAgreedToPayRequiredTokenAmountError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityHasNotAgreedToPayRequiredTokenAmountError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_has_not_agreed_to_pay_required_token_amount_error :: dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: identity_has_not_agreed_to_pay_required_token_amount_error :: IdentityHasNotAgreedToPayRequiredTokenAmountError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: RequiredTokenPaymentInfoNotSetError (o_0) => dpp_errors_consensus_state_state_error_StateError :: RequiredTokenPaymentInfoNotSetError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: required_token_payment_info_not_set_error :: dpp_errors_consensus_state_token_required_token_payment_info_not_set_error_RequiredTokenPaymentInfoNotSetError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: required_token_payment_info_not_set_error :: RequiredTokenPaymentInfoNotSetError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityTryingToPayWithWrongTokenError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityTryingToPayWithWrongTokenError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_trying_to_pay_with_wrong_token_error :: dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: identity_trying_to_pay_with_wrong_token_error :: IdentityTryingToPayWithWrongTokenError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenDirectPurchaseUserPriceTooLow (o_0) => dpp_errors_consensus_state_state_error_StateError :: TokenDirectPurchaseUserPriceTooLow (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_direct_purchase_user_price_too_low :: dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_direct_purchase_user_price_too_low :: TokenDirectPurchaseUserPriceTooLow >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenAmountUnderMinimumSaleAmount (o_0) => dpp_errors_consensus_state_state_error_StateError :: TokenAmountUnderMinimumSaleAmount (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_amount_under_minimum_sale_amount :: dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_amount_under_minimum_sale_amount :: TokenAmountUnderMinimumSaleAmount >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenNotForDirectSale (o_0) => dpp_errors_consensus_state_state_error_StateError :: TokenNotForDirectSale (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_not_for_direct_sale :: dpp_errors_consensus_state_token_token_not_for_direct_sale_TokenNotForDirectSale as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_not_for_direct_sale :: TokenNotForDirectSale >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityInTokenConfigurationNotFoundError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityInTokenConfigurationNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: IdentityInTokenConfigurationNotFoundError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityMemberOfGroupNotFoundError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityMemberOfGroupNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: identity_for_group_not_found_error :: dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: group :: identity_for_group_not_found_error :: IdentityMemberOfGroupNotFoundError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: ModificationOfGroupActionMainParametersNotPermittedError (o_0) => dpp_errors_consensus_state_state_error_StateError :: ModificationOfGroupActionMainParametersNotPermittedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: modification_of_group_action_main_parameters_not_permitted_error :: dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: group :: modification_of_group_action_main_parameters_not_permitted_error :: ModificationOfGroupActionMainParametersNotPermittedError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityToFreezeDoesNotExistError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityToFreezeDoesNotExistError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_to_freeze_does_not_exist_error :: dpp_errors_consensus_state_identity_identity_to_freeze_does_not_exist_error_IdentityToFreezeDoesNotExistError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_to_freeze_does_not_exist_error :: IdentityToFreezeDoesNotExistError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractNotFoundError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DataContractNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_not_found_error :: dpp_errors_consensus_state_data_contract_data_contract_not_found_error_DataContractNotFoundError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: data_contract_not_found_error :: DataContractNotFoundError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidTokenPositionStateError (o_0) => dpp_errors_consensus_state_state_error_StateError :: InvalidTokenPositionStateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: invalid_token_position_error :: dpp_errors_consensus_state_token_invalid_token_position_error_InvalidTokenPositionStateError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: invalid_token_position_error :: InvalidTokenPositionStateError >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_errors_consensus_state_state_error_StateError { fn drop (& mut self) { unsafe { match self { dpp_errors_consensus_state_state_error_StateError :: DataContractAlreadyPresentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DataTriggerError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentAlreadyPresentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentContestCurrentlyLockedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentContestNotJoinableError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentContestIdentityAlreadyContestantError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentContestNotPaidForError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentContestDocumentWithSameIdAlreadyPresentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentNotForSaleError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentIncorrectPurchasePriceError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentOwnerIdMismatchError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampsMismatchError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampWindowViolationError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DuplicateUniqueIndexError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: InvalidDocumentRevisionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityAlreadyExistsError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyIsReadOnlyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: MissingIdentityPublicKeyIdsError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: MissingTransferKeyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: NoTransferKeyForCoreWithdrawalAvailableError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityPublicKeyIdError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityRevisionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityNonceError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: MaxIdentityPublicKeyLimitReachedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DuplicatedIdentityPublicKeyStateError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DuplicatedIdentityPublicKeyIdStateError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyIsDisabledError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityInsufficientBalanceError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampsAreEqualError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DataContractIsReadonlyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DataContractConfigUpdateError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentTypeUpdateError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: PrefundedSpecializedBalanceInsufficientError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: PrefundedSpecializedBalanceNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DataContractUpdatePermissionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: MasternodeNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: MasternodeIncorrectVoterIdentityIdError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: MasternodeIncorrectVotingAddressError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: VotePollNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: VotePollNotAvailableForVotingError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: MasternodeVotedTooManyTimesError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: MasternodeVoteAlreadyPresentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: RecipientIdentityDoesNotExistError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityDoesNotHaveEnoughTokenBalanceError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: UnauthorizedTokenActionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountFrozenError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountNotFrozenError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityNotMemberOfGroupError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: GroupActionDoesNotExistError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: GroupActionAlreadyCompletedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: GroupActionAlreadySignedByIdentityError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DataContractUpdateActionNotAllowedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: TokenSettingMaxSupplyToLessThanCurrentSupplyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: TokenMintPastMaxSupplyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimPropertyMismatch (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimNoCurrentRewards (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimWrongClaimant (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: NewTokensDestinationIdentityDoesNotExistError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerIdentityDoesNotExistError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerGroupDoesNotExistError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerMainGroupNotSetError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: InvalidGroupPositionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: TokenIsPausedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountAlreadyFrozenError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: TokenAlreadyPausedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: TokenNotPausedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: TokenTransferRecipientIdentityNotExistError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: PreProgrammedDistributionTimestampInPastError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityHasNotAgreedToPayRequiredTokenAmountError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: RequiredTokenPaymentInfoNotSetError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityTryingToPayWithWrongTokenError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: TokenDirectPurchaseUserPriceTooLow (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: TokenAmountUnderMinimumSaleAmount (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: TokenNotForDirectSale (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityInTokenConfigurationNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityMemberOfGroupNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: ModificationOfGroupActionMainParametersNotPermittedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityToFreezeDoesNotExistError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DataContractNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: InvalidTokenPositionStateError (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod token { pub mod identity_does_not_have_enough_token_balance_error { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityDoesNotHaveEnoughTokenBalanceError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub required_balance : u64 , pub actual_balance : u64 , pub action : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: identity_does_not_have_enough_token_balance_error :: IdentityDoesNotHaveEnoughTokenBalanceError > for dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError) -> dpp :: errors :: consensus :: state :: token :: identity_does_not_have_enough_token_balance_error :: IdentityDoesNotHaveEnoughTokenBalanceError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: identity_does_not_have_enough_token_balance_error :: IdentityDoesNotHaveEnoughTokenBalanceError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , required_balance : ffi_ref . required_balance , actual_balance : ffi_ref . actual_balance , action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: identity_does_not_have_enough_token_balance_error :: IdentityDoesNotHaveEnoughTokenBalanceError > for dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: identity_does_not_have_enough_token_balance_error :: IdentityDoesNotHaveEnoughTokenBalanceError) -> * const dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError { ferment :: boxed (dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , required_balance : obj . required_balance , actual_balance : obj . actual_balance , action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) }) } } impl Drop for dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_any (ffi_ref . identity_id) ; ; ; ferment :: unbox_string (ffi_ref . action) ; } } } } pub mod identity_has_not_agreed_to_pay_required_token_amount_error { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityHasNotAgreedToPayRequiredTokenAmountError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub required_amount : u64 , pub identity_min_offer : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , pub identity_max_offer : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , pub action : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: identity_has_not_agreed_to_pay_required_token_amount_error :: IdentityHasNotAgreedToPayRequiredTokenAmountError > for dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError) -> dpp :: errors :: consensus :: state :: token :: identity_has_not_agreed_to_pay_required_token_amount_error :: IdentityHasNotAgreedToPayRequiredTokenAmountError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: identity_has_not_agreed_to_pay_required_token_amount_error :: IdentityHasNotAgreedToPayRequiredTokenAmountError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , required_amount : ffi_ref . required_amount , identity_min_offer : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from_opt (ffi_ref . identity_min_offer) , identity_max_offer : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from_opt (ffi_ref . identity_max_offer) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: identity_has_not_agreed_to_pay_required_token_amount_error :: IdentityHasNotAgreedToPayRequiredTokenAmountError > for dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: identity_has_not_agreed_to_pay_required_token_amount_error :: IdentityHasNotAgreedToPayRequiredTokenAmountError) -> * const dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError { ferment :: boxed (dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , required_amount : obj . required_amount , identity_min_offer : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to_opt (obj . identity_min_offer) , identity_max_offer : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to_opt (obj . identity_max_offer) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) }) } } impl Drop for dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ; ferment :: unbox_any_opt (ffi_ref . identity_min_offer) ; ferment :: unbox_any_opt (ffi_ref . identity_max_offer) ; ferment :: unbox_string (ffi_ref . action) ; } } } } pub mod identity_token_account_already_frozen_error { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityTokenAccountAlreadyFrozenError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub action : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: identity_token_account_already_frozen_error :: IdentityTokenAccountAlreadyFrozenError > for dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError) -> dpp :: errors :: consensus :: state :: token :: identity_token_account_already_frozen_error :: IdentityTokenAccountAlreadyFrozenError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: identity_token_account_already_frozen_error :: IdentityTokenAccountAlreadyFrozenError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: identity_token_account_already_frozen_error :: IdentityTokenAccountAlreadyFrozenError > for dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: identity_token_account_already_frozen_error :: IdentityTokenAccountAlreadyFrozenError) -> * const dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError { ferment :: boxed (dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) }) } } impl Drop for dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_string (ffi_ref . action) ; } } } } pub mod identity_token_account_frozen_error { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityTokenAccountFrozenError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub action : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: identity_token_account_frozen_error :: IdentityTokenAccountFrozenError > for dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError) -> dpp :: errors :: consensus :: state :: token :: identity_token_account_frozen_error :: IdentityTokenAccountFrozenError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: identity_token_account_frozen_error :: IdentityTokenAccountFrozenError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: identity_token_account_frozen_error :: IdentityTokenAccountFrozenError > for dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: identity_token_account_frozen_error :: IdentityTokenAccountFrozenError) -> * const dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError { ferment :: boxed (dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) }) } } impl Drop for dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_string (ffi_ref . action) ; } } } } pub mod identity_token_account_not_frozen_error { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityTokenAccountNotFrozenError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub action : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: identity_token_account_not_frozen_error :: IdentityTokenAccountNotFrozenError > for dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError) -> dpp :: errors :: consensus :: state :: token :: identity_token_account_not_frozen_error :: IdentityTokenAccountNotFrozenError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: identity_token_account_not_frozen_error :: IdentityTokenAccountNotFrozenError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: identity_token_account_not_frozen_error :: IdentityTokenAccountNotFrozenError > for dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: identity_token_account_not_frozen_error :: IdentityTokenAccountNotFrozenError) -> * const dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError { ferment :: boxed (dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) }) } } impl Drop for dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_string (ffi_ref . action) ; } } } } pub mod identity_trying_to_pay_with_wrong_token_error { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityTryingToPayWithWrongTokenError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError { pub expected_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub expected_token_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , pub expected_token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub actual_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub actual_token_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , pub actual_token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: identity_trying_to_pay_with_wrong_token_error :: IdentityTryingToPayWithWrongTokenError > for dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError) -> dpp :: errors :: consensus :: state :: token :: identity_trying_to_pay_with_wrong_token_error :: IdentityTryingToPayWithWrongTokenError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: identity_trying_to_pay_with_wrong_token_error :: IdentityTryingToPayWithWrongTokenError { expected_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from_opt (ffi_ref . expected_contract_id) , expected_token_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from (ffi_ref . expected_token_contract_position) , expected_token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . expected_token_id) , actual_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from_opt (ffi_ref . actual_contract_id) , actual_token_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from (ffi_ref . actual_token_contract_position) , actual_token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . actual_token_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: identity_trying_to_pay_with_wrong_token_error :: IdentityTryingToPayWithWrongTokenError > for dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: identity_trying_to_pay_with_wrong_token_error :: IdentityTryingToPayWithWrongTokenError) -> * const dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError { ferment :: boxed (dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError { expected_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to_opt (obj . expected_contract_id) , expected_token_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition >> :: ffi_to (obj . expected_token_contract_position) , expected_token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . expected_token_id) , actual_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to_opt (obj . actual_contract_id) , actual_token_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition >> :: ffi_to (obj . actual_token_contract_position) , actual_token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . actual_token_id) }) } } impl Drop for dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any_opt (ffi_ref . expected_contract_id) ; ferment :: unbox_any (ffi_ref . expected_token_contract_position) ; ferment :: unbox_any (ffi_ref . expected_token_id) ; ferment :: unbox_any_opt (ffi_ref . actual_contract_id) ; ferment :: unbox_any (ffi_ref . actual_token_contract_position) ; ferment :: unbox_any (ffi_ref . actual_token_id) ; } } } } pub mod invalid_group_position_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidGroupPositionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError { pub max_group_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , pub invalid_group_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: invalid_group_position_error :: InvalidGroupPositionError > for dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError) -> dpp :: errors :: consensus :: state :: token :: invalid_group_position_error :: InvalidGroupPositionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: invalid_group_position_error :: InvalidGroupPositionError { max_group_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from_opt (ffi_ref . max_group_position) , invalid_group_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (ffi_ref . invalid_group_position) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: invalid_group_position_error :: InvalidGroupPositionError > for dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: invalid_group_position_error :: InvalidGroupPositionError) -> * const dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError { ferment :: boxed (dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError { max_group_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to_opt (obj . max_group_position) , invalid_group_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (obj . invalid_group_position) }) } } impl Drop for dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any_opt (ffi_ref . max_group_position) ; ferment :: unbox_any (ffi_ref . invalid_group_position) ; } } } } pub mod invalid_token_claim_no_current_rewards { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidTokenClaimNoCurrentRewards`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub recipient_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub current_moment : * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment , pub last_claimed_moment : * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: invalid_token_claim_no_current_rewards :: InvalidTokenClaimNoCurrentRewards > for dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards) -> dpp :: errors :: consensus :: state :: token :: invalid_token_claim_no_current_rewards :: InvalidTokenClaimNoCurrentRewards { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: invalid_token_claim_no_current_rewards :: InvalidTokenClaimNoCurrentRewards { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , recipient_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . recipient_id) , current_moment : < crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment as ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment >> :: ffi_from (ffi_ref . current_moment) , last_claimed_moment : < crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment as ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment >> :: ffi_from_opt (ffi_ref . last_claimed_moment) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: invalid_token_claim_no_current_rewards :: InvalidTokenClaimNoCurrentRewards > for dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: invalid_token_claim_no_current_rewards :: InvalidTokenClaimNoCurrentRewards) -> * const dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards { ferment :: boxed (dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , recipient_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . recipient_id) , current_moment : < crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment as ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment >> :: ffi_to (obj . current_moment) , last_claimed_moment : < crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment as ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment >> :: ffi_to_opt (obj . last_claimed_moment) }) } } impl Drop for dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_any (ffi_ref . recipient_id) ; ferment :: unbox_any (ffi_ref . current_moment) ; ferment :: unbox_any_opt (ffi_ref . last_claimed_moment) ; } } } } pub mod invalid_token_claim_property_mismatch { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidTokenClaimPropertyMismatch`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch { pub property : * mut std :: os :: raw :: c_char , pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: invalid_token_claim_property_mismatch :: InvalidTokenClaimPropertyMismatch > for dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch) -> dpp :: errors :: consensus :: state :: token :: invalid_token_claim_property_mismatch :: InvalidTokenClaimPropertyMismatch { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: invalid_token_claim_property_mismatch :: InvalidTokenClaimPropertyMismatch { property : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . property) , token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: invalid_token_claim_property_mismatch :: InvalidTokenClaimPropertyMismatch > for dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: invalid_token_claim_property_mismatch :: InvalidTokenClaimPropertyMismatch) -> * const dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch { ferment :: boxed (dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch { property : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . property) , token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) }) } } impl Drop for dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . property) ; ferment :: unbox_any (ffi_ref . token_id) ; } } } } pub mod invalid_token_claim_wrong_claimant { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidTokenClaimWrongClaimant`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub expected_claimant_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub claimant_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: invalid_token_claim_wrong_claimant :: InvalidTokenClaimWrongClaimant > for dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant) -> dpp :: errors :: consensus :: state :: token :: invalid_token_claim_wrong_claimant :: InvalidTokenClaimWrongClaimant { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: invalid_token_claim_wrong_claimant :: InvalidTokenClaimWrongClaimant { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , expected_claimant_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . expected_claimant_id) , claimant_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . claimant_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: invalid_token_claim_wrong_claimant :: InvalidTokenClaimWrongClaimant > for dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: invalid_token_claim_wrong_claimant :: InvalidTokenClaimWrongClaimant) -> * const dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant { ferment :: boxed (dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , expected_claimant_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . expected_claimant_id) , claimant_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . claimant_id) }) } } impl Drop for dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_any (ffi_ref . expected_claimant_id) ; ferment :: unbox_any (ffi_ref . claimant_id) ; } } } } pub mod invalid_token_position_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidTokenPositionStateError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_invalid_token_position_error_InvalidTokenPositionStateError { pub max_token_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , pub invalid_token_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: invalid_token_position_error :: InvalidTokenPositionStateError > for dpp_errors_consensus_state_token_invalid_token_position_error_InvalidTokenPositionStateError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_invalid_token_position_error_InvalidTokenPositionStateError) -> dpp :: errors :: consensus :: state :: token :: invalid_token_position_error :: InvalidTokenPositionStateError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: invalid_token_position_error :: InvalidTokenPositionStateError { max_token_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from_opt (ffi_ref . max_token_position) , invalid_token_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from (ffi_ref . invalid_token_position) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: invalid_token_position_error :: InvalidTokenPositionStateError > for dpp_errors_consensus_state_token_invalid_token_position_error_InvalidTokenPositionStateError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: invalid_token_position_error :: InvalidTokenPositionStateError) -> * const dpp_errors_consensus_state_token_invalid_token_position_error_InvalidTokenPositionStateError { ferment :: boxed (dpp_errors_consensus_state_token_invalid_token_position_error_InvalidTokenPositionStateError { max_token_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition >> :: ffi_to_opt (obj . max_token_position) , invalid_token_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition >> :: ffi_to (obj . invalid_token_position) }) } } impl Drop for dpp_errors_consensus_state_token_invalid_token_position_error_InvalidTokenPositionStateError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any_opt (ffi_ref . max_token_position) ; ferment :: unbox_any (ffi_ref . invalid_token_position) ; } } } } pub mod new_authorized_action_taker_group_does_not_exist_error { use crate as example_platform ; # [doc = "FFI-representation of the [`NewAuthorizedActionTakerGroupDoesNotExistError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError { pub group_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_group_does_not_exist_error :: NewAuthorizedActionTakerGroupDoesNotExistError > for dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError) -> dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_group_does_not_exist_error :: NewAuthorizedActionTakerGroupDoesNotExistError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_group_does_not_exist_error :: NewAuthorizedActionTakerGroupDoesNotExistError { group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (ffi_ref . group_contract_position) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_group_does_not_exist_error :: NewAuthorizedActionTakerGroupDoesNotExistError > for dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_group_does_not_exist_error :: NewAuthorizedActionTakerGroupDoesNotExistError) -> * const dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError { ferment :: boxed (dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError { group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (obj . group_contract_position) }) } } impl Drop for dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . group_contract_position) ; } } } } pub mod new_authorized_action_taker_identity_does_not_exist_error { use crate as example_platform ; # [doc = "FFI-representation of the [`NewAuthorizedActionTakerIdentityDoesNotExistError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_identity_does_not_exist_error :: NewAuthorizedActionTakerIdentityDoesNotExistError > for dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError) -> dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_identity_does_not_exist_error :: NewAuthorizedActionTakerIdentityDoesNotExistError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_identity_does_not_exist_error :: NewAuthorizedActionTakerIdentityDoesNotExistError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_identity_does_not_exist_error :: NewAuthorizedActionTakerIdentityDoesNotExistError > for dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_identity_does_not_exist_error :: NewAuthorizedActionTakerIdentityDoesNotExistError) -> * const dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError { ferment :: boxed (dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) }) } } impl Drop for dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; } } } } pub mod new_authorized_action_taker_main_group_not_set_error { use crate as example_platform ; # [doc = "FFI-representation of the [`NewAuthorizedActionTakerMainGroupNotSetError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_main_group_not_set_error :: NewAuthorizedActionTakerMainGroupNotSetError > for dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError) -> dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_main_group_not_set_error :: NewAuthorizedActionTakerMainGroupNotSetError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_main_group_not_set_error :: NewAuthorizedActionTakerMainGroupNotSetError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_main_group_not_set_error :: NewAuthorizedActionTakerMainGroupNotSetError > for dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_main_group_not_set_error :: NewAuthorizedActionTakerMainGroupNotSetError) -> * const dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError { ferment :: boxed (dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError { }) } } } pub mod new_tokens_destination_identity_does_not_exist_error { use crate as example_platform ; # [doc = "FFI-representation of the [`NewTokensDestinationIdentityDoesNotExistError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: new_tokens_destination_identity_does_not_exist_error :: NewTokensDestinationIdentityDoesNotExistError > for dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError) -> dpp :: errors :: consensus :: state :: token :: new_tokens_destination_identity_does_not_exist_error :: NewTokensDestinationIdentityDoesNotExistError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: new_tokens_destination_identity_does_not_exist_error :: NewTokensDestinationIdentityDoesNotExistError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: new_tokens_destination_identity_does_not_exist_error :: NewTokensDestinationIdentityDoesNotExistError > for dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: new_tokens_destination_identity_does_not_exist_error :: NewTokensDestinationIdentityDoesNotExistError) -> * const dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError { ferment :: boxed (dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) }) } } impl Drop for dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; } } } } pub mod pre_programmed_distribution_timestamp_in_past_error { use crate as example_platform ; # [doc = "FFI-representation of the [`PreProgrammedDistributionTimestampInPastError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub token_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , pub pre_programmed_timestamp : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis , pub current_timestamp : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: pre_programmed_distribution_timestamp_in_past_error :: PreProgrammedDistributionTimestampInPastError > for dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError) -> dpp :: errors :: consensus :: state :: token :: pre_programmed_distribution_timestamp_in_past_error :: PreProgrammedDistributionTimestampInPastError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: pre_programmed_distribution_timestamp_in_past_error :: PreProgrammedDistributionTimestampInPastError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , token_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from (ffi_ref . token_position) , pre_programmed_timestamp : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_from (ffi_ref . pre_programmed_timestamp) , current_timestamp : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_from (ffi_ref . current_timestamp) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: pre_programmed_distribution_timestamp_in_past_error :: PreProgrammedDistributionTimestampInPastError > for dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: pre_programmed_distribution_timestamp_in_past_error :: PreProgrammedDistributionTimestampInPastError) -> * const dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError { ferment :: boxed (dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , token_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition >> :: ffi_to (obj . token_position) , pre_programmed_timestamp : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_to (obj . pre_programmed_timestamp) , current_timestamp : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_to (obj . current_timestamp) }) } } impl Drop for dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any (ffi_ref . token_position) ; ferment :: unbox_any (ffi_ref . pre_programmed_timestamp) ; ferment :: unbox_any (ffi_ref . current_timestamp) ; } } } } pub mod required_token_payment_info_not_set_error { use crate as example_platform ; # [doc = "FFI-representation of the [`RequiredTokenPaymentInfoNotSetError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_required_token_payment_info_not_set_error_RequiredTokenPaymentInfoNotSetError { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub action : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: required_token_payment_info_not_set_error :: RequiredTokenPaymentInfoNotSetError > for dpp_errors_consensus_state_token_required_token_payment_info_not_set_error_RequiredTokenPaymentInfoNotSetError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_required_token_payment_info_not_set_error_RequiredTokenPaymentInfoNotSetError) -> dpp :: errors :: consensus :: state :: token :: required_token_payment_info_not_set_error :: RequiredTokenPaymentInfoNotSetError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: required_token_payment_info_not_set_error :: RequiredTokenPaymentInfoNotSetError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: required_token_payment_info_not_set_error :: RequiredTokenPaymentInfoNotSetError > for dpp_errors_consensus_state_token_required_token_payment_info_not_set_error_RequiredTokenPaymentInfoNotSetError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: required_token_payment_info_not_set_error :: RequiredTokenPaymentInfoNotSetError) -> * const dpp_errors_consensus_state_token_required_token_payment_info_not_set_error_RequiredTokenPaymentInfoNotSetError { ferment :: boxed (dpp_errors_consensus_state_token_required_token_payment_info_not_set_error_RequiredTokenPaymentInfoNotSetError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) }) } } impl Drop for dpp_errors_consensus_state_token_required_token_payment_info_not_set_error_RequiredTokenPaymentInfoNotSetError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_string (ffi_ref . action) ; } } } } pub mod token_already_paused_error { use crate as example_platform ; # [doc = "FFI-representation of the [`TokenAlreadyPausedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub action : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_already_paused_error :: TokenAlreadyPausedError > for dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError) -> dpp :: errors :: consensus :: state :: token :: token_already_paused_error :: TokenAlreadyPausedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: token_already_paused_error :: TokenAlreadyPausedError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_already_paused_error :: TokenAlreadyPausedError > for dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: token_already_paused_error :: TokenAlreadyPausedError) -> * const dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError { ferment :: boxed (dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) }) } } impl Drop for dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_string (ffi_ref . action) ; } } } } pub mod token_amount_under_minimum_sale_amount { use crate as example_platform ; # [doc = "FFI-representation of the [`TokenAmountUnderMinimumSaleAmount`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub desired_amount : u64 , pub minimum_amount : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_amount_under_minimum_sale_amount :: TokenAmountUnderMinimumSaleAmount > for dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount) -> dpp :: errors :: consensus :: state :: token :: token_amount_under_minimum_sale_amount :: TokenAmountUnderMinimumSaleAmount { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: token_amount_under_minimum_sale_amount :: TokenAmountUnderMinimumSaleAmount { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , desired_amount : ffi_ref . desired_amount , minimum_amount : ffi_ref . minimum_amount } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_amount_under_minimum_sale_amount :: TokenAmountUnderMinimumSaleAmount > for dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: token_amount_under_minimum_sale_amount :: TokenAmountUnderMinimumSaleAmount) -> * const dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount { ferment :: boxed (dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , desired_amount : obj . desired_amount , minimum_amount : obj . minimum_amount }) } } impl Drop for dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ; ; } } } } pub mod token_direct_purchase_user_price_too_low { use crate as example_platform ; # [doc = "FFI-representation of the [`TokenDirectPurchaseUserPriceTooLow`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub user_price : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , pub required_price : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_direct_purchase_user_price_too_low :: TokenDirectPurchaseUserPriceTooLow > for dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow) -> dpp :: errors :: consensus :: state :: token :: token_direct_purchase_user_price_too_low :: TokenDirectPurchaseUserPriceTooLow { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: token_direct_purchase_user_price_too_low :: TokenDirectPurchaseUserPriceTooLow { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , user_price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . user_price) , required_price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . required_price) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_direct_purchase_user_price_too_low :: TokenDirectPurchaseUserPriceTooLow > for dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: token_direct_purchase_user_price_too_low :: TokenDirectPurchaseUserPriceTooLow) -> * const dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow { ferment :: boxed (dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , user_price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . user_price) , required_price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . required_price) }) } } impl Drop for dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_any (ffi_ref . user_price) ; ferment :: unbox_any (ffi_ref . required_price) ; } } } } pub mod token_is_paused_error { use crate as example_platform ; # [doc = "FFI-representation of the [`TokenIsPausedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_is_paused_error :: TokenIsPausedError > for dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError) -> dpp :: errors :: consensus :: state :: token :: token_is_paused_error :: TokenIsPausedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: token_is_paused_error :: TokenIsPausedError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_is_paused_error :: TokenIsPausedError > for dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: token_is_paused_error :: TokenIsPausedError) -> * const dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError { ferment :: boxed (dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) }) } } impl Drop for dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; } } } } pub mod token_mint_past_max_supply_error { use crate as example_platform ; # [doc = "FFI-representation of the [`TokenMintPastMaxSupplyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , pub current_supply : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , pub max_supply : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_mint_past_max_supply_error :: TokenMintPastMaxSupplyError > for dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError) -> dpp :: errors :: consensus :: state :: token :: token_mint_past_max_supply_error :: TokenMintPastMaxSupplyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: token_mint_past_max_supply_error :: TokenMintPastMaxSupplyError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (ffi_ref . amount) , current_supply : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (ffi_ref . current_supply) , max_supply : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (ffi_ref . max_supply) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_mint_past_max_supply_error :: TokenMintPastMaxSupplyError > for dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: token_mint_past_max_supply_error :: TokenMintPastMaxSupplyError) -> * const dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError { ferment :: boxed (dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (obj . amount) , current_supply : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (obj . current_supply) , max_supply : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (obj . max_supply) }) } } impl Drop for dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_any (ffi_ref . amount) ; ferment :: unbox_any (ffi_ref . current_supply) ; ferment :: unbox_any (ffi_ref . max_supply) ; } } } } pub mod token_not_for_direct_sale { use crate as example_platform ; # [doc = "FFI-representation of the [`TokenNotForDirectSale`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_token_not_for_direct_sale_TokenNotForDirectSale { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_not_for_direct_sale :: TokenNotForDirectSale > for dpp_errors_consensus_state_token_token_not_for_direct_sale_TokenNotForDirectSale { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_token_not_for_direct_sale_TokenNotForDirectSale) -> dpp :: errors :: consensus :: state :: token :: token_not_for_direct_sale :: TokenNotForDirectSale { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: token_not_for_direct_sale :: TokenNotForDirectSale { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_not_for_direct_sale :: TokenNotForDirectSale > for dpp_errors_consensus_state_token_token_not_for_direct_sale_TokenNotForDirectSale { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: token_not_for_direct_sale :: TokenNotForDirectSale) -> * const dpp_errors_consensus_state_token_token_not_for_direct_sale_TokenNotForDirectSale { ferment :: boxed (dpp_errors_consensus_state_token_token_not_for_direct_sale_TokenNotForDirectSale { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) }) } } impl Drop for dpp_errors_consensus_state_token_token_not_for_direct_sale_TokenNotForDirectSale { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; } } } } pub mod token_not_paused_error { use crate as example_platform ; # [doc = "FFI-representation of the [`TokenNotPausedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub action : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_not_paused_error :: TokenNotPausedError > for dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError) -> dpp :: errors :: consensus :: state :: token :: token_not_paused_error :: TokenNotPausedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: token_not_paused_error :: TokenNotPausedError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_not_paused_error :: TokenNotPausedError > for dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: token_not_paused_error :: TokenNotPausedError) -> * const dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError { ferment :: boxed (dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) }) } } impl Drop for dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_string (ffi_ref . action) ; } } } } pub mod token_setting_max_supply_to_less_than_current_supply_error { use crate as example_platform ; # [doc = "FFI-representation of the [`TokenSettingMaxSupplyToLessThanCurrentSupplyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub max_supply : u64 , pub current_supply : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_setting_max_supply_to_less_than_current_supply_error :: TokenSettingMaxSupplyToLessThanCurrentSupplyError > for dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError) -> dpp :: errors :: consensus :: state :: token :: token_setting_max_supply_to_less_than_current_supply_error :: TokenSettingMaxSupplyToLessThanCurrentSupplyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: token_setting_max_supply_to_less_than_current_supply_error :: TokenSettingMaxSupplyToLessThanCurrentSupplyError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , max_supply : ffi_ref . max_supply , current_supply : ffi_ref . current_supply } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_setting_max_supply_to_less_than_current_supply_error :: TokenSettingMaxSupplyToLessThanCurrentSupplyError > for dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: token_setting_max_supply_to_less_than_current_supply_error :: TokenSettingMaxSupplyToLessThanCurrentSupplyError) -> * const dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError { ferment :: boxed (dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , max_supply : obj . max_supply , current_supply : obj . current_supply }) } } impl Drop for dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ; ; } } } } pub mod token_transfer_recipient_identity_not_exist_error { use crate as example_platform ; # [doc = "FFI-representation of the [`TokenTransferRecipientIdentityNotExistError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_token_transfer_recipient_identity_not_exist_error_TokenTransferRecipientIdentityNotExistError { pub recipient_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_transfer_recipient_identity_not_exist_error :: TokenTransferRecipientIdentityNotExistError > for dpp_errors_consensus_state_token_token_transfer_recipient_identity_not_exist_error_TokenTransferRecipientIdentityNotExistError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_token_transfer_recipient_identity_not_exist_error_TokenTransferRecipientIdentityNotExistError) -> dpp :: errors :: consensus :: state :: token :: token_transfer_recipient_identity_not_exist_error :: TokenTransferRecipientIdentityNotExistError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: token_transfer_recipient_identity_not_exist_error :: TokenTransferRecipientIdentityNotExistError { recipient_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . recipient_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_transfer_recipient_identity_not_exist_error :: TokenTransferRecipientIdentityNotExistError > for dpp_errors_consensus_state_token_token_transfer_recipient_identity_not_exist_error_TokenTransferRecipientIdentityNotExistError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: token_transfer_recipient_identity_not_exist_error :: TokenTransferRecipientIdentityNotExistError) -> * const dpp_errors_consensus_state_token_token_transfer_recipient_identity_not_exist_error_TokenTransferRecipientIdentityNotExistError { ferment :: boxed (dpp_errors_consensus_state_token_token_transfer_recipient_identity_not_exist_error_TokenTransferRecipientIdentityNotExistError { recipient_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . recipient_id) }) } } impl Drop for dpp_errors_consensus_state_token_token_transfer_recipient_identity_not_exist_error_TokenTransferRecipientIdentityNotExistError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . recipient_id) ; } } } } pub mod unauthorized_token_action_error { use crate as example_platform ; # [doc = "FFI-representation of the [`UnauthorizedTokenActionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub action : * mut std :: os :: raw :: c_char , pub authorized_action_takers : * mut crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: unauthorized_token_action_error :: UnauthorizedTokenActionError > for dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError) -> dpp :: errors :: consensus :: state :: token :: unauthorized_token_action_error :: UnauthorizedTokenActionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: unauthorized_token_action_error :: UnauthorizedTokenActionError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) , authorized_action_takers : < crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers as ferment :: FFIConversionFrom < dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers >> :: ffi_from (ffi_ref . authorized_action_takers) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: unauthorized_token_action_error :: UnauthorizedTokenActionError > for dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: unauthorized_token_action_error :: UnauthorizedTokenActionError) -> * const dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError { ferment :: boxed (dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) , authorized_action_takers : < crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers as ferment :: FFIConversionTo < dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers >> :: ffi_to (obj . authorized_action_takers) }) } } impl Drop for dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_string (ffi_ref . action) ; ferment :: unbox_any (ffi_ref . authorized_action_takers) ; } } } } } pub mod voting { pub mod masternode_incorrect_voter_identity_id_error { use crate as example_platform ; # [doc = "FFI-representation of the [`MasternodeIncorrectVoterIdentityIdError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError { pub pro_tx_hash : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub expected_voter_identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub provided_voter_identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voter_identity_id_error :: MasternodeIncorrectVoterIdentityIdError > for dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError) -> dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voter_identity_id_error :: MasternodeIncorrectVoterIdentityIdError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voter_identity_id_error :: MasternodeIncorrectVoterIdentityIdError { pro_tx_hash : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . pro_tx_hash) , expected_voter_identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . expected_voter_identity_id) , provided_voter_identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . provided_voter_identity_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voter_identity_id_error :: MasternodeIncorrectVoterIdentityIdError > for dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voter_identity_id_error :: MasternodeIncorrectVoterIdentityIdError) -> * const dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError { ferment :: boxed (dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError { pro_tx_hash : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . pro_tx_hash) , expected_voter_identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . expected_voter_identity_id) , provided_voter_identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . provided_voter_identity_id) }) } } impl Drop for dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . pro_tx_hash) ; ferment :: unbox_any (ffi_ref . expected_voter_identity_id) ; ferment :: unbox_any (ffi_ref . provided_voter_identity_id) ; } } } } pub mod masternode_incorrect_voting_address_error { use crate as example_platform ; # [doc = "FFI-representation of the [`MasternodeIncorrectVotingAddressError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError { pub pro_tx_hash : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub current_voting_address : * mut crate :: fermented :: types :: platform_value :: types :: bytes_20 :: platform_value_types_bytes_20_Bytes20 , pub given_voting_address : * mut crate :: fermented :: types :: platform_value :: types :: bytes_20 :: platform_value_types_bytes_20_Bytes20 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voting_address_error :: MasternodeIncorrectVotingAddressError > for dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError) -> dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voting_address_error :: MasternodeIncorrectVotingAddressError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voting_address_error :: MasternodeIncorrectVotingAddressError { pro_tx_hash : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . pro_tx_hash) , current_voting_address : < crate :: fermented :: types :: platform_value :: types :: bytes_20 :: platform_value_types_bytes_20_Bytes20 as ferment :: FFIConversionFrom < platform_value :: types :: bytes_20 :: Bytes20 >> :: ffi_from (ffi_ref . current_voting_address) , given_voting_address : < crate :: fermented :: types :: platform_value :: types :: bytes_20 :: platform_value_types_bytes_20_Bytes20 as ferment :: FFIConversionFrom < platform_value :: types :: bytes_20 :: Bytes20 >> :: ffi_from (ffi_ref . given_voting_address) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voting_address_error :: MasternodeIncorrectVotingAddressError > for dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voting_address_error :: MasternodeIncorrectVotingAddressError) -> * const dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError { ferment :: boxed (dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError { pro_tx_hash : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . pro_tx_hash) , current_voting_address : < crate :: fermented :: types :: platform_value :: types :: bytes_20 :: platform_value_types_bytes_20_Bytes20 as ferment :: FFIConversionTo < platform_value :: types :: bytes_20 :: Bytes20 >> :: ffi_to (obj . current_voting_address) , given_voting_address : < crate :: fermented :: types :: platform_value :: types :: bytes_20 :: platform_value_types_bytes_20_Bytes20 as ferment :: FFIConversionTo < platform_value :: types :: bytes_20 :: Bytes20 >> :: ffi_to (obj . given_voting_address) }) } } impl Drop for dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . pro_tx_hash) ; ferment :: unbox_any (ffi_ref . current_voting_address) ; ferment :: unbox_any (ffi_ref . given_voting_address) ; } } } } pub mod masternode_not_found_error { use crate as example_platform ; # [doc = "FFI-representation of the [`MasternodeNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError { pub pro_tx_hash : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: masternode_not_found_error :: MasternodeNotFoundError > for dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError) -> dpp :: errors :: consensus :: state :: voting :: masternode_not_found_error :: MasternodeNotFoundError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: voting :: masternode_not_found_error :: MasternodeNotFoundError { pro_tx_hash : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . pro_tx_hash) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: masternode_not_found_error :: MasternodeNotFoundError > for dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: voting :: masternode_not_found_error :: MasternodeNotFoundError) -> * const dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError { ferment :: boxed (dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError { pro_tx_hash : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . pro_tx_hash) }) } } impl Drop for dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . pro_tx_hash) ; } } } } pub mod masternode_vote_already_present_error { use crate as example_platform ; # [doc = "FFI-representation of the [`MasternodeVoteAlreadyPresentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError { pub pro_tx_hash : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: masternode_vote_already_present_error :: MasternodeVoteAlreadyPresentError > for dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError) -> dpp :: errors :: consensus :: state :: voting :: masternode_vote_already_present_error :: MasternodeVoteAlreadyPresentError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: voting :: masternode_vote_already_present_error :: MasternodeVoteAlreadyPresentError { pro_tx_hash : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . pro_tx_hash) , vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll as ferment :: FFIConversionFrom < dpp :: voting :: vote_polls :: VotePoll >> :: ffi_from (ffi_ref . vote_poll) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: masternode_vote_already_present_error :: MasternodeVoteAlreadyPresentError > for dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: voting :: masternode_vote_already_present_error :: MasternodeVoteAlreadyPresentError) -> * const dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError { ferment :: boxed (dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError { pro_tx_hash : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . pro_tx_hash) , vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll as ferment :: FFIConversionTo < dpp :: voting :: vote_polls :: VotePoll >> :: ffi_to (obj . vote_poll) }) } } impl Drop for dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . pro_tx_hash) ; ferment :: unbox_any (ffi_ref . vote_poll) ; } } } } pub mod masternode_voted_too_many_times { use crate as example_platform ; # [doc = "FFI-representation of the [`MasternodeVotedTooManyTimesError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError { pub pro_tx_hash : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub times_already_voted : u16 , pub max_times_allowed : u16 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: masternode_voted_too_many_times :: MasternodeVotedTooManyTimesError > for dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError) -> dpp :: errors :: consensus :: state :: voting :: masternode_voted_too_many_times :: MasternodeVotedTooManyTimesError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: voting :: masternode_voted_too_many_times :: MasternodeVotedTooManyTimesError { pro_tx_hash : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . pro_tx_hash) , times_already_voted : ffi_ref . times_already_voted , max_times_allowed : ffi_ref . max_times_allowed } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: masternode_voted_too_many_times :: MasternodeVotedTooManyTimesError > for dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: voting :: masternode_voted_too_many_times :: MasternodeVotedTooManyTimesError) -> * const dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError { ferment :: boxed (dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError { pro_tx_hash : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . pro_tx_hash) , times_already_voted : obj . times_already_voted , max_times_allowed : obj . max_times_allowed }) } } impl Drop for dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . pro_tx_hash) ; ; ; } } } } pub mod vote_poll_not_available_for_voting_error { use crate as example_platform ; # [doc = "FFI-representation of the [`VotePollNotAvailableForVotingError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError { pub vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll , pub status : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: vote_poll_not_available_for_voting_error :: VotePollNotAvailableForVotingError > for dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError) -> dpp :: errors :: consensus :: state :: voting :: vote_poll_not_available_for_voting_error :: VotePollNotAvailableForVotingError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: voting :: vote_poll_not_available_for_voting_error :: VotePollNotAvailableForVotingError { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll as ferment :: FFIConversionFrom < dpp :: voting :: vote_polls :: VotePoll >> :: ffi_from (ffi_ref . vote_poll) , status : < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus as ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus >> :: ffi_from (ffi_ref . status) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: vote_poll_not_available_for_voting_error :: VotePollNotAvailableForVotingError > for dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: voting :: vote_poll_not_available_for_voting_error :: VotePollNotAvailableForVotingError) -> * const dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError { ferment :: boxed (dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll as ferment :: FFIConversionTo < dpp :: voting :: vote_polls :: VotePoll >> :: ffi_to (obj . vote_poll) , status : < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus as ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus >> :: ffi_to (obj . status) }) } } impl Drop for dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . vote_poll) ; ferment :: unbox_any (ffi_ref . status) ; } } } } pub mod vote_poll_not_found_error { use crate as example_platform ; # [doc = "FFI-representation of the [`VotePollNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError { pub vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: vote_poll_not_found_error :: VotePollNotFoundError > for dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError) -> dpp :: errors :: consensus :: state :: voting :: vote_poll_not_found_error :: VotePollNotFoundError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: voting :: vote_poll_not_found_error :: VotePollNotFoundError { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll as ferment :: FFIConversionFrom < dpp :: voting :: vote_polls :: VotePoll >> :: ffi_from (ffi_ref . vote_poll) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: vote_poll_not_found_error :: VotePollNotFoundError > for dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: voting :: vote_poll_not_found_error :: VotePollNotFoundError) -> * const dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError { ferment :: boxed (dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll as ferment :: FFIConversionTo < dpp :: voting :: vote_polls :: VotePoll >> :: ffi_to (obj . vote_poll) }) } } impl Drop for dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . vote_poll) ; } } } } } } # [cfg (test)] pub mod test_consensus_error { use crate as example_platform ; # [doc = "FFI-representation of the [`TestConsensusError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_test_consensus_error_TestConsensusError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: test_consensus_error :: TestConsensusError > for dpp_errors_consensus_test_consensus_error_TestConsensusError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_test_consensus_error_TestConsensusError) -> dpp :: errors :: consensus :: test_consensus_error :: TestConsensusError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: test_consensus_error :: TestConsensusError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: test_consensus_error :: TestConsensusError > for dpp_errors_consensus_test_consensus_error_TestConsensusError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: test_consensus_error :: TestConsensusError) -> * const dpp_errors_consensus_test_consensus_error_TestConsensusError { ferment :: boxed (dpp_errors_consensus_test_consensus_error_TestConsensusError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_test_consensus_error_TestConsensusError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } } } pub mod dpp_init_error { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DashPlatformProtocolInitError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_errors_dpp_init_error_DashPlatformProtocolInitError { SchemaDeserializationError (* mut crate :: fermented :: types :: platform_value :: error :: platform_value_error_Error) , InvalidSchemaError (* mut std :: os :: raw :: c_char) , UnknownVersionMismatch { method : * mut std :: os :: raw :: c_char , known_versions : * mut crate :: fermented :: generics :: Vec_dpp_version_FeatureVersion , received : * mut dpp :: version :: FeatureVersion } } impl ferment :: FFIConversionFrom < dpp :: errors :: dpp_init_error :: DashPlatformProtocolInitError > for dpp_errors_dpp_init_error_DashPlatformProtocolInitError { unsafe fn ffi_from_const (ffi : * const dpp_errors_dpp_init_error_DashPlatformProtocolInitError) -> dpp :: errors :: dpp_init_error :: DashPlatformProtocolInitError { let ffi_ref = & * ffi ; match ffi_ref { dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: SchemaDeserializationError (o_0) => dpp :: errors :: dpp_init_error :: DashPlatformProtocolInitError :: SchemaDeserializationError (< crate :: fermented :: types :: platform_value :: error :: platform_value_error_Error as ferment :: FFIConversionFrom < platform_value :: error :: Error >> :: ffi_from (* o_0)) , dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: InvalidSchemaError (o_0) => dpp :: errors :: dpp_init_error :: DashPlatformProtocolInitError :: InvalidSchemaError (Box :: leak (Box :: new (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < & str >> :: ffi_from (* o_0)))) , dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: UnknownVersionMismatch { method , known_versions , received } => dpp :: errors :: dpp_init_error :: DashPlatformProtocolInitError :: UnknownVersionMismatch { method : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* method) , known_versions : < crate :: fermented :: generics :: Vec_dpp_version_FeatureVersion as ferment :: FFIConversionFrom < Vec < dpp :: version :: FeatureVersion > >> :: ffi_from (* known_versions) , received : std :: ptr :: read (* received) } } } } impl ferment :: FFIConversionTo < dpp :: errors :: dpp_init_error :: DashPlatformProtocolInitError > for dpp_errors_dpp_init_error_DashPlatformProtocolInitError { unsafe fn ffi_to_const (obj : dpp :: errors :: dpp_init_error :: DashPlatformProtocolInitError) -> * const dpp_errors_dpp_init_error_DashPlatformProtocolInitError { ferment :: boxed (match obj { dpp :: errors :: dpp_init_error :: DashPlatformProtocolInitError :: SchemaDeserializationError (o_0) => dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: SchemaDeserializationError (< crate :: fermented :: types :: platform_value :: error :: platform_value_error_Error as ferment :: FFIConversionTo < platform_value :: error :: Error >> :: ffi_to (o_0)) , dpp :: errors :: dpp_init_error :: DashPlatformProtocolInitError :: InvalidSchemaError (o_0) => dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: InvalidSchemaError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < & str >> :: ffi_to (o_0)) , dpp :: errors :: dpp_init_error :: DashPlatformProtocolInitError :: UnknownVersionMismatch { method , known_versions , received } => dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: UnknownVersionMismatch { method : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (method) , known_versions : < crate :: fermented :: generics :: Vec_dpp_version_FeatureVersion as ferment :: FFIConversionTo < Vec < dpp :: version :: FeatureVersion > >> :: ffi_to (known_versions) , received : ferment :: boxed (received) } , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_errors_dpp_init_error_DashPlatformProtocolInitError { fn drop (& mut self) { unsafe { match self { dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: SchemaDeserializationError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: InvalidSchemaError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: UnknownVersionMismatch { method , known_versions , received } => { ferment :: unbox_string (* method) ; ; ferment :: unbox_any (* known_versions) ; ; ferment :: unbox_any (* received) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod invalid_vector_size_error { use crate as example_platform ; # [doc = "FFI-representation of the [`InvalidVectorSizeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_invalid_vector_size_error_InvalidVectorSizeError { pub expected_size : usize , pub actual_size : usize } impl ferment :: FFIConversionFrom < dpp :: errors :: invalid_vector_size_error :: InvalidVectorSizeError > for dpp_errors_invalid_vector_size_error_InvalidVectorSizeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_invalid_vector_size_error_InvalidVectorSizeError) -> dpp :: errors :: invalid_vector_size_error :: InvalidVectorSizeError { let ffi_ref = & * ffi ; dpp :: errors :: invalid_vector_size_error :: InvalidVectorSizeError { expected_size : ffi_ref . expected_size , actual_size : ffi_ref . actual_size } } } impl ferment :: FFIConversionTo < dpp :: errors :: invalid_vector_size_error :: InvalidVectorSizeError > for dpp_errors_invalid_vector_size_error_InvalidVectorSizeError { unsafe fn ffi_to_const (obj : dpp :: errors :: invalid_vector_size_error :: InvalidVectorSizeError) -> * const dpp_errors_invalid_vector_size_error_InvalidVectorSizeError { ferment :: boxed (dpp_errors_invalid_vector_size_error_InvalidVectorSizeError { expected_size : obj . expected_size , actual_size : obj . actual_size }) } } } pub mod non_consensus_error { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`NonConsensusError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_errors_non_consensus_error_NonConsensusError { ValueError (* mut crate :: fermented :: types :: platform_value :: error :: platform_value_error_Error) , UnknownVersionMismatch { method : * mut std :: os :: raw :: c_char , known_versions : * mut crate :: fermented :: generics :: Vec_dpp_version_FeatureVersion , received : * mut dpp :: version :: FeatureVersion } , SerdeParsingError (* mut crate :: fermented :: types :: dpp :: errors :: serde_parsing_error :: dpp_errors_serde_parsing_error_SerdeParsingError) , CompatibleProtocolVersionIsNotDefinedError (* mut crate :: fermented :: types :: dpp :: errors :: compatible_protocol_version_is_not_defined_error :: dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError) , SerdeJsonError (* mut std :: os :: raw :: c_char) , InvalidVectorSizeError (* mut crate :: fermented :: types :: dpp :: errors :: invalid_vector_size_error :: dpp_errors_invalid_vector_size_error_InvalidVectorSizeError) , StateRepositoryFetchError (* mut std :: os :: raw :: c_char) , WithdrawalError (* mut std :: os :: raw :: c_char) , IdentifierCreateError (* mut std :: os :: raw :: c_char) , StateTransitionCreationError (* mut std :: os :: raw :: c_char) , IdentityPublicKeyCreateError (* mut std :: os :: raw :: c_char) , RequiredPropertyError { property_name : * mut std :: os :: raw :: c_char } , InvalidDataProcessedError (* mut std :: os :: raw :: c_char) , ObjectCreationError { object_name : * mut std :: os :: raw :: c_char , details : * mut std :: os :: raw :: c_char } , DPPError (* mut crate :: fermented :: types :: dpp :: errors :: dpp_error :: dpp_errors_dpp_error_DPPError) , Error (* mut crate :: fermented :: types :: platform_value :: error :: platform_value_error_Error) , Overflow (* mut std :: os :: raw :: c_char) } impl ferment :: FFIConversionFrom < dpp :: errors :: non_consensus_error :: NonConsensusError > for dpp_errors_non_consensus_error_NonConsensusError { unsafe fn ffi_from_const (ffi : * const dpp_errors_non_consensus_error_NonConsensusError) -> dpp :: errors :: non_consensus_error :: NonConsensusError { let ffi_ref = & * ffi ; match ffi_ref { dpp_errors_non_consensus_error_NonConsensusError :: ValueError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: ValueError (< crate :: fermented :: types :: platform_value :: error :: platform_value_error_Error as ferment :: FFIConversionFrom < platform_value :: error :: Error >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: UnknownVersionMismatch { method , known_versions , received } => dpp :: errors :: non_consensus_error :: NonConsensusError :: UnknownVersionMismatch { method : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* method) , known_versions : < crate :: fermented :: generics :: Vec_dpp_version_FeatureVersion as ferment :: FFIConversionFrom < Vec < dpp :: version :: FeatureVersion > >> :: ffi_from (* known_versions) , received : std :: ptr :: read (* received) } , dpp_errors_non_consensus_error_NonConsensusError :: SerdeParsingError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: SerdeParsingError (< crate :: fermented :: types :: dpp :: errors :: serde_parsing_error :: dpp_errors_serde_parsing_error_SerdeParsingError as ferment :: FFIConversionFrom < dpp :: errors :: serde_parsing_error :: SerdeParsingError >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: CompatibleProtocolVersionIsNotDefinedError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: CompatibleProtocolVersionIsNotDefinedError (< crate :: fermented :: types :: dpp :: errors :: compatible_protocol_version_is_not_defined_error :: dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError as ferment :: FFIConversionFrom < dpp :: errors :: compatible_protocol_version_is_not_defined_error :: CompatibleProtocolVersionIsNotDefinedError >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: SerdeJsonError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: SerdeJsonError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: InvalidVectorSizeError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: InvalidVectorSizeError (< crate :: fermented :: types :: dpp :: errors :: invalid_vector_size_error :: dpp_errors_invalid_vector_size_error_InvalidVectorSizeError as ferment :: FFIConversionFrom < dpp :: errors :: invalid_vector_size_error :: InvalidVectorSizeError >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: StateRepositoryFetchError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: StateRepositoryFetchError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: WithdrawalError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: WithdrawalError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: IdentifierCreateError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: IdentifierCreateError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: StateTransitionCreationError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: StateTransitionCreationError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: IdentityPublicKeyCreateError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: IdentityPublicKeyCreateError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: RequiredPropertyError { property_name } => dpp :: errors :: non_consensus_error :: NonConsensusError :: RequiredPropertyError { property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* property_name) } , dpp_errors_non_consensus_error_NonConsensusError :: InvalidDataProcessedError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: InvalidDataProcessedError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: ObjectCreationError { object_name , details } => dpp :: errors :: non_consensus_error :: NonConsensusError :: ObjectCreationError { object_name : Box :: leak (Box :: new (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < & str >> :: ffi_from (* object_name))) , details : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* details) } , dpp_errors_non_consensus_error_NonConsensusError :: DPPError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: DPPError (< crate :: fermented :: types :: dpp :: errors :: dpp_error :: dpp_errors_dpp_error_DPPError as ferment :: FFIConversionFrom < dpp :: errors :: dpp_error :: DPPError >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: Error (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: Error (< crate :: fermented :: types :: platform_value :: error :: platform_value_error_Error as ferment :: FFIConversionFrom < platform_value :: error :: Error >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: Overflow (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: Overflow (Box :: leak (Box :: new (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < & str >> :: ffi_from (* o_0)))) } } } impl ferment :: FFIConversionTo < dpp :: errors :: non_consensus_error :: NonConsensusError > for dpp_errors_non_consensus_error_NonConsensusError { unsafe fn ffi_to_const (obj : dpp :: errors :: non_consensus_error :: NonConsensusError) -> * const dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (match obj { dpp :: errors :: non_consensus_error :: NonConsensusError :: ValueError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: ValueError (< crate :: fermented :: types :: platform_value :: error :: platform_value_error_Error as ferment :: FFIConversionTo < platform_value :: error :: Error >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: UnknownVersionMismatch { method , known_versions , received } => dpp_errors_non_consensus_error_NonConsensusError :: UnknownVersionMismatch { method : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (method) , known_versions : < crate :: fermented :: generics :: Vec_dpp_version_FeatureVersion as ferment :: FFIConversionTo < Vec < dpp :: version :: FeatureVersion > >> :: ffi_to (known_versions) , received : ferment :: boxed (received) } , dpp :: errors :: non_consensus_error :: NonConsensusError :: SerdeParsingError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: SerdeParsingError (< crate :: fermented :: types :: dpp :: errors :: serde_parsing_error :: dpp_errors_serde_parsing_error_SerdeParsingError as ferment :: FFIConversionTo < dpp :: errors :: serde_parsing_error :: SerdeParsingError >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: CompatibleProtocolVersionIsNotDefinedError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: CompatibleProtocolVersionIsNotDefinedError (< crate :: fermented :: types :: dpp :: errors :: compatible_protocol_version_is_not_defined_error :: dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError as ferment :: FFIConversionTo < dpp :: errors :: compatible_protocol_version_is_not_defined_error :: CompatibleProtocolVersionIsNotDefinedError >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: SerdeJsonError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: SerdeJsonError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: InvalidVectorSizeError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: InvalidVectorSizeError (< crate :: fermented :: types :: dpp :: errors :: invalid_vector_size_error :: dpp_errors_invalid_vector_size_error_InvalidVectorSizeError as ferment :: FFIConversionTo < dpp :: errors :: invalid_vector_size_error :: InvalidVectorSizeError >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: StateRepositoryFetchError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: StateRepositoryFetchError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: WithdrawalError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: WithdrawalError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: IdentifierCreateError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: IdentifierCreateError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: StateTransitionCreationError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: StateTransitionCreationError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: IdentityPublicKeyCreateError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: IdentityPublicKeyCreateError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: RequiredPropertyError { property_name } => dpp_errors_non_consensus_error_NonConsensusError :: RequiredPropertyError { property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (property_name) } , dpp :: errors :: non_consensus_error :: NonConsensusError :: InvalidDataProcessedError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: InvalidDataProcessedError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: ObjectCreationError { object_name , details } => dpp_errors_non_consensus_error_NonConsensusError :: ObjectCreationError { object_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < & str >> :: ffi_to (object_name) , details : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (details) } , dpp :: errors :: non_consensus_error :: NonConsensusError :: DPPError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: DPPError (< crate :: fermented :: types :: dpp :: errors :: dpp_error :: dpp_errors_dpp_error_DPPError as ferment :: FFIConversionTo < dpp :: errors :: dpp_error :: DPPError >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: Error (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: Error (< crate :: fermented :: types :: platform_value :: error :: platform_value_error_Error as ferment :: FFIConversionTo < platform_value :: error :: Error >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: Overflow (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: Overflow (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < & str >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_errors_non_consensus_error_NonConsensusError { fn drop (& mut self) { unsafe { match self { dpp_errors_non_consensus_error_NonConsensusError :: ValueError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: UnknownVersionMismatch { method , known_versions , received } => { ferment :: unbox_string (* method) ; ; ferment :: unbox_any (* known_versions) ; ; ferment :: unbox_any (* received) ; } , dpp_errors_non_consensus_error_NonConsensusError :: SerdeParsingError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: CompatibleProtocolVersionIsNotDefinedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: SerdeJsonError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: InvalidVectorSizeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: StateRepositoryFetchError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: WithdrawalError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: IdentifierCreateError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: StateTransitionCreationError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: IdentityPublicKeyCreateError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: RequiredPropertyError { property_name } => { ferment :: unbox_string (* property_name) ; } , dpp_errors_non_consensus_error_NonConsensusError :: InvalidDataProcessedError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: ObjectCreationError { object_name , details } => { ferment :: unbox_string (* object_name) ; ; ferment :: unbox_string (* details) ; } , dpp_errors_non_consensus_error_NonConsensusError :: DPPError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: Error (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: Overflow (o_0) => { ferment :: unbox_string (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod public_key_validation_error { use crate as example_platform ; # [doc = "FFI-representation of the [`PublicKeyValidationError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_public_key_validation_error_PublicKeyValidationError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: public_key_validation_error :: PublicKeyValidationError > for dpp_errors_public_key_validation_error_PublicKeyValidationError { unsafe fn ffi_from_const (ffi : * const dpp_errors_public_key_validation_error_PublicKeyValidationError) -> dpp :: errors :: public_key_validation_error :: PublicKeyValidationError { let ffi_ref = & * ffi ; dpp :: errors :: public_key_validation_error :: PublicKeyValidationError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: public_key_validation_error :: PublicKeyValidationError > for dpp_errors_public_key_validation_error_PublicKeyValidationError { unsafe fn ffi_to_const (obj : dpp :: errors :: public_key_validation_error :: PublicKeyValidationError) -> * const dpp_errors_public_key_validation_error_PublicKeyValidationError { ferment :: boxed (dpp_errors_public_key_validation_error_PublicKeyValidationError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_public_key_validation_error_PublicKeyValidationError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } } pub mod serde_parsing_error { use crate as example_platform ; # [doc = "FFI-representation of the [`SerdeParsingError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_serde_parsing_error_SerdeParsingError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: serde_parsing_error :: SerdeParsingError > for dpp_errors_serde_parsing_error_SerdeParsingError { unsafe fn ffi_from_const (ffi : * const dpp_errors_serde_parsing_error_SerdeParsingError) -> dpp :: errors :: serde_parsing_error :: SerdeParsingError { let ffi_ref = & * ffi ; dpp :: errors :: serde_parsing_error :: SerdeParsingError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: serde_parsing_error :: SerdeParsingError > for dpp_errors_serde_parsing_error_SerdeParsingError { unsafe fn ffi_to_const (obj : dpp :: errors :: serde_parsing_error :: SerdeParsingError) -> * const dpp_errors_serde_parsing_error_SerdeParsingError { ferment :: boxed (dpp_errors_serde_parsing_error_SerdeParsingError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_serde_parsing_error_SerdeParsingError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } } pub mod protocol_error { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ProtocolError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_errors_protocol_error_ProtocolError { IdentifierError (* mut std :: os :: raw :: c_char) , StringDecodeError (* mut std :: os :: raw :: c_char) , EmptyPublicKeyDataError , MaxEncodedBytesReachedError { max_size_kbytes : usize , size_hit : usize } , EncodingError (* mut std :: os :: raw :: c_char) , DecodingError (* mut std :: os :: raw :: c_char) , FileNotFound (* mut std :: os :: raw :: c_char) , UnsupportedVersionMismatch { method : * mut std :: os :: raw :: c_char , allowed_versions : * mut crate :: fermented :: generics :: Vec_dpp_version_FeatureVersion , received : * mut dpp :: version :: FeatureVersion } , UnknownVersionMismatch { method : * mut std :: os :: raw :: c_char , known_versions : * mut crate :: fermented :: generics :: Vec_dpp_version_FeatureVersion , received : * mut dpp :: version :: FeatureVersion } , CurrentProtocolVersionNotInitialized , UnknownVersionError (* mut std :: os :: raw :: c_char) , UnknownProtocolVersionError (* mut std :: os :: raw :: c_char) , NoProtocolVersionError , ParsingError (* mut std :: os :: raw :: c_char) , ParsingJsonError (* mut crate :: fermented :: types :: platform_value :: error :: platform_value_error_Error) , Error (* mut crate :: fermented :: types :: platform_value :: error :: platform_value_error_Error) , InvalidKeyContractBoundsError (* mut std :: os :: raw :: c_char) , UnknownStorageKeyRequirements (* mut std :: os :: raw :: c_char) , UnknownContestedIndexResolution (* mut std :: os :: raw :: c_char) , DataContractError (* mut crate :: fermented :: types :: dpp :: data_contract :: errors :: contract :: dpp_data_contract_errors_contract_DataContractError) , # [cfg (all (feature = "state-transitions" , feature = "validation"))] StateTransitionError (* mut crate :: fermented :: types :: dpp :: state_transition :: errors :: state_transition_error :: dpp_state_transition_errors_state_transition_error_StateTransitionError) , InvalidStateTransitionType (* mut std :: os :: raw :: c_char) , PlatformVersionError (* mut crate :: fermented :: types :: platform_version :: error :: platform_version_error_PlatformVersionError) , ConsensusError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: consensus_error :: dpp_errors_consensus_consensus_error_ConsensusError) , Document (* mut crate :: fermented :: types :: dpp :: document :: errors :: dpp_document_errors_DocumentError) , Token (* mut crate :: fermented :: types :: dpp :: tokens :: errors :: dpp_tokens_errors_TokenError) , Generic (* mut std :: os :: raw :: c_char) , NotSupported (* mut std :: os :: raw :: c_char) , # [cfg (feature = "message-signing")] InvalidSigningKeyTypeError (* mut std :: os :: raw :: c_char) , # [cfg (any (feature = "state-transition-validation" , feature = "state-transition-signing"))] InvalidIdentityPublicKeyTypeError (* mut crate :: fermented :: types :: dpp :: state_transition :: errors :: invalid_identity_public_key_type_error :: dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) , # [cfg (feature = "state-transition-validation")] StateTransitionIsNotSignedError (* mut crate :: fermented :: types :: dpp :: state_transition :: errors :: state_transition_is_not_signed_error :: dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError) , # [cfg (feature = "state-transition-validation")] PublicKeySecurityLevelNotMetError (* mut crate :: fermented :: types :: dpp :: state_transition :: errors :: public_key_security_level_not_met_error :: dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError) , # [cfg (any (all (feature = "state-transitions" , feature = "validation") , feature = "state-transition-validation" , feature = "state-transition-signing" , feature = "state-transition-validation"))] WrongPublicKeyPurposeError (* mut crate :: fermented :: types :: dpp :: state_transition :: errors :: wrong_public_key_purpose_error :: dpp_state_transition_errors_wrong_public_key_purpose_error_WrongPublicKeyPurposeError) , # [cfg (feature = "state-transition-validation")] PublicKeyMismatchError (* mut crate :: fermented :: types :: dpp :: state_transition :: errors :: public_key_mismatch_error :: dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError) , # [cfg (feature = "state-transition-validation")] InvalidSignaturePublicKeyError (* mut crate :: fermented :: types :: dpp :: state_transition :: errors :: invalid_signature_public_key_error :: dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError) , NonConsensusError (* mut crate :: fermented :: types :: dpp :: errors :: non_consensus_error :: dpp_errors_non_consensus_error_NonConsensusError) , CompatibleProtocolVersionIsNotDefinedError (* mut crate :: fermented :: types :: dpp :: errors :: compatible_protocol_version_is_not_defined_error :: dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError) , InvalidDocumentTypeError (* mut crate :: fermented :: types :: dpp :: data_contract :: errors :: invalid_document_type_error :: dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError) , DataContractNotPresentError (* mut crate :: fermented :: types :: dpp :: data_contract :: errors :: data_contract_not_present_error :: dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError) , InvalidSignaturePublicKeySecurityLevelError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError) , InvalidStateTransitionTypeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError) , PublicKeyIsDisabledError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError) , IdentityNotPresentError (* mut crate :: fermented :: types :: dpp :: data_contract :: errors :: identity_not_present_error :: dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError) , Overflow (* mut std :: os :: raw :: c_char) , DivideByZero (* mut std :: os :: raw :: c_char) , DesiredKeyWithTypePurposeSecurityLevelMissing (* mut std :: os :: raw :: c_char) , ValueError (* mut crate :: fermented :: types :: platform_value :: error :: platform_value_error_Error) , PlatformSerializationError (* mut std :: os :: raw :: c_char) , PlatformDeserializationError (* mut std :: os :: raw :: c_char) , DashCoreError (* mut crate :: fermented :: types :: platform_value :: error :: platform_value_error_Error) , InvalidIdentityError { errors : * mut crate :: fermented :: generics :: Vec_dpp_errors_consensus_consensus_error_ConsensusError , raw_identity : * mut crate :: fermented :: types :: platform_value :: platform_value_Value } , VoteError (* mut std :: os :: raw :: c_char) , PublicKeyGenerationError (* mut std :: os :: raw :: c_char) , GroupMemberNotFound (* mut std :: os :: raw :: c_char) , GroupNotFound (* mut std :: os :: raw :: c_char) , CorruptedCodeExecution (* mut std :: os :: raw :: c_char) , CorruptedSerialization (* mut std :: os :: raw :: c_char) , CriticalCorruptedCreditsCodeExecution (* mut std :: os :: raw :: c_char) , InvalidVectorSizeError (* mut crate :: fermented :: types :: dpp :: errors :: invalid_vector_size_error :: dpp_errors_invalid_vector_size_error_InvalidVectorSizeError) , InvalidCBOR (* mut std :: os :: raw :: c_char) , # [cfg (feature = "bls-signatures")] BlsError (* mut dashcore :: blsful :: BlsError) , PrivateKeySizeError { got : u32 } , InvalidBLSPrivateKeyError (* mut std :: os :: raw :: c_char) , BlsSignatureSizeError { got : u32 } , AddingDifferentTypes (* mut std :: os :: raw :: c_char) , InvalidDistributionStep (* mut std :: os :: raw :: c_char) , MissingEpochInfo (* mut std :: os :: raw :: c_char) , InvalidBatchedTransitionActionVariant { expected : * mut std :: os :: raw :: c_char , found : * mut std :: os :: raw :: c_char } } impl ferment :: FFIConversionFrom < dpp :: errors :: protocol_error :: ProtocolError > for dpp_errors_protocol_error_ProtocolError { unsafe fn ffi_from_const (ffi : * const dpp_errors_protocol_error_ProtocolError) -> dpp :: errors :: protocol_error :: ProtocolError { let ffi_ref = & * ffi ; match ffi_ref { dpp_errors_protocol_error_ProtocolError :: IdentifierError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: IdentifierError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: StringDecodeError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: StringDecodeError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: EmptyPublicKeyDataError => dpp :: errors :: protocol_error :: ProtocolError :: EmptyPublicKeyDataError , dpp_errors_protocol_error_ProtocolError :: MaxEncodedBytesReachedError { max_size_kbytes , size_hit } => dpp :: errors :: protocol_error :: ProtocolError :: MaxEncodedBytesReachedError { max_size_kbytes : * max_size_kbytes , size_hit : * size_hit } , dpp_errors_protocol_error_ProtocolError :: EncodingError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: EncodingError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: DecodingError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: DecodingError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: FileNotFound (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: FileNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: UnsupportedVersionMismatch { method , allowed_versions , received } => dpp :: errors :: protocol_error :: ProtocolError :: UnsupportedVersionMismatch { method : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* method) , allowed_versions : < crate :: fermented :: generics :: Vec_dpp_version_FeatureVersion as ferment :: FFIConversionFrom < Vec < dpp :: version :: FeatureVersion > >> :: ffi_from (* allowed_versions) , received : std :: ptr :: read (* received) } , dpp_errors_protocol_error_ProtocolError :: UnknownVersionMismatch { method , known_versions , received } => dpp :: errors :: protocol_error :: ProtocolError :: UnknownVersionMismatch { method : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* method) , known_versions : < crate :: fermented :: generics :: Vec_dpp_version_FeatureVersion as ferment :: FFIConversionFrom < Vec < dpp :: version :: FeatureVersion > >> :: ffi_from (* known_versions) , received : std :: ptr :: read (* received) } , dpp_errors_protocol_error_ProtocolError :: CurrentProtocolVersionNotInitialized => dpp :: errors :: protocol_error :: ProtocolError :: CurrentProtocolVersionNotInitialized , dpp_errors_protocol_error_ProtocolError :: UnknownVersionError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: UnknownVersionError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: UnknownProtocolVersionError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: UnknownProtocolVersionError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: NoProtocolVersionError => dpp :: errors :: protocol_error :: ProtocolError :: NoProtocolVersionError , dpp_errors_protocol_error_ProtocolError :: ParsingError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: ParsingError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: ParsingJsonError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: ParsingJsonError (< crate :: fermented :: types :: platform_value :: error :: platform_value_error_Error as ferment :: FFIConversionFrom < platform_value :: error :: Error >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: Error (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: Error (< crate :: fermented :: types :: platform_value :: error :: platform_value_error_Error as ferment :: FFIConversionFrom < platform_value :: error :: Error >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: InvalidKeyContractBoundsError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidKeyContractBoundsError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: UnknownStorageKeyRequirements (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: UnknownStorageKeyRequirements (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: UnknownContestedIndexResolution (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: UnknownContestedIndexResolution (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: DataContractError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: DataContractError (< crate :: fermented :: types :: dpp :: data_contract :: errors :: contract :: dpp_data_contract_errors_contract_DataContractError as ferment :: FFIConversionFrom < dpp :: data_contract :: errors :: contract :: DataContractError >> :: ffi_from (* o_0)) , # [cfg (all (feature = "state-transitions" , feature = "validation"))] dpp_errors_protocol_error_ProtocolError :: StateTransitionError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: StateTransitionError (< crate :: fermented :: types :: dpp :: state_transition :: errors :: state_transition_error :: dpp_state_transition_errors_state_transition_error_StateTransitionError as ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: state_transition_error :: StateTransitionError >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: InvalidStateTransitionType (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidStateTransitionType (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: PlatformVersionError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: PlatformVersionError (< crate :: fermented :: types :: platform_version :: error :: platform_version_error_PlatformVersionError as ferment :: FFIConversionFrom < platform_version :: error :: PlatformVersionError >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: ConsensusError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: ConsensusError (Box :: new (< crate :: fermented :: types :: dpp :: errors :: consensus :: consensus_error :: dpp_errors_consensus_consensus_error_ConsensusError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: consensus_error :: ConsensusError >> :: ffi_from (* o_0))) , dpp_errors_protocol_error_ProtocolError :: Document (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: Document (Box :: new (< crate :: fermented :: types :: dpp :: document :: errors :: dpp_document_errors_DocumentError as ferment :: FFIConversionFrom < dpp :: document :: errors :: DocumentError >> :: ffi_from (* o_0))) , dpp_errors_protocol_error_ProtocolError :: Token (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: Token (Box :: new (< crate :: fermented :: types :: dpp :: tokens :: errors :: dpp_tokens_errors_TokenError as ferment :: FFIConversionFrom < dpp :: tokens :: errors :: TokenError >> :: ffi_from (* o_0))) , dpp_errors_protocol_error_ProtocolError :: Generic (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: Generic (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: NotSupported (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: NotSupported (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , # [cfg (feature = "message-signing")] dpp_errors_protocol_error_ProtocolError :: InvalidSigningKeyTypeError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidSigningKeyTypeError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , # [cfg (any (feature = "state-transition-validation" , feature = "state-transition-signing"))] dpp_errors_protocol_error_ProtocolError :: InvalidIdentityPublicKeyTypeError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidIdentityPublicKeyTypeError (< crate :: fermented :: types :: dpp :: state_transition :: errors :: invalid_identity_public_key_type_error :: dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError as ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError >> :: ffi_from (* o_0)) , # [cfg (feature = "state-transition-validation")] dpp_errors_protocol_error_ProtocolError :: StateTransitionIsNotSignedError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: StateTransitionIsNotSignedError (< crate :: fermented :: types :: dpp :: state_transition :: errors :: state_transition_is_not_signed_error :: dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError as ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: state_transition_is_not_signed_error :: StateTransitionIsNotSignedError >> :: ffi_from (* o_0)) , # [cfg (feature = "state-transition-validation")] dpp_errors_protocol_error_ProtocolError :: PublicKeySecurityLevelNotMetError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: PublicKeySecurityLevelNotMetError (< crate :: fermented :: types :: dpp :: state_transition :: errors :: public_key_security_level_not_met_error :: dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError as ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError >> :: ffi_from (* o_0)) , # [cfg (any (all (feature = "state-transitions" , feature = "validation") , feature = "state-transition-validation" , feature = "state-transition-signing" , feature = "state-transition-validation"))] dpp_errors_protocol_error_ProtocolError :: WrongPublicKeyPurposeError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: WrongPublicKeyPurposeError (< crate :: fermented :: types :: dpp :: state_transition :: errors :: wrong_public_key_purpose_error :: dpp_state_transition_errors_wrong_public_key_purpose_error_WrongPublicKeyPurposeError as ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError >> :: ffi_from (* o_0)) , # [cfg (feature = "state-transition-validation")] dpp_errors_protocol_error_ProtocolError :: PublicKeyMismatchError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: PublicKeyMismatchError (< crate :: fermented :: types :: dpp :: state_transition :: errors :: public_key_mismatch_error :: dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError as ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: public_key_mismatch_error :: PublicKeyMismatchError >> :: ffi_from (* o_0)) , # [cfg (feature = "state-transition-validation")] dpp_errors_protocol_error_ProtocolError :: InvalidSignaturePublicKeyError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidSignaturePublicKeyError (< crate :: fermented :: types :: dpp :: state_transition :: errors :: invalid_signature_public_key_error :: dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError as ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: invalid_signature_public_key_error :: InvalidSignaturePublicKeyError >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: NonConsensusError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: NonConsensusError (< crate :: fermented :: types :: dpp :: errors :: non_consensus_error :: dpp_errors_non_consensus_error_NonConsensusError as ferment :: FFIConversionFrom < dpp :: errors :: non_consensus_error :: NonConsensusError >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: CompatibleProtocolVersionIsNotDefinedError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: CompatibleProtocolVersionIsNotDefinedError (< crate :: fermented :: types :: dpp :: errors :: compatible_protocol_version_is_not_defined_error :: dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError as ferment :: FFIConversionFrom < dpp :: errors :: compatible_protocol_version_is_not_defined_error :: CompatibleProtocolVersionIsNotDefinedError >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: InvalidDocumentTypeError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidDocumentTypeError (< crate :: fermented :: types :: dpp :: data_contract :: errors :: invalid_document_type_error :: dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError as ferment :: FFIConversionFrom < dpp :: data_contract :: errors :: invalid_document_type_error :: InvalidDocumentTypeError >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: DataContractNotPresentError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: DataContractNotPresentError (< crate :: fermented :: types :: dpp :: data_contract :: errors :: data_contract_not_present_error :: dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError as ferment :: FFIConversionFrom < dpp :: data_contract :: errors :: data_contract_not_present_error :: DataContractNotPresentError >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: InvalidSignaturePublicKeySecurityLevelError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidSignaturePublicKeySecurityLevelError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: InvalidSignaturePublicKeySecurityLevelError >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: InvalidStateTransitionTypeError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidStateTransitionTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: InvalidStateTransitionTypeError >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: PublicKeyIsDisabledError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: PublicKeyIsDisabledError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: PublicKeyIsDisabledError >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: IdentityNotPresentError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: IdentityNotPresentError (< crate :: fermented :: types :: dpp :: data_contract :: errors :: identity_not_present_error :: dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError as ferment :: FFIConversionFrom < dpp :: data_contract :: errors :: identity_not_present_error :: IdentityNotPresentError >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: Overflow (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: Overflow (Box :: leak (Box :: new (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < & str >> :: ffi_from (* o_0)))) , dpp_errors_protocol_error_ProtocolError :: DivideByZero (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: DivideByZero (Box :: leak (Box :: new (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < & str >> :: ffi_from (* o_0)))) , dpp_errors_protocol_error_ProtocolError :: DesiredKeyWithTypePurposeSecurityLevelMissing (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: DesiredKeyWithTypePurposeSecurityLevelMissing (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: ValueError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: ValueError (< crate :: fermented :: types :: platform_value :: error :: platform_value_error_Error as ferment :: FFIConversionFrom < platform_value :: error :: Error >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: PlatformSerializationError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: PlatformSerializationError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: PlatformDeserializationError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: PlatformDeserializationError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: DashCoreError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: DashCoreError (< crate :: fermented :: types :: platform_value :: error :: platform_value_error_Error as ferment :: FFIConversionFrom < platform_value :: error :: Error >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: InvalidIdentityError { errors , raw_identity } => dpp :: errors :: protocol_error :: ProtocolError :: InvalidIdentityError { errors : < crate :: fermented :: generics :: Vec_dpp_errors_consensus_consensus_error_ConsensusError as ferment :: FFIConversionFrom < Vec < dpp :: errors :: consensus :: consensus_error :: ConsensusError > >> :: ffi_from (* errors) , raw_identity : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (* raw_identity) } , dpp_errors_protocol_error_ProtocolError :: VoteError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: VoteError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: PublicKeyGenerationError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: PublicKeyGenerationError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: GroupMemberNotFound (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: GroupMemberNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: GroupNotFound (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: GroupNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: CorruptedCodeExecution (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: CorruptedCodeExecution (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: CorruptedSerialization (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: CorruptedSerialization (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: CriticalCorruptedCreditsCodeExecution (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: CriticalCorruptedCreditsCodeExecution (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: InvalidVectorSizeError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidVectorSizeError (< crate :: fermented :: types :: dpp :: errors :: invalid_vector_size_error :: dpp_errors_invalid_vector_size_error_InvalidVectorSizeError as ferment :: FFIConversionFrom < dpp :: errors :: invalid_vector_size_error :: InvalidVectorSizeError >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: InvalidCBOR (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidCBOR (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , # [cfg (feature = "bls-signatures")] dpp_errors_protocol_error_ProtocolError :: BlsError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: BlsError (std :: ptr :: read (* o_0)) , dpp_errors_protocol_error_ProtocolError :: PrivateKeySizeError { got } => dpp :: errors :: protocol_error :: ProtocolError :: PrivateKeySizeError { got : * got } , dpp_errors_protocol_error_ProtocolError :: InvalidBLSPrivateKeyError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidBLSPrivateKeyError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: BlsSignatureSizeError { got } => dpp :: errors :: protocol_error :: ProtocolError :: BlsSignatureSizeError { got : * got } , dpp_errors_protocol_error_ProtocolError :: AddingDifferentTypes (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: AddingDifferentTypes (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: InvalidDistributionStep (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidDistributionStep (Box :: leak (Box :: new (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < & str >> :: ffi_from (* o_0)))) , dpp_errors_protocol_error_ProtocolError :: MissingEpochInfo (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: MissingEpochInfo (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: InvalidBatchedTransitionActionVariant { expected , found } => dpp :: errors :: protocol_error :: ProtocolError :: InvalidBatchedTransitionActionVariant { expected : Box :: leak (Box :: new (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < & str >> :: ffi_from (* expected))) , found : Box :: leak (Box :: new (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < & str >> :: ffi_from (* found))) } } } } impl ferment :: FFIConversionTo < dpp :: errors :: protocol_error :: ProtocolError > for dpp_errors_protocol_error_ProtocolError { unsafe fn ffi_to_const (obj : dpp :: errors :: protocol_error :: ProtocolError) -> * const dpp_errors_protocol_error_ProtocolError { ferment :: boxed (match obj { dpp :: errors :: protocol_error :: ProtocolError :: IdentifierError (o_0) => dpp_errors_protocol_error_ProtocolError :: IdentifierError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: StringDecodeError (o_0) => dpp_errors_protocol_error_ProtocolError :: StringDecodeError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: EmptyPublicKeyDataError => dpp_errors_protocol_error_ProtocolError :: EmptyPublicKeyDataError , dpp :: errors :: protocol_error :: ProtocolError :: MaxEncodedBytesReachedError { max_size_kbytes , size_hit } => dpp_errors_protocol_error_ProtocolError :: MaxEncodedBytesReachedError { max_size_kbytes : max_size_kbytes , size_hit : size_hit } , dpp :: errors :: protocol_error :: ProtocolError :: EncodingError (o_0) => dpp_errors_protocol_error_ProtocolError :: EncodingError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: DecodingError (o_0) => dpp_errors_protocol_error_ProtocolError :: DecodingError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: FileNotFound (o_0) => dpp_errors_protocol_error_ProtocolError :: FileNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: UnsupportedVersionMismatch { method , allowed_versions , received } => dpp_errors_protocol_error_ProtocolError :: UnsupportedVersionMismatch { method : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (method) , allowed_versions : < crate :: fermented :: generics :: Vec_dpp_version_FeatureVersion as ferment :: FFIConversionTo < Vec < dpp :: version :: FeatureVersion > >> :: ffi_to (allowed_versions) , received : ferment :: boxed (received) } , dpp :: errors :: protocol_error :: ProtocolError :: UnknownVersionMismatch { method , known_versions , received } => dpp_errors_protocol_error_ProtocolError :: UnknownVersionMismatch { method : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (method) , known_versions : < crate :: fermented :: generics :: Vec_dpp_version_FeatureVersion as ferment :: FFIConversionTo < Vec < dpp :: version :: FeatureVersion > >> :: ffi_to (known_versions) , received : ferment :: boxed (received) } , dpp :: errors :: protocol_error :: ProtocolError :: CurrentProtocolVersionNotInitialized => dpp_errors_protocol_error_ProtocolError :: CurrentProtocolVersionNotInitialized , dpp :: errors :: protocol_error :: ProtocolError :: UnknownVersionError (o_0) => dpp_errors_protocol_error_ProtocolError :: UnknownVersionError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: UnknownProtocolVersionError (o_0) => dpp_errors_protocol_error_ProtocolError :: UnknownProtocolVersionError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: NoProtocolVersionError => dpp_errors_protocol_error_ProtocolError :: NoProtocolVersionError , dpp :: errors :: protocol_error :: ProtocolError :: ParsingError (o_0) => dpp_errors_protocol_error_ProtocolError :: ParsingError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: ParsingJsonError (o_0) => dpp_errors_protocol_error_ProtocolError :: ParsingJsonError (< crate :: fermented :: types :: platform_value :: error :: platform_value_error_Error as ferment :: FFIConversionTo < platform_value :: error :: Error >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: Error (o_0) => dpp_errors_protocol_error_ProtocolError :: Error (< crate :: fermented :: types :: platform_value :: error :: platform_value_error_Error as ferment :: FFIConversionTo < platform_value :: error :: Error >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: InvalidKeyContractBoundsError (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidKeyContractBoundsError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: UnknownStorageKeyRequirements (o_0) => dpp_errors_protocol_error_ProtocolError :: UnknownStorageKeyRequirements (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: UnknownContestedIndexResolution (o_0) => dpp_errors_protocol_error_ProtocolError :: UnknownContestedIndexResolution (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: DataContractError (o_0) => dpp_errors_protocol_error_ProtocolError :: DataContractError (< crate :: fermented :: types :: dpp :: data_contract :: errors :: contract :: dpp_data_contract_errors_contract_DataContractError as ferment :: FFIConversionTo < dpp :: data_contract :: errors :: contract :: DataContractError >> :: ffi_to (o_0)) , # [cfg (all (feature = "state-transitions" , feature = "validation"))] dpp :: errors :: protocol_error :: ProtocolError :: StateTransitionError (o_0) => dpp_errors_protocol_error_ProtocolError :: StateTransitionError (< crate :: fermented :: types :: dpp :: state_transition :: errors :: state_transition_error :: dpp_state_transition_errors_state_transition_error_StateTransitionError as ferment :: FFIConversionTo < dpp :: state_transition :: errors :: state_transition_error :: StateTransitionError >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: InvalidStateTransitionType (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidStateTransitionType (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: PlatformVersionError (o_0) => dpp_errors_protocol_error_ProtocolError :: PlatformVersionError (< crate :: fermented :: types :: platform_version :: error :: platform_version_error_PlatformVersionError as ferment :: FFIConversionTo < platform_version :: error :: PlatformVersionError >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: ConsensusError (o_0) => dpp_errors_protocol_error_ProtocolError :: ConsensusError (< crate :: fermented :: types :: dpp :: errors :: consensus :: consensus_error :: dpp_errors_consensus_consensus_error_ConsensusError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: consensus_error :: ConsensusError >> :: ffi_to (* o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: Document (o_0) => dpp_errors_protocol_error_ProtocolError :: Document (< crate :: fermented :: types :: dpp :: document :: errors :: dpp_document_errors_DocumentError as ferment :: FFIConversionTo < dpp :: document :: errors :: DocumentError >> :: ffi_to (* o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: Token (o_0) => dpp_errors_protocol_error_ProtocolError :: Token (< crate :: fermented :: types :: dpp :: tokens :: errors :: dpp_tokens_errors_TokenError as ferment :: FFIConversionTo < dpp :: tokens :: errors :: TokenError >> :: ffi_to (* o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: Generic (o_0) => dpp_errors_protocol_error_ProtocolError :: Generic (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: NotSupported (o_0) => dpp_errors_protocol_error_ProtocolError :: NotSupported (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , # [cfg (feature = "message-signing")] dpp :: errors :: protocol_error :: ProtocolError :: InvalidSigningKeyTypeError (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidSigningKeyTypeError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , # [cfg (any (feature = "state-transition-validation" , feature = "state-transition-signing"))] dpp :: errors :: protocol_error :: ProtocolError :: InvalidIdentityPublicKeyTypeError (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidIdentityPublicKeyTypeError (< crate :: fermented :: types :: dpp :: state_transition :: errors :: invalid_identity_public_key_type_error :: dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError as ferment :: FFIConversionTo < dpp :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError >> :: ffi_to (o_0)) , # [cfg (feature = "state-transition-validation")] dpp :: errors :: protocol_error :: ProtocolError :: StateTransitionIsNotSignedError (o_0) => dpp_errors_protocol_error_ProtocolError :: StateTransitionIsNotSignedError (< crate :: fermented :: types :: dpp :: state_transition :: errors :: state_transition_is_not_signed_error :: dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError as ferment :: FFIConversionTo < dpp :: state_transition :: errors :: state_transition_is_not_signed_error :: StateTransitionIsNotSignedError >> :: ffi_to (o_0)) , # [cfg (feature = "state-transition-validation")] dpp :: errors :: protocol_error :: ProtocolError :: PublicKeySecurityLevelNotMetError (o_0) => dpp_errors_protocol_error_ProtocolError :: PublicKeySecurityLevelNotMetError (< crate :: fermented :: types :: dpp :: state_transition :: errors :: public_key_security_level_not_met_error :: dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError as ferment :: FFIConversionTo < dpp :: state_transition :: errors :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError >> :: ffi_to (o_0)) , # [cfg (any (all (feature = "state-transitions" , feature = "validation") , feature = "state-transition-validation" , feature = "state-transition-signing" , feature = "state-transition-validation"))] dpp :: errors :: protocol_error :: ProtocolError :: WrongPublicKeyPurposeError (o_0) => dpp_errors_protocol_error_ProtocolError :: WrongPublicKeyPurposeError (< crate :: fermented :: types :: dpp :: state_transition :: errors :: wrong_public_key_purpose_error :: dpp_state_transition_errors_wrong_public_key_purpose_error_WrongPublicKeyPurposeError as ferment :: FFIConversionTo < dpp :: state_transition :: errors :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError >> :: ffi_to (o_0)) , # [cfg (feature = "state-transition-validation")] dpp :: errors :: protocol_error :: ProtocolError :: PublicKeyMismatchError (o_0) => dpp_errors_protocol_error_ProtocolError :: PublicKeyMismatchError (< crate :: fermented :: types :: dpp :: state_transition :: errors :: public_key_mismatch_error :: dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError as ferment :: FFIConversionTo < dpp :: state_transition :: errors :: public_key_mismatch_error :: PublicKeyMismatchError >> :: ffi_to (o_0)) , # [cfg (feature = "state-transition-validation")] dpp :: errors :: protocol_error :: ProtocolError :: InvalidSignaturePublicKeyError (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidSignaturePublicKeyError (< crate :: fermented :: types :: dpp :: state_transition :: errors :: invalid_signature_public_key_error :: dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError as ferment :: FFIConversionTo < dpp :: state_transition :: errors :: invalid_signature_public_key_error :: InvalidSignaturePublicKeyError >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: NonConsensusError (o_0) => dpp_errors_protocol_error_ProtocolError :: NonConsensusError (< crate :: fermented :: types :: dpp :: errors :: non_consensus_error :: dpp_errors_non_consensus_error_NonConsensusError as ferment :: FFIConversionTo < dpp :: errors :: non_consensus_error :: NonConsensusError >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: CompatibleProtocolVersionIsNotDefinedError (o_0) => dpp_errors_protocol_error_ProtocolError :: CompatibleProtocolVersionIsNotDefinedError (< crate :: fermented :: types :: dpp :: errors :: compatible_protocol_version_is_not_defined_error :: dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError as ferment :: FFIConversionTo < dpp :: errors :: compatible_protocol_version_is_not_defined_error :: CompatibleProtocolVersionIsNotDefinedError >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: InvalidDocumentTypeError (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidDocumentTypeError (< crate :: fermented :: types :: dpp :: data_contract :: errors :: invalid_document_type_error :: dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError as ferment :: FFIConversionTo < dpp :: data_contract :: errors :: invalid_document_type_error :: InvalidDocumentTypeError >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: DataContractNotPresentError (o_0) => dpp_errors_protocol_error_ProtocolError :: DataContractNotPresentError (< crate :: fermented :: types :: dpp :: data_contract :: errors :: data_contract_not_present_error :: dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError as ferment :: FFIConversionTo < dpp :: data_contract :: errors :: data_contract_not_present_error :: DataContractNotPresentError >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: InvalidSignaturePublicKeySecurityLevelError (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidSignaturePublicKeySecurityLevelError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: InvalidSignaturePublicKeySecurityLevelError >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: InvalidStateTransitionTypeError (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidStateTransitionTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: InvalidStateTransitionTypeError >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: PublicKeyIsDisabledError (o_0) => dpp_errors_protocol_error_ProtocolError :: PublicKeyIsDisabledError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: PublicKeyIsDisabledError >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: IdentityNotPresentError (o_0) => dpp_errors_protocol_error_ProtocolError :: IdentityNotPresentError (< crate :: fermented :: types :: dpp :: data_contract :: errors :: identity_not_present_error :: dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError as ferment :: FFIConversionTo < dpp :: data_contract :: errors :: identity_not_present_error :: IdentityNotPresentError >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: Overflow (o_0) => dpp_errors_protocol_error_ProtocolError :: Overflow (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < & str >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: DivideByZero (o_0) => dpp_errors_protocol_error_ProtocolError :: DivideByZero (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < & str >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: DesiredKeyWithTypePurposeSecurityLevelMissing (o_0) => dpp_errors_protocol_error_ProtocolError :: DesiredKeyWithTypePurposeSecurityLevelMissing (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: ValueError (o_0) => dpp_errors_protocol_error_ProtocolError :: ValueError (< crate :: fermented :: types :: platform_value :: error :: platform_value_error_Error as ferment :: FFIConversionTo < platform_value :: error :: Error >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: PlatformSerializationError (o_0) => dpp_errors_protocol_error_ProtocolError :: PlatformSerializationError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: PlatformDeserializationError (o_0) => dpp_errors_protocol_error_ProtocolError :: PlatformDeserializationError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: DashCoreError (o_0) => dpp_errors_protocol_error_ProtocolError :: DashCoreError (< crate :: fermented :: types :: platform_value :: error :: platform_value_error_Error as ferment :: FFIConversionTo < platform_value :: error :: Error >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: InvalidIdentityError { errors , raw_identity } => dpp_errors_protocol_error_ProtocolError :: InvalidIdentityError { errors : < crate :: fermented :: generics :: Vec_dpp_errors_consensus_consensus_error_ConsensusError as ferment :: FFIConversionTo < Vec < dpp :: errors :: consensus :: consensus_error :: ConsensusError > >> :: ffi_to (errors) , raw_identity : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (raw_identity) } , dpp :: errors :: protocol_error :: ProtocolError :: VoteError (o_0) => dpp_errors_protocol_error_ProtocolError :: VoteError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: PublicKeyGenerationError (o_0) => dpp_errors_protocol_error_ProtocolError :: PublicKeyGenerationError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: GroupMemberNotFound (o_0) => dpp_errors_protocol_error_ProtocolError :: GroupMemberNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: GroupNotFound (o_0) => dpp_errors_protocol_error_ProtocolError :: GroupNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: CorruptedCodeExecution (o_0) => dpp_errors_protocol_error_ProtocolError :: CorruptedCodeExecution (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: CorruptedSerialization (o_0) => dpp_errors_protocol_error_ProtocolError :: CorruptedSerialization (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: CriticalCorruptedCreditsCodeExecution (o_0) => dpp_errors_protocol_error_ProtocolError :: CriticalCorruptedCreditsCodeExecution (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: InvalidVectorSizeError (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidVectorSizeError (< crate :: fermented :: types :: dpp :: errors :: invalid_vector_size_error :: dpp_errors_invalid_vector_size_error_InvalidVectorSizeError as ferment :: FFIConversionTo < dpp :: errors :: invalid_vector_size_error :: InvalidVectorSizeError >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: InvalidCBOR (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidCBOR (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , # [cfg (feature = "bls-signatures")] dpp :: errors :: protocol_error :: ProtocolError :: BlsError (o_0) => dpp_errors_protocol_error_ProtocolError :: BlsError (ferment :: boxed (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: PrivateKeySizeError { got } => dpp_errors_protocol_error_ProtocolError :: PrivateKeySizeError { got : got } , dpp :: errors :: protocol_error :: ProtocolError :: InvalidBLSPrivateKeyError (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidBLSPrivateKeyError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: BlsSignatureSizeError { got } => dpp_errors_protocol_error_ProtocolError :: BlsSignatureSizeError { got : got } , dpp :: errors :: protocol_error :: ProtocolError :: AddingDifferentTypes (o_0) => dpp_errors_protocol_error_ProtocolError :: AddingDifferentTypes (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: InvalidDistributionStep (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidDistributionStep (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < & str >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: MissingEpochInfo (o_0) => dpp_errors_protocol_error_ProtocolError :: MissingEpochInfo (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: InvalidBatchedTransitionActionVariant { expected , found } => dpp_errors_protocol_error_ProtocolError :: InvalidBatchedTransitionActionVariant { expected : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < & str >> :: ffi_to (expected) , found : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < & str >> :: ffi_to (found) } , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_errors_protocol_error_ProtocolError { fn drop (& mut self) { unsafe { match self { dpp_errors_protocol_error_ProtocolError :: IdentifierError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: StringDecodeError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: EmptyPublicKeyDataError => { } , dpp_errors_protocol_error_ProtocolError :: MaxEncodedBytesReachedError { max_size_kbytes , size_hit } => { ; ; ; } , dpp_errors_protocol_error_ProtocolError :: EncodingError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: DecodingError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: FileNotFound (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: UnsupportedVersionMismatch { method , allowed_versions , received } => { ferment :: unbox_string (* method) ; ; ferment :: unbox_any (* allowed_versions) ; ; ferment :: unbox_any (* received) ; } , dpp_errors_protocol_error_ProtocolError :: UnknownVersionMismatch { method , known_versions , received } => { ferment :: unbox_string (* method) ; ; ferment :: unbox_any (* known_versions) ; ; ferment :: unbox_any (* received) ; } , dpp_errors_protocol_error_ProtocolError :: CurrentProtocolVersionNotInitialized => { } , dpp_errors_protocol_error_ProtocolError :: UnknownVersionError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: UnknownProtocolVersionError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: NoProtocolVersionError => { } , dpp_errors_protocol_error_ProtocolError :: ParsingError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: ParsingJsonError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: Error (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: InvalidKeyContractBoundsError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: UnknownStorageKeyRequirements (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: UnknownContestedIndexResolution (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: DataContractError (o_0) => { ferment :: unbox_any (* o_0) ; } , # [cfg (all (feature = "state-transitions" , feature = "validation"))] dpp_errors_protocol_error_ProtocolError :: StateTransitionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: InvalidStateTransitionType (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: PlatformVersionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: ConsensusError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: Document (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: Token (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: Generic (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: NotSupported (o_0) => { ferment :: unbox_string (* o_0) ; } , # [cfg (feature = "message-signing")] dpp_errors_protocol_error_ProtocolError :: InvalidSigningKeyTypeError (o_0) => { ferment :: unbox_string (* o_0) ; } , # [cfg (any (feature = "state-transition-validation" , feature = "state-transition-signing"))] dpp_errors_protocol_error_ProtocolError :: InvalidIdentityPublicKeyTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , # [cfg (feature = "state-transition-validation")] dpp_errors_protocol_error_ProtocolError :: StateTransitionIsNotSignedError (o_0) => { ferment :: unbox_any (* o_0) ; } , # [cfg (feature = "state-transition-validation")] dpp_errors_protocol_error_ProtocolError :: PublicKeySecurityLevelNotMetError (o_0) => { ferment :: unbox_any (* o_0) ; } , # [cfg (any (all (feature = "state-transitions" , feature = "validation") , feature = "state-transition-validation" , feature = "state-transition-signing" , feature = "state-transition-validation"))] dpp_errors_protocol_error_ProtocolError :: WrongPublicKeyPurposeError (o_0) => { ferment :: unbox_any (* o_0) ; } , # [cfg (feature = "state-transition-validation")] dpp_errors_protocol_error_ProtocolError :: PublicKeyMismatchError (o_0) => { ferment :: unbox_any (* o_0) ; } , # [cfg (feature = "state-transition-validation")] dpp_errors_protocol_error_ProtocolError :: InvalidSignaturePublicKeyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: NonConsensusError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: CompatibleProtocolVersionIsNotDefinedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: InvalidDocumentTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: DataContractNotPresentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: InvalidSignaturePublicKeySecurityLevelError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: InvalidStateTransitionTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: PublicKeyIsDisabledError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: IdentityNotPresentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: Overflow (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: DivideByZero (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: DesiredKeyWithTypePurposeSecurityLevelMissing (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: ValueError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: PlatformSerializationError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: PlatformDeserializationError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: DashCoreError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: InvalidIdentityError { errors , raw_identity } => { ferment :: unbox_any (* errors) ; ; ferment :: unbox_any (* raw_identity) ; } , dpp_errors_protocol_error_ProtocolError :: VoteError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: PublicKeyGenerationError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: GroupMemberNotFound (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: GroupNotFound (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: CorruptedCodeExecution (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: CorruptedSerialization (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: CriticalCorruptedCreditsCodeExecution (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: InvalidVectorSizeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: InvalidCBOR (o_0) => { ferment :: unbox_string (* o_0) ; } , # [cfg (feature = "bls-signatures")] dpp_errors_protocol_error_ProtocolError :: BlsError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: PrivateKeySizeError { got } => { ; } , dpp_errors_protocol_error_ProtocolError :: InvalidBLSPrivateKeyError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: BlsSignatureSizeError { got } => { ; } , dpp_errors_protocol_error_ProtocolError :: AddingDifferentTypes (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: InvalidDistributionStep (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: MissingEpochInfo (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: InvalidBatchedTransitionActionVariant { expected , found } => { ferment :: unbox_string (* expected) ; ; ferment :: unbox_string (* found) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod dpp_error { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DPPError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_errors_dpp_error_DPPError { AssetLockOutputNotFoundError (* mut crate :: fermented :: types :: dpp :: identity :: errors :: asset_lock_output_not_found_error :: dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError) , AssetLockTransactionIsNotFoundError (* mut crate :: fermented :: types :: dpp :: identity :: errors :: asset_lock_transaction_is_not_found_error :: dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError) , WrongPublicKeyHashSize , WrongBurnOutputType , InvalidAssetLockTransaction , CoreMessageCorruption (* mut std :: os :: raw :: c_char) } impl ferment :: FFIConversionFrom < dpp :: errors :: dpp_error :: DPPError > for dpp_errors_dpp_error_DPPError { unsafe fn ffi_from_const (ffi : * const dpp_errors_dpp_error_DPPError) -> dpp :: errors :: dpp_error :: DPPError { let ffi_ref = & * ffi ; match ffi_ref { dpp_errors_dpp_error_DPPError :: AssetLockOutputNotFoundError (o_0) => dpp :: errors :: dpp_error :: DPPError :: AssetLockOutputNotFoundError (< crate :: fermented :: types :: dpp :: identity :: errors :: asset_lock_output_not_found_error :: dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError as ferment :: FFIConversionFrom < dpp :: identity :: errors :: asset_lock_output_not_found_error :: AssetLockOutputNotFoundError >> :: ffi_from (* o_0)) , dpp_errors_dpp_error_DPPError :: AssetLockTransactionIsNotFoundError (o_0) => dpp :: errors :: dpp_error :: DPPError :: AssetLockTransactionIsNotFoundError (< crate :: fermented :: types :: dpp :: identity :: errors :: asset_lock_transaction_is_not_found_error :: dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError as ferment :: FFIConversionFrom < dpp :: identity :: errors :: asset_lock_transaction_is_not_found_error :: AssetLockTransactionIsNotFoundError >> :: ffi_from (* o_0)) , dpp_errors_dpp_error_DPPError :: WrongPublicKeyHashSize => dpp :: errors :: dpp_error :: DPPError :: WrongPublicKeyHashSize , dpp_errors_dpp_error_DPPError :: WrongBurnOutputType => dpp :: errors :: dpp_error :: DPPError :: WrongBurnOutputType , dpp_errors_dpp_error_DPPError :: InvalidAssetLockTransaction => dpp :: errors :: dpp_error :: DPPError :: InvalidAssetLockTransaction , dpp_errors_dpp_error_DPPError :: CoreMessageCorruption (o_0) => dpp :: errors :: dpp_error :: DPPError :: CoreMessageCorruption (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: errors :: dpp_error :: DPPError > for dpp_errors_dpp_error_DPPError { unsafe fn ffi_to_const (obj : dpp :: errors :: dpp_error :: DPPError) -> * const dpp_errors_dpp_error_DPPError { ferment :: boxed (match obj { dpp :: errors :: dpp_error :: DPPError :: AssetLockOutputNotFoundError (o_0) => dpp_errors_dpp_error_DPPError :: AssetLockOutputNotFoundError (< crate :: fermented :: types :: dpp :: identity :: errors :: asset_lock_output_not_found_error :: dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError as ferment :: FFIConversionTo < dpp :: identity :: errors :: asset_lock_output_not_found_error :: AssetLockOutputNotFoundError >> :: ffi_to (o_0)) , dpp :: errors :: dpp_error :: DPPError :: AssetLockTransactionIsNotFoundError (o_0) => dpp_errors_dpp_error_DPPError :: AssetLockTransactionIsNotFoundError (< crate :: fermented :: types :: dpp :: identity :: errors :: asset_lock_transaction_is_not_found_error :: dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError as ferment :: FFIConversionTo < dpp :: identity :: errors :: asset_lock_transaction_is_not_found_error :: AssetLockTransactionIsNotFoundError >> :: ffi_to (o_0)) , dpp :: errors :: dpp_error :: DPPError :: WrongPublicKeyHashSize => dpp_errors_dpp_error_DPPError :: WrongPublicKeyHashSize , dpp :: errors :: dpp_error :: DPPError :: WrongBurnOutputType => dpp_errors_dpp_error_DPPError :: WrongBurnOutputType , dpp :: errors :: dpp_error :: DPPError :: InvalidAssetLockTransaction => dpp_errors_dpp_error_DPPError :: InvalidAssetLockTransaction , dpp :: errors :: dpp_error :: DPPError :: CoreMessageCorruption (o_0) => dpp_errors_dpp_error_DPPError :: CoreMessageCorruption (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_errors_dpp_error_DPPError { fn drop (& mut self) { unsafe { match self { dpp_errors_dpp_error_DPPError :: AssetLockOutputNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_dpp_error_DPPError :: AssetLockTransactionIsNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_dpp_error_DPPError :: WrongPublicKeyHashSize => { } , dpp_errors_dpp_error_DPPError :: WrongBurnOutputType => { } , dpp_errors_dpp_error_DPPError :: InvalidAssetLockTransaction => { } , dpp_errors_dpp_error_DPPError :: CoreMessageCorruption (o_0) => { ferment :: unbox_string (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } } pub mod balances { pub mod credits { use crate as example_platform ; # [doc = "FFI-representation of the [`Credits`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_balances_credits_Credits (u64) ; impl ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits > for dpp_balances_credits_Credits { unsafe fn ffi_from_const (ffi : * const dpp_balances_credits_Credits) -> dpp :: balances :: credits :: Credits { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits > for dpp_balances_credits_Credits { unsafe fn ffi_to_const (obj : dpp :: balances :: credits :: Credits) -> * const dpp_balances_credits_Credits { ferment :: boxed (dpp_balances_credits_Credits (obj)) } } # [doc = "FFI-representation of the [`TokenAmount`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_balances_credits_TokenAmount (u64) ; impl ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount > for dpp_balances_credits_TokenAmount { unsafe fn ffi_from_const (ffi : * const dpp_balances_credits_TokenAmount) -> dpp :: balances :: credits :: TokenAmount { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount > for dpp_balances_credits_TokenAmount { unsafe fn ffi_to_const (obj : dpp :: balances :: credits :: TokenAmount) -> * const dpp_balances_credits_TokenAmount { ferment :: boxed (dpp_balances_credits_TokenAmount (obj)) } } # [doc = "FFI-representation of the [`SignedCredits`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_balances_credits_SignedCredits (i64) ; impl ferment :: FFIConversionFrom < dpp :: balances :: credits :: SignedCredits > for dpp_balances_credits_SignedCredits { unsafe fn ffi_from_const (ffi : * const dpp_balances_credits_SignedCredits) -> dpp :: balances :: credits :: SignedCredits { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: balances :: credits :: SignedCredits > for dpp_balances_credits_SignedCredits { unsafe fn ffi_to_const (obj : dpp :: balances :: credits :: SignedCredits) -> * const dpp_balances_credits_SignedCredits { ferment :: boxed (dpp_balances_credits_SignedCredits (obj)) } } } } pub mod block { pub mod block_info { use crate as example_platform ; # [doc = "FFI-representation of the [`BlockInfo`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_block_block_info_BlockInfo { pub time_ms : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis , pub height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , pub core_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight , pub epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_Epoch } impl ferment :: FFIConversionFrom < dpp :: block :: block_info :: BlockInfo > for dpp_block_block_info_BlockInfo { unsafe fn ffi_from_const (ffi : * const dpp_block_block_info_BlockInfo) -> dpp :: block :: block_info :: BlockInfo { let ffi_ref = & * ffi ; dpp :: block :: block_info :: BlockInfo { time_ms : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionFrom < dpp :: prelude :: TimestampMillis >> :: ffi_from (ffi_ref . time_ms) , height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: BlockHeight >> :: ffi_from (ffi_ref . height) , core_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: CoreBlockHeight >> :: ffi_from (ffi_ref . core_height) , epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_Epoch as ferment :: FFIConversionFrom < dpp :: block :: epoch :: Epoch >> :: ffi_from (ffi_ref . epoch) } } } impl ferment :: FFIConversionTo < dpp :: block :: block_info :: BlockInfo > for dpp_block_block_info_BlockInfo { unsafe fn ffi_to_const (obj : dpp :: block :: block_info :: BlockInfo) -> * const dpp_block_block_info_BlockInfo { ferment :: boxed (dpp_block_block_info_BlockInfo { time_ms : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionTo < dpp :: prelude :: TimestampMillis >> :: ffi_to (obj . time_ms) , height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: BlockHeight >> :: ffi_to (obj . height) , core_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: CoreBlockHeight >> :: ffi_to (obj . core_height) , epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_Epoch as ferment :: FFIConversionTo < dpp :: block :: epoch :: Epoch >> :: ffi_to (obj . epoch) }) } } impl Drop for dpp_block_block_info_BlockInfo { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . time_ms) ; ferment :: unbox_any (ffi_ref . height) ; ferment :: unbox_any (ffi_ref . core_height) ; ferment :: unbox_any (ffi_ref . epoch) ; } } } } pub mod epoch { use crate as example_platform ; # [doc = "FFI-representation of the [`EpochIndex`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_block_epoch_EpochIndex (u16) ; impl ferment :: FFIConversionFrom < dpp :: block :: epoch :: EpochIndex > for dpp_block_epoch_EpochIndex { unsafe fn ffi_from_const (ffi : * const dpp_block_epoch_EpochIndex) -> dpp :: block :: epoch :: EpochIndex { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: block :: epoch :: EpochIndex > for dpp_block_epoch_EpochIndex { unsafe fn ffi_to_const (obj : dpp :: block :: epoch :: EpochIndex) -> * const dpp_block_epoch_EpochIndex { ferment :: boxed (dpp_block_epoch_EpochIndex (obj)) } } # [doc = "FFI-representation of the [`Epoch`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_block_epoch_Epoch { pub index : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex , pub key : * mut crate :: fermented :: generics :: Arr_u8_2 } impl ferment :: FFIConversionFrom < dpp :: block :: epoch :: Epoch > for dpp_block_epoch_Epoch { unsafe fn ffi_from_const (ffi : * const dpp_block_epoch_Epoch) -> dpp :: block :: epoch :: Epoch { let ffi_ref = & * ffi ; dpp :: block :: epoch :: Epoch { index : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionFrom < dpp :: block :: epoch :: EpochIndex >> :: ffi_from (ffi_ref . index) , key : < crate :: fermented :: generics :: Arr_u8_2 as ferment :: FFIConversionFrom < [u8 ; 2] >> :: ffi_from (ffi_ref . key) } } } impl ferment :: FFIConversionTo < dpp :: block :: epoch :: Epoch > for dpp_block_epoch_Epoch { unsafe fn ffi_to_const (obj : dpp :: block :: epoch :: Epoch) -> * const dpp_block_epoch_Epoch { ferment :: boxed (dpp_block_epoch_Epoch { index : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionTo < dpp :: block :: epoch :: EpochIndex >> :: ffi_to (obj . index) , key : < crate :: fermented :: generics :: Arr_u8_2 as ferment :: FFIConversionTo < [u8 ; 2] >> :: ffi_to (obj . key) }) } } impl Drop for dpp_block_epoch_Epoch { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . index) ; ferment :: unbox_any (ffi_ref . key) ; } } } } } pub mod nft { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TradeMode`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_nft_TradeMode { None = 0 , DirectPurchase = 1 } impl ferment :: FFIConversionFrom < dpp :: nft :: TradeMode > for dpp_nft_TradeMode { unsafe fn ffi_from_const (ffi : * const dpp_nft_TradeMode) -> dpp :: nft :: TradeMode { let ffi_ref = & * ffi ; match ffi_ref { dpp_nft_TradeMode :: None => dpp :: nft :: TradeMode :: None , dpp_nft_TradeMode :: DirectPurchase => dpp :: nft :: TradeMode :: DirectPurchase } } } impl ferment :: FFIConversionTo < dpp :: nft :: TradeMode > for dpp_nft_TradeMode { unsafe fn ffi_to_const (obj : dpp :: nft :: TradeMode) -> * const dpp_nft_TradeMode { ferment :: boxed (match obj { dpp :: nft :: TradeMode :: None => dpp_nft_TradeMode :: None , dpp :: nft :: TradeMode :: DirectPurchase => dpp_nft_TradeMode :: DirectPurchase , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_nft_TradeMode { fn drop (& mut self) { unsafe { match self { dpp_nft_TradeMode :: None => { } , dpp_nft_TradeMode :: DirectPurchase => { } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod tokens { use crate as example_platform ; pub mod emergency_action { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenEmergencyAction`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_tokens_emergency_action_TokenEmergencyAction { Pause = 0 , Resume = 1 } impl ferment :: FFIConversionFrom < dpp :: tokens :: emergency_action :: TokenEmergencyAction > for dpp_tokens_emergency_action_TokenEmergencyAction { unsafe fn ffi_from_const (ffi : * const dpp_tokens_emergency_action_TokenEmergencyAction) -> dpp :: tokens :: emergency_action :: TokenEmergencyAction { let ffi_ref = & * ffi ; match ffi_ref { dpp_tokens_emergency_action_TokenEmergencyAction :: Pause => dpp :: tokens :: emergency_action :: TokenEmergencyAction :: Pause , dpp_tokens_emergency_action_TokenEmergencyAction :: Resume => dpp :: tokens :: emergency_action :: TokenEmergencyAction :: Resume } } } impl ferment :: FFIConversionTo < dpp :: tokens :: emergency_action :: TokenEmergencyAction > for dpp_tokens_emergency_action_TokenEmergencyAction { unsafe fn ffi_to_const (obj : dpp :: tokens :: emergency_action :: TokenEmergencyAction) -> * const dpp_tokens_emergency_action_TokenEmergencyAction { ferment :: boxed (match obj { dpp :: tokens :: emergency_action :: TokenEmergencyAction :: Pause => dpp_tokens_emergency_action_TokenEmergencyAction :: Pause , dpp :: tokens :: emergency_action :: TokenEmergencyAction :: Resume => dpp_tokens_emergency_action_TokenEmergencyAction :: Resume , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_tokens_emergency_action_TokenEmergencyAction { fn drop (& mut self) { unsafe { match self { dpp_tokens_emergency_action_TokenEmergencyAction :: Pause => { } , dpp_tokens_emergency_action_TokenEmergencyAction :: Resume => { } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod errors { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_tokens_errors_TokenError { TokenNotFoundAtPositionError , TokenNotFoundOnContractVersion , TokenNoMintingRecipient } impl ferment :: FFIConversionFrom < dpp :: tokens :: errors :: TokenError > for dpp_tokens_errors_TokenError { unsafe fn ffi_from_const (ffi : * const dpp_tokens_errors_TokenError) -> dpp :: tokens :: errors :: TokenError { let ffi_ref = & * ffi ; match ffi_ref { dpp_tokens_errors_TokenError :: TokenNotFoundAtPositionError => dpp :: tokens :: errors :: TokenError :: TokenNotFoundAtPositionError , dpp_tokens_errors_TokenError :: TokenNotFoundOnContractVersion => dpp :: tokens :: errors :: TokenError :: TokenNotFoundOnContractVersion , dpp_tokens_errors_TokenError :: TokenNoMintingRecipient => dpp :: tokens :: errors :: TokenError :: TokenNoMintingRecipient } } } impl ferment :: FFIConversionTo < dpp :: tokens :: errors :: TokenError > for dpp_tokens_errors_TokenError { unsafe fn ffi_to_const (obj : dpp :: tokens :: errors :: TokenError) -> * const dpp_tokens_errors_TokenError { ferment :: boxed (match obj { dpp :: tokens :: errors :: TokenError :: TokenNotFoundAtPositionError => dpp_tokens_errors_TokenError :: TokenNotFoundAtPositionError , dpp :: tokens :: errors :: TokenError :: TokenNotFoundOnContractVersion => dpp_tokens_errors_TokenError :: TokenNotFoundOnContractVersion , dpp :: tokens :: errors :: TokenError :: TokenNoMintingRecipient => dpp_tokens_errors_TokenError :: TokenNoMintingRecipient , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_tokens_errors_TokenError { fn drop (& mut self) { unsafe { match self { dpp_tokens_errors_TokenError :: TokenNotFoundAtPositionError => { } , dpp_tokens_errors_TokenError :: TokenNotFoundOnContractVersion => { } , dpp_tokens_errors_TokenError :: TokenNoMintingRecipient => { } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod gas_fees_paid_by { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`GasFeesPaidBy`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_tokens_gas_fees_paid_by_GasFeesPaidBy { DocumentOwner = 0 , ContractOwner = 1 , PreferContractOwner = 2 } impl ferment :: FFIConversionFrom < dpp :: tokens :: gas_fees_paid_by :: GasFeesPaidBy > for dpp_tokens_gas_fees_paid_by_GasFeesPaidBy { unsafe fn ffi_from_const (ffi : * const dpp_tokens_gas_fees_paid_by_GasFeesPaidBy) -> dpp :: tokens :: gas_fees_paid_by :: GasFeesPaidBy { let ffi_ref = & * ffi ; match ffi_ref { dpp_tokens_gas_fees_paid_by_GasFeesPaidBy :: DocumentOwner => dpp :: tokens :: gas_fees_paid_by :: GasFeesPaidBy :: DocumentOwner , dpp_tokens_gas_fees_paid_by_GasFeesPaidBy :: ContractOwner => dpp :: tokens :: gas_fees_paid_by :: GasFeesPaidBy :: ContractOwner , dpp_tokens_gas_fees_paid_by_GasFeesPaidBy :: PreferContractOwner => dpp :: tokens :: gas_fees_paid_by :: GasFeesPaidBy :: PreferContractOwner } } } impl ferment :: FFIConversionTo < dpp :: tokens :: gas_fees_paid_by :: GasFeesPaidBy > for dpp_tokens_gas_fees_paid_by_GasFeesPaidBy { unsafe fn ffi_to_const (obj : dpp :: tokens :: gas_fees_paid_by :: GasFeesPaidBy) -> * const dpp_tokens_gas_fees_paid_by_GasFeesPaidBy { ferment :: boxed (match obj { dpp :: tokens :: gas_fees_paid_by :: GasFeesPaidBy :: DocumentOwner => dpp_tokens_gas_fees_paid_by_GasFeesPaidBy :: DocumentOwner , dpp :: tokens :: gas_fees_paid_by :: GasFeesPaidBy :: ContractOwner => dpp_tokens_gas_fees_paid_by_GasFeesPaidBy :: ContractOwner , dpp :: tokens :: gas_fees_paid_by :: GasFeesPaidBy :: PreferContractOwner => dpp_tokens_gas_fees_paid_by_GasFeesPaidBy :: PreferContractOwner , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_tokens_gas_fees_paid_by_GasFeesPaidBy { fn drop (& mut self) { unsafe { match self { dpp_tokens_gas_fees_paid_by_GasFeesPaidBy :: DocumentOwner => { } , dpp_tokens_gas_fees_paid_by_GasFeesPaidBy :: ContractOwner => { } , dpp_tokens_gas_fees_paid_by_GasFeesPaidBy :: PreferContractOwner => { } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod info { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`IdentityTokenInfoV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_tokens_info_v0_IdentityTokenInfoV0 { pub frozen : bool } impl ferment :: FFIConversionFrom < dpp :: tokens :: info :: v0 :: IdentityTokenInfoV0 > for dpp_tokens_info_v0_IdentityTokenInfoV0 { unsafe fn ffi_from_const (ffi : * const dpp_tokens_info_v0_IdentityTokenInfoV0) -> dpp :: tokens :: info :: v0 :: IdentityTokenInfoV0 { let ffi_ref = & * ffi ; dpp :: tokens :: info :: v0 :: IdentityTokenInfoV0 { frozen : ffi_ref . frozen } } } impl ferment :: FFIConversionTo < dpp :: tokens :: info :: v0 :: IdentityTokenInfoV0 > for dpp_tokens_info_v0_IdentityTokenInfoV0 { unsafe fn ffi_to_const (obj : dpp :: tokens :: info :: v0 :: IdentityTokenInfoV0) -> * const dpp_tokens_info_v0_IdentityTokenInfoV0 { ferment :: boxed (dpp_tokens_info_v0_IdentityTokenInfoV0 { frozen : obj . frozen }) } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`IdentityTokenInfo`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_tokens_info_IdentityTokenInfo { V0 (* mut crate :: fermented :: types :: dpp :: tokens :: info :: v0 :: dpp_tokens_info_v0_IdentityTokenInfoV0) } impl ferment :: FFIConversionFrom < dpp :: tokens :: info :: IdentityTokenInfo > for dpp_tokens_info_IdentityTokenInfo { unsafe fn ffi_from_const (ffi : * const dpp_tokens_info_IdentityTokenInfo) -> dpp :: tokens :: info :: IdentityTokenInfo { let ffi_ref = & * ffi ; match ffi_ref { dpp_tokens_info_IdentityTokenInfo :: V0 (o_0) => dpp :: tokens :: info :: IdentityTokenInfo :: V0 (< crate :: fermented :: types :: dpp :: tokens :: info :: v0 :: dpp_tokens_info_v0_IdentityTokenInfoV0 as ferment :: FFIConversionFrom < dpp :: tokens :: info :: v0 :: IdentityTokenInfoV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: tokens :: info :: IdentityTokenInfo > for dpp_tokens_info_IdentityTokenInfo { unsafe fn ffi_to_const (obj : dpp :: tokens :: info :: IdentityTokenInfo) -> * const dpp_tokens_info_IdentityTokenInfo { ferment :: boxed (match obj { dpp :: tokens :: info :: IdentityTokenInfo :: V0 (o_0) => dpp_tokens_info_IdentityTokenInfo :: V0 (< crate :: fermented :: types :: dpp :: tokens :: info :: v0 :: dpp_tokens_info_v0_IdentityTokenInfoV0 as ferment :: FFIConversionTo < dpp :: tokens :: info :: v0 :: IdentityTokenInfoV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_tokens_info_IdentityTokenInfo { fn drop (& mut self) { unsafe { match self { dpp_tokens_info_IdentityTokenInfo :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod status { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`TokenStatusV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_tokens_status_v0_TokenStatusV0 { pub paused : bool } impl ferment :: FFIConversionFrom < dpp :: tokens :: status :: v0 :: TokenStatusV0 > for dpp_tokens_status_v0_TokenStatusV0 { unsafe fn ffi_from_const (ffi : * const dpp_tokens_status_v0_TokenStatusV0) -> dpp :: tokens :: status :: v0 :: TokenStatusV0 { let ffi_ref = & * ffi ; dpp :: tokens :: status :: v0 :: TokenStatusV0 { paused : ffi_ref . paused } } } impl ferment :: FFIConversionTo < dpp :: tokens :: status :: v0 :: TokenStatusV0 > for dpp_tokens_status_v0_TokenStatusV0 { unsafe fn ffi_to_const (obj : dpp :: tokens :: status :: v0 :: TokenStatusV0) -> * const dpp_tokens_status_v0_TokenStatusV0 { ferment :: boxed (dpp_tokens_status_v0_TokenStatusV0 { paused : obj . paused }) } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenStatus`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_tokens_status_TokenStatus { V0 (* mut crate :: fermented :: types :: dpp :: tokens :: status :: v0 :: dpp_tokens_status_v0_TokenStatusV0) } impl ferment :: FFIConversionFrom < dpp :: tokens :: status :: TokenStatus > for dpp_tokens_status_TokenStatus { unsafe fn ffi_from_const (ffi : * const dpp_tokens_status_TokenStatus) -> dpp :: tokens :: status :: TokenStatus { let ffi_ref = & * ffi ; match ffi_ref { dpp_tokens_status_TokenStatus :: V0 (o_0) => dpp :: tokens :: status :: TokenStatus :: V0 (< crate :: fermented :: types :: dpp :: tokens :: status :: v0 :: dpp_tokens_status_v0_TokenStatusV0 as ferment :: FFIConversionFrom < dpp :: tokens :: status :: v0 :: TokenStatusV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: tokens :: status :: TokenStatus > for dpp_tokens_status_TokenStatus { unsafe fn ffi_to_const (obj : dpp :: tokens :: status :: TokenStatus) -> * const dpp_tokens_status_TokenStatus { ferment :: boxed (match obj { dpp :: tokens :: status :: TokenStatus :: V0 (o_0) => dpp_tokens_status_TokenStatus :: V0 (< crate :: fermented :: types :: dpp :: tokens :: status :: v0 :: dpp_tokens_status_v0_TokenStatusV0 as ferment :: FFIConversionTo < dpp :: tokens :: status :: v0 :: TokenStatusV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_tokens_status_TokenStatus { fn drop (& mut self) { unsafe { match self { dpp_tokens_status_TokenStatus :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod token_amount_on_contract_token { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentActionTokenEffect`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect { TransferTokenToContractOwner , BurnToken } impl ferment :: FFIConversionFrom < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenEffect > for dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect { unsafe fn ffi_from_const (ffi : * const dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect) -> dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenEffect { let ffi_ref = & * ffi ; match ffi_ref { dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect :: TransferTokenToContractOwner => dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenEffect :: TransferTokenToContractOwner , dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect :: BurnToken => dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenEffect :: BurnToken } } } impl ferment :: FFIConversionTo < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenEffect > for dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect { unsafe fn ffi_to_const (obj : dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenEffect) -> * const dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect { ferment :: boxed (match obj { dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenEffect :: TransferTokenToContractOwner => dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect :: TransferTokenToContractOwner , dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenEffect :: BurnToken => dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect :: BurnToken , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect { fn drop (& mut self) { unsafe { match self { dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect :: TransferTokenToContractOwner => { } , dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect :: BurnToken => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [doc = "FFI-representation of the [`DocumentActionTokenCost`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost { pub contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub token_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , pub token_amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , pub effect : * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect , pub gas_fees_paid_by : * mut crate :: fermented :: types :: dpp :: tokens :: gas_fees_paid_by :: dpp_tokens_gas_fees_paid_by_GasFeesPaidBy } impl ferment :: FFIConversionFrom < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost > for dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost { unsafe fn ffi_from_const (ffi : * const dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost) -> dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost { let ffi_ref = & * ffi ; dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost { contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from_opt (ffi_ref . contract_id) , token_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from (ffi_ref . token_contract_position) , token_amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (ffi_ref . token_amount) , effect : < crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect as ferment :: FFIConversionFrom < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenEffect >> :: ffi_from (ffi_ref . effect) , gas_fees_paid_by : < crate :: fermented :: types :: dpp :: tokens :: gas_fees_paid_by :: dpp_tokens_gas_fees_paid_by_GasFeesPaidBy as ferment :: FFIConversionFrom < dpp :: tokens :: gas_fees_paid_by :: GasFeesPaidBy >> :: ffi_from (ffi_ref . gas_fees_paid_by) } } } impl ferment :: FFIConversionTo < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost > for dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost { unsafe fn ffi_to_const (obj : dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost) -> * const dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost { ferment :: boxed (dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost { contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to_opt (obj . contract_id) , token_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition >> :: ffi_to (obj . token_contract_position) , token_amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (obj . token_amount) , effect : < crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect as ferment :: FFIConversionTo < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenEffect >> :: ffi_to (obj . effect) , gas_fees_paid_by : < crate :: fermented :: types :: dpp :: tokens :: gas_fees_paid_by :: dpp_tokens_gas_fees_paid_by_GasFeesPaidBy as ferment :: FFIConversionTo < dpp :: tokens :: gas_fees_paid_by :: GasFeesPaidBy >> :: ffi_to (obj . gas_fees_paid_by) }) } } impl Drop for dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any_opt (ffi_ref . contract_id) ; ferment :: unbox_any (ffi_ref . token_contract_position) ; ferment :: unbox_any (ffi_ref . token_amount) ; ferment :: unbox_any (ffi_ref . effect) ; ferment :: unbox_any (ffi_ref . gas_fees_paid_by) ; } } } } pub mod token_payment_info { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`TokenPaymentInfoV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0 { pub payment_token_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub token_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , pub minimum_token_cost : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , pub maximum_token_cost : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , pub gas_fees_paid_by : * mut crate :: fermented :: types :: dpp :: tokens :: gas_fees_paid_by :: dpp_tokens_gas_fees_paid_by_GasFeesPaidBy } impl ferment :: FFIConversionFrom < dpp :: tokens :: token_payment_info :: v0 :: TokenPaymentInfoV0 > for dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0 { unsafe fn ffi_from_const (ffi : * const dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0) -> dpp :: tokens :: token_payment_info :: v0 :: TokenPaymentInfoV0 { let ffi_ref = & * ffi ; dpp :: tokens :: token_payment_info :: v0 :: TokenPaymentInfoV0 { payment_token_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from_opt (ffi_ref . payment_token_contract_id) , token_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from (ffi_ref . token_contract_position) , minimum_token_cost : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from_opt (ffi_ref . minimum_token_cost) , maximum_token_cost : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from_opt (ffi_ref . maximum_token_cost) , gas_fees_paid_by : < crate :: fermented :: types :: dpp :: tokens :: gas_fees_paid_by :: dpp_tokens_gas_fees_paid_by_GasFeesPaidBy as ferment :: FFIConversionFrom < dpp :: tokens :: gas_fees_paid_by :: GasFeesPaidBy >> :: ffi_from (ffi_ref . gas_fees_paid_by) } } } impl ferment :: FFIConversionTo < dpp :: tokens :: token_payment_info :: v0 :: TokenPaymentInfoV0 > for dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0 { unsafe fn ffi_to_const (obj : dpp :: tokens :: token_payment_info :: v0 :: TokenPaymentInfoV0) -> * const dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0 { ferment :: boxed (dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0 { payment_token_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to_opt (obj . payment_token_contract_id) , token_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition >> :: ffi_to (obj . token_contract_position) , minimum_token_cost : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to_opt (obj . minimum_token_cost) , maximum_token_cost : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to_opt (obj . maximum_token_cost) , gas_fees_paid_by : < crate :: fermented :: types :: dpp :: tokens :: gas_fees_paid_by :: dpp_tokens_gas_fees_paid_by_GasFeesPaidBy as ferment :: FFIConversionTo < dpp :: tokens :: gas_fees_paid_by :: GasFeesPaidBy >> :: ffi_to (obj . gas_fees_paid_by) }) } } impl Drop for dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any_opt (ffi_ref . payment_token_contract_id) ; ferment :: unbox_any (ffi_ref . token_contract_position) ; ferment :: unbox_any_opt (ffi_ref . minimum_token_cost) ; ferment :: unbox_any_opt (ffi_ref . maximum_token_cost) ; ferment :: unbox_any (ffi_ref . gas_fees_paid_by) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenPaymentInfo`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_tokens_token_payment_info_TokenPaymentInfo { V0 (* mut crate :: fermented :: types :: dpp :: tokens :: token_payment_info :: v0 :: dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0) } impl ferment :: FFIConversionFrom < dpp :: tokens :: token_payment_info :: TokenPaymentInfo > for dpp_tokens_token_payment_info_TokenPaymentInfo { unsafe fn ffi_from_const (ffi : * const dpp_tokens_token_payment_info_TokenPaymentInfo) -> dpp :: tokens :: token_payment_info :: TokenPaymentInfo { let ffi_ref = & * ffi ; match ffi_ref { dpp_tokens_token_payment_info_TokenPaymentInfo :: V0 (o_0) => dpp :: tokens :: token_payment_info :: TokenPaymentInfo :: V0 (< crate :: fermented :: types :: dpp :: tokens :: token_payment_info :: v0 :: dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0 as ferment :: FFIConversionFrom < dpp :: tokens :: token_payment_info :: v0 :: TokenPaymentInfoV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: tokens :: token_payment_info :: TokenPaymentInfo > for dpp_tokens_token_payment_info_TokenPaymentInfo { unsafe fn ffi_to_const (obj : dpp :: tokens :: token_payment_info :: TokenPaymentInfo) -> * const dpp_tokens_token_payment_info_TokenPaymentInfo { ferment :: boxed (match obj { dpp :: tokens :: token_payment_info :: TokenPaymentInfo :: V0 (o_0) => dpp_tokens_token_payment_info_TokenPaymentInfo :: V0 (< crate :: fermented :: types :: dpp :: tokens :: token_payment_info :: v0 :: dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0 as ferment :: FFIConversionTo < dpp :: tokens :: token_payment_info :: v0 :: TokenPaymentInfoV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_tokens_token_payment_info_TokenPaymentInfo { fn drop (& mut self) { unsafe { match self { dpp_tokens_token_payment_info_TokenPaymentInfo :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod token_pricing_schedule { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenPricingSchedule`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_tokens_token_pricing_schedule_TokenPricingSchedule { SinglePrice (* mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) , SetPrices (* mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_balances_credits_TokenAmount_values_dpp_balances_credits_Credits) } impl ferment :: FFIConversionFrom < dpp :: tokens :: token_pricing_schedule :: TokenPricingSchedule > for dpp_tokens_token_pricing_schedule_TokenPricingSchedule { unsafe fn ffi_from_const (ffi : * const dpp_tokens_token_pricing_schedule_TokenPricingSchedule) -> dpp :: tokens :: token_pricing_schedule :: TokenPricingSchedule { let ffi_ref = & * ffi ; match ffi_ref { dpp_tokens_token_pricing_schedule_TokenPricingSchedule :: SinglePrice (o_0) => dpp :: tokens :: token_pricing_schedule :: TokenPricingSchedule :: SinglePrice (< crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (* o_0)) , dpp_tokens_token_pricing_schedule_TokenPricingSchedule :: SetPrices (o_0) => dpp :: tokens :: token_pricing_schedule :: TokenPricingSchedule :: SetPrices (< crate :: fermented :: generics :: std_collections_Map_keys_dpp_balances_credits_TokenAmount_values_dpp_balances_credits_Credits as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: balances :: credits :: TokenAmount , dpp :: balances :: credits :: Credits > >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: tokens :: token_pricing_schedule :: TokenPricingSchedule > for dpp_tokens_token_pricing_schedule_TokenPricingSchedule { unsafe fn ffi_to_const (obj : dpp :: tokens :: token_pricing_schedule :: TokenPricingSchedule) -> * const dpp_tokens_token_pricing_schedule_TokenPricingSchedule { ferment :: boxed (match obj { dpp :: tokens :: token_pricing_schedule :: TokenPricingSchedule :: SinglePrice (o_0) => dpp_tokens_token_pricing_schedule_TokenPricingSchedule :: SinglePrice (< crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (o_0)) , dpp :: tokens :: token_pricing_schedule :: TokenPricingSchedule :: SetPrices (o_0) => dpp_tokens_token_pricing_schedule_TokenPricingSchedule :: SetPrices (< crate :: fermented :: generics :: std_collections_Map_keys_dpp_balances_credits_TokenAmount_values_dpp_balances_credits_Credits as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: balances :: credits :: TokenAmount , dpp :: balances :: credits :: Credits > >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_tokens_token_pricing_schedule_TokenPricingSchedule { fn drop (& mut self) { unsafe { match self { dpp_tokens_token_pricing_schedule_TokenPricingSchedule :: SinglePrice (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_tokens_token_pricing_schedule_TokenPricingSchedule :: SetPrices (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } # [doc = "FFI-representation of the [`SharedEncryptedNote`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_tokens_SharedEncryptedNote (* mut crate :: fermented :: generics :: Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8) ; impl ferment :: FFIConversionFrom < dpp :: tokens :: SharedEncryptedNote > for dpp_tokens_SharedEncryptedNote { unsafe fn ffi_from_const (ffi : * const dpp_tokens_SharedEncryptedNote) -> dpp :: tokens :: SharedEncryptedNote { let ffi_ref = & * ffi ; < crate :: fermented :: generics :: Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8 as ferment :: FFIConversionFrom < (dpp :: prelude :: SenderKeyIndex , dpp :: prelude :: RecipientKeyIndex , Vec < u8 >) >> :: ffi_from (ffi_ref . 0) } } impl ferment :: FFIConversionTo < dpp :: tokens :: SharedEncryptedNote > for dpp_tokens_SharedEncryptedNote { unsafe fn ffi_to_const (obj : dpp :: tokens :: SharedEncryptedNote) -> * const dpp_tokens_SharedEncryptedNote { ferment :: boxed (dpp_tokens_SharedEncryptedNote (< crate :: fermented :: generics :: Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8 as ferment :: FFIConversionTo < (dpp :: prelude :: SenderKeyIndex , dpp :: prelude :: RecipientKeyIndex , Vec < u8 >) >> :: ffi_to (obj))) } } impl Drop for dpp_tokens_SharedEncryptedNote { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [doc = "FFI-representation of the [`PrivateEncryptedNote`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_tokens_PrivateEncryptedNote (* mut crate :: fermented :: generics :: Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8) ; impl ferment :: FFIConversionFrom < dpp :: tokens :: PrivateEncryptedNote > for dpp_tokens_PrivateEncryptedNote { unsafe fn ffi_from_const (ffi : * const dpp_tokens_PrivateEncryptedNote) -> dpp :: tokens :: PrivateEncryptedNote { let ffi_ref = & * ffi ; < crate :: fermented :: generics :: Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8 as ferment :: FFIConversionFrom < (dpp :: prelude :: RootEncryptionKeyIndex , dpp :: prelude :: DerivationEncryptionKeyIndex , Vec < u8 > ,) >> :: ffi_from (ffi_ref . 0) } } impl ferment :: FFIConversionTo < dpp :: tokens :: PrivateEncryptedNote > for dpp_tokens_PrivateEncryptedNote { unsafe fn ffi_to_const (obj : dpp :: tokens :: PrivateEncryptedNote) -> * const dpp_tokens_PrivateEncryptedNote { ferment :: boxed (dpp_tokens_PrivateEncryptedNote (< crate :: fermented :: generics :: Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8 as ferment :: FFIConversionTo < (dpp :: prelude :: RootEncryptionKeyIndex , dpp :: prelude :: DerivationEncryptionKeyIndex , Vec < u8 > ,) >> :: ffi_to (obj))) } } impl Drop for dpp_tokens_PrivateEncryptedNote { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } } pub mod voting { pub mod contender_structs { use crate as example_platform ; # [doc = "FFI-representation of the [`FinalizedResourceVoteChoicesWithVoterInfo`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { pub resource_vote_choice : * mut crate :: fermented :: types :: dpp :: voting :: vote_choices :: resource_vote_choice :: dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice , pub voters : * mut crate :: fermented :: generics :: Vec_Tuple_platform_value_types_identifier_Identifier_u8 } impl ferment :: FFIConversionFrom < dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo > for dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { unsafe fn ffi_from_const (ffi : * const dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo) -> dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo { let ffi_ref = & * ffi ; dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo { resource_vote_choice : < crate :: fermented :: types :: dpp :: voting :: vote_choices :: resource_vote_choice :: dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice as ferment :: FFIConversionFrom < dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice >> :: ffi_from (ffi_ref . resource_vote_choice) , voters : < crate :: fermented :: generics :: Vec_Tuple_platform_value_types_identifier_Identifier_u8 as ferment :: FFIConversionFrom < Vec < (platform_value :: types :: identifier :: Identifier , u8) > >> :: ffi_from (ffi_ref . voters) } } } impl ferment :: FFIConversionTo < dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo > for dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { unsafe fn ffi_to_const (obj : dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo) -> * const dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { ferment :: boxed (dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { resource_vote_choice : < crate :: fermented :: types :: dpp :: voting :: vote_choices :: resource_vote_choice :: dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice as ferment :: FFIConversionTo < dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice >> :: ffi_to (obj . resource_vote_choice) , voters : < crate :: fermented :: generics :: Vec_Tuple_platform_value_types_identifier_Identifier_u8 as ferment :: FFIConversionTo < Vec < (platform_value :: types :: identifier :: Identifier , u8) > >> :: ffi_to (obj . voters) }) } } impl Drop for dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . resource_vote_choice) ; ferment :: unbox_any (ffi_ref . voters) ; } } } } pub mod vote_choices { pub mod resource_vote_choice { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ResourceVoteChoice`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice { TowardsIdentity (* mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) , Abstain , Lock } impl ferment :: FFIConversionFrom < dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice > for dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice { unsafe fn ffi_from_const (ffi : * const dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice) -> dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice { let ffi_ref = & * ffi ; match ffi_ref { dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: TowardsIdentity (o_0) => dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice :: TowardsIdentity (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (* o_0)) , dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: Abstain => dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice :: Abstain , dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: Lock => dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice :: Lock } } } impl ferment :: FFIConversionTo < dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice > for dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice { unsafe fn ffi_to_const (obj : dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice) -> * const dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice { ferment :: boxed (match obj { dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice :: TowardsIdentity (o_0) => dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: TowardsIdentity (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (o_0)) , dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice :: Abstain => dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: Abstain , dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice :: Lock => dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: Lock , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice { fn drop (& mut self) { unsafe { match self { dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: TowardsIdentity (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: Abstain => { } , dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: Lock => { } , _ => unreachable ! ("This is unreachable") } ; } } } } } pub mod vote_info_storage { pub mod contested_document_vote_poll_stored_info { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`ContestedDocumentVotePollStoredInfoVoteEventV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { pub resource_vote_choices : * mut crate :: fermented :: generics :: Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo , pub start_block : * mut crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo , pub finalization_block : * mut crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo , pub winner : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo } impl ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 > for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { unsafe fn ffi_from_const (ffi : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0) -> dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 { let ffi_ref = & * ffi ; dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 { resource_vote_choices : < crate :: fermented :: generics :: Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo as ferment :: FFIConversionFrom < Vec < dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo > >> :: ffi_from (ffi_ref . resource_vote_choices) , start_block : < crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo as ferment :: FFIConversionFrom < dpp :: block :: block_info :: BlockInfo >> :: ffi_from (ffi_ref . start_block) , finalization_block : < crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo as ferment :: FFIConversionFrom < dpp :: block :: block_info :: BlockInfo >> :: ffi_from (ffi_ref . finalization_block) , winner : < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo as ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo >> :: ffi_from (ffi_ref . winner) } } } impl ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 > for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { unsafe fn ffi_to_const (obj : dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0) -> * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { ferment :: boxed (dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { resource_vote_choices : < crate :: fermented :: generics :: Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo as ferment :: FFIConversionTo < Vec < dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo > >> :: ffi_to (obj . resource_vote_choices) , start_block : < crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo as ferment :: FFIConversionTo < dpp :: block :: block_info :: BlockInfo >> :: ffi_to (obj . start_block) , finalization_block : < crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo as ferment :: FFIConversionTo < dpp :: block :: block_info :: BlockInfo >> :: ffi_to (obj . finalization_block) , winner : < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo as ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo >> :: ffi_to (obj . winner) }) } } impl Drop for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . resource_vote_choices) ; ferment :: unbox_any (ffi_ref . start_block) ; ferment :: unbox_any (ffi_ref . finalization_block) ; ferment :: unbox_any (ffi_ref . winner) ; } } } # [doc = "FFI-representation of the [`ContestedDocumentVotePollStoredInfoV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0 { pub finalized_events : * mut crate :: fermented :: generics :: Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 , pub vote_poll_status : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus , pub locked_count : u16 } impl ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoV0 > for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0 { unsafe fn ffi_from_const (ffi : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0) -> dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoV0 { let ffi_ref = & * ffi ; dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoV0 { finalized_events : < crate :: fermented :: generics :: Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 as ferment :: FFIConversionFrom < Vec < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 > >> :: ffi_from (ffi_ref . finalized_events) , vote_poll_status : < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus as ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus >> :: ffi_from (ffi_ref . vote_poll_status) , locked_count : ffi_ref . locked_count } } } impl ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoV0 > for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0 { unsafe fn ffi_to_const (obj : dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoV0) -> * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0 { ferment :: boxed (dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0 { finalized_events : < crate :: fermented :: generics :: Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 as ferment :: FFIConversionTo < Vec < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 > >> :: ffi_to (obj . finalized_events) , vote_poll_status : < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus as ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus >> :: ffi_to (obj . vote_poll_status) , locked_count : obj . locked_count }) } } impl Drop for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . finalized_events) ; ferment :: unbox_any (ffi_ref . vote_poll_status) ; ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ContestedDocumentVotePollStatus`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus { NotStarted , Awarded (* mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) , Locked , Started (* mut crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo) } impl ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus > for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus { unsafe fn ffi_from_const (ffi : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus) -> dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus { let ffi_ref = & * ffi ; match ffi_ref { dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: NotStarted => dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus :: NotStarted , dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Awarded (o_0) => dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus :: Awarded (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (* o_0)) , dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Locked => dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus :: Locked , dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Started (o_0) => dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus :: Started (< crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo as ferment :: FFIConversionFrom < dpp :: block :: block_info :: BlockInfo >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus > for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus { unsafe fn ffi_to_const (obj : dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus) -> * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus { ferment :: boxed (match obj { dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus :: NotStarted => dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: NotStarted , dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus :: Awarded (o_0) => dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Awarded (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (o_0)) , dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus :: Locked => dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Locked , dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus :: Started (o_0) => dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Started (< crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo as ferment :: FFIConversionTo < dpp :: block :: block_info :: BlockInfo >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus { fn drop (& mut self) { unsafe { match self { dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: NotStarted => { } , dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Awarded (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Locked => { } , dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Started (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ContestedDocumentVotePollStoredInfo`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo { V0 (* mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0) } impl ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStoredInfo > for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo { unsafe fn ffi_from_const (ffi : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo) -> dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStoredInfo { let ffi_ref = & * ffi ; match ffi_ref { dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo :: V0 (o_0) => dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStoredInfo :: V0 (< crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0 as ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStoredInfo > for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo { unsafe fn ffi_to_const (obj : dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStoredInfo) -> * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo { ferment :: boxed (match obj { dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStoredInfo :: V0 (o_0) => dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo :: V0 (< crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0 as ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo { fn drop (& mut self) { unsafe { match self { dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod contested_document_vote_poll_winner_info { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ContestedDocumentVotePollWinnerInfo`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo { NoWinner , WonByIdentity (* mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) , Locked } impl ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo > for dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo { unsafe fn ffi_from_const (ffi : * const dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo) -> dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo { let ffi_ref = & * ffi ; match ffi_ref { dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: NoWinner => dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo :: NoWinner , dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: WonByIdentity (o_0) => dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo :: WonByIdentity (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (* o_0)) , dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: Locked => dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo :: Locked } } } impl ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo > for dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo { unsafe fn ffi_to_const (obj : dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo) -> * const dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo { ferment :: boxed (match obj { dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo :: NoWinner => dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: NoWinner , dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo :: WonByIdentity (o_0) => dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: WonByIdentity (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (o_0)) , dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo :: Locked => dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: Locked , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo { fn drop (& mut self) { unsafe { match self { dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: NoWinner => { } , dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: WonByIdentity (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: Locked => { } , _ => unreachable ! ("This is unreachable") } ; } } } } } pub mod vote_polls { use crate as example_platform ; pub mod contested_document_resource_vote_poll { use crate as example_platform ; # [doc = "FFI-representation of the [`ContestedDocumentResourceVotePoll`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll { pub contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub document_type_name : * mut std :: os :: raw :: c_char , pub index_name : * mut std :: os :: raw :: c_char , pub index_values : * mut crate :: fermented :: generics :: Vec_platform_value_Value } impl ferment :: FFIConversionFrom < dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll > for dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll { unsafe fn ffi_from_const (ffi : * const dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll) -> dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll { let ffi_ref = & * ffi ; dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll { contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . contract_id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type_name) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . index_name) , index_values : < crate :: fermented :: generics :: Vec_platform_value_Value as ferment :: FFIConversionFrom < Vec < platform_value :: Value > >> :: ffi_from (ffi_ref . index_values) } } } impl ferment :: FFIConversionTo < dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll > for dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll { unsafe fn ffi_to_const (obj : dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll) -> * const dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll { ferment :: boxed (dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll { contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . contract_id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type_name) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . index_name) , index_values : < crate :: fermented :: generics :: Vec_platform_value_Value as ferment :: FFIConversionTo < Vec < platform_value :: Value > >> :: ffi_to (obj . index_values) }) } } impl Drop for dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . contract_id) ; ferment :: unbox_string (ffi_ref . document_type_name) ; ferment :: unbox_string (ffi_ref . index_name) ; ferment :: unbox_any (ffi_ref . index_values) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`VotePoll`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_voting_vote_polls_VotePoll { ContestedDocumentResourceVotePoll (* mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll) } impl ferment :: FFIConversionFrom < dpp :: voting :: vote_polls :: VotePoll > for dpp_voting_vote_polls_VotePoll { unsafe fn ffi_from_const (ffi : * const dpp_voting_vote_polls_VotePoll) -> dpp :: voting :: vote_polls :: VotePoll { let ffi_ref = & * ffi ; match ffi_ref { dpp_voting_vote_polls_VotePoll :: ContestedDocumentResourceVotePoll (o_0) => dpp :: voting :: vote_polls :: VotePoll :: ContestedDocumentResourceVotePoll (< crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll as ferment :: FFIConversionFrom < dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: voting :: vote_polls :: VotePoll > for dpp_voting_vote_polls_VotePoll { unsafe fn ffi_to_const (obj : dpp :: voting :: vote_polls :: VotePoll) -> * const dpp_voting_vote_polls_VotePoll { ferment :: boxed (match obj { dpp :: voting :: vote_polls :: VotePoll :: ContestedDocumentResourceVotePoll (o_0) => dpp_voting_vote_polls_VotePoll :: ContestedDocumentResourceVotePoll (< crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll as ferment :: FFIConversionTo < dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_voting_vote_polls_VotePoll { fn drop (& mut self) { unsafe { match self { dpp_voting_vote_polls_VotePoll :: ContestedDocumentResourceVotePoll (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod votes { use crate as example_platform ; pub mod resource_vote { use crate as example_platform ; pub mod v0 { use crate as example_platform ; # [doc = "FFI-representation of the [`ResourceVoteV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_voting_votes_resource_vote_v0_ResourceVoteV0 { pub vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll , pub resource_vote_choice : * mut crate :: fermented :: types :: dpp :: voting :: vote_choices :: resource_vote_choice :: dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice } impl ferment :: FFIConversionFrom < dpp :: voting :: votes :: resource_vote :: v0 :: ResourceVoteV0 > for dpp_voting_votes_resource_vote_v0_ResourceVoteV0 { unsafe fn ffi_from_const (ffi : * const dpp_voting_votes_resource_vote_v0_ResourceVoteV0) -> dpp :: voting :: votes :: resource_vote :: v0 :: ResourceVoteV0 { let ffi_ref = & * ffi ; dpp :: voting :: votes :: resource_vote :: v0 :: ResourceVoteV0 { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll as ferment :: FFIConversionFrom < dpp :: voting :: vote_polls :: VotePoll >> :: ffi_from (ffi_ref . vote_poll) , resource_vote_choice : < crate :: fermented :: types :: dpp :: voting :: vote_choices :: resource_vote_choice :: dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice as ferment :: FFIConversionFrom < dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice >> :: ffi_from (ffi_ref . resource_vote_choice) } } } impl ferment :: FFIConversionTo < dpp :: voting :: votes :: resource_vote :: v0 :: ResourceVoteV0 > for dpp_voting_votes_resource_vote_v0_ResourceVoteV0 { unsafe fn ffi_to_const (obj : dpp :: voting :: votes :: resource_vote :: v0 :: ResourceVoteV0) -> * const dpp_voting_votes_resource_vote_v0_ResourceVoteV0 { ferment :: boxed (dpp_voting_votes_resource_vote_v0_ResourceVoteV0 { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll as ferment :: FFIConversionTo < dpp :: voting :: vote_polls :: VotePoll >> :: ffi_to (obj . vote_poll) , resource_vote_choice : < crate :: fermented :: types :: dpp :: voting :: vote_choices :: resource_vote_choice :: dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice as ferment :: FFIConversionTo < dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice >> :: ffi_to (obj . resource_vote_choice) }) } } impl Drop for dpp_voting_votes_resource_vote_v0_ResourceVoteV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . vote_poll) ; ferment :: unbox_any (ffi_ref . resource_vote_choice) ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ResourceVote`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_voting_votes_resource_vote_ResourceVote { V0 (* mut crate :: fermented :: types :: dpp :: voting :: votes :: resource_vote :: v0 :: dpp_voting_votes_resource_vote_v0_ResourceVoteV0) } impl ferment :: FFIConversionFrom < dpp :: voting :: votes :: resource_vote :: ResourceVote > for dpp_voting_votes_resource_vote_ResourceVote { unsafe fn ffi_from_const (ffi : * const dpp_voting_votes_resource_vote_ResourceVote) -> dpp :: voting :: votes :: resource_vote :: ResourceVote { let ffi_ref = & * ffi ; match ffi_ref { dpp_voting_votes_resource_vote_ResourceVote :: V0 (o_0) => dpp :: voting :: votes :: resource_vote :: ResourceVote :: V0 (< crate :: fermented :: types :: dpp :: voting :: votes :: resource_vote :: v0 :: dpp_voting_votes_resource_vote_v0_ResourceVoteV0 as ferment :: FFIConversionFrom < dpp :: voting :: votes :: resource_vote :: v0 :: ResourceVoteV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: voting :: votes :: resource_vote :: ResourceVote > for dpp_voting_votes_resource_vote_ResourceVote { unsafe fn ffi_to_const (obj : dpp :: voting :: votes :: resource_vote :: ResourceVote) -> * const dpp_voting_votes_resource_vote_ResourceVote { ferment :: boxed (match obj { dpp :: voting :: votes :: resource_vote :: ResourceVote :: V0 (o_0) => dpp_voting_votes_resource_vote_ResourceVote :: V0 (< crate :: fermented :: types :: dpp :: voting :: votes :: resource_vote :: v0 :: dpp_voting_votes_resource_vote_v0_ResourceVoteV0 as ferment :: FFIConversionTo < dpp :: voting :: votes :: resource_vote :: v0 :: ResourceVoteV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_voting_votes_resource_vote_ResourceVote { fn drop (& mut self) { unsafe { match self { dpp_voting_votes_resource_vote_ResourceVote :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`Vote`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_voting_votes_Vote { ResourceVote (* mut crate :: fermented :: types :: dpp :: voting :: votes :: resource_vote :: dpp_voting_votes_resource_vote_ResourceVote) } impl ferment :: FFIConversionFrom < dpp :: voting :: votes :: Vote > for dpp_voting_votes_Vote { unsafe fn ffi_from_const (ffi : * const dpp_voting_votes_Vote) -> dpp :: voting :: votes :: Vote { let ffi_ref = & * ffi ; match ffi_ref { dpp_voting_votes_Vote :: ResourceVote (o_0) => dpp :: voting :: votes :: Vote :: ResourceVote (< crate :: fermented :: types :: dpp :: voting :: votes :: resource_vote :: dpp_voting_votes_resource_vote_ResourceVote as ferment :: FFIConversionFrom < dpp :: voting :: votes :: resource_vote :: ResourceVote >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: voting :: votes :: Vote > for dpp_voting_votes_Vote { unsafe fn ffi_to_const (obj : dpp :: voting :: votes :: Vote) -> * const dpp_voting_votes_Vote { ferment :: boxed (match obj { dpp :: voting :: votes :: Vote :: ResourceVote (o_0) => dpp_voting_votes_Vote :: ResourceVote (< crate :: fermented :: types :: dpp :: voting :: votes :: resource_vote :: dpp_voting_votes_resource_vote_ResourceVote as ferment :: FFIConversionTo < dpp :: voting :: votes :: resource_vote :: ResourceVote >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_voting_votes_Vote { fn drop (& mut self) { unsafe { match self { dpp_voting_votes_Vote :: ResourceVote (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } } } pub mod group { use crate as example_platform ; pub mod group_action_status { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`GroupActionStatus`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_group_group_action_status_GroupActionStatus { ActionActive , ActionClosed } impl ferment :: FFIConversionFrom < dpp :: group :: group_action_status :: GroupActionStatus > for dpp_group_group_action_status_GroupActionStatus { unsafe fn ffi_from_const (ffi : * const dpp_group_group_action_status_GroupActionStatus) -> dpp :: group :: group_action_status :: GroupActionStatus { let ffi_ref = & * ffi ; match ffi_ref { dpp_group_group_action_status_GroupActionStatus :: ActionActive => dpp :: group :: group_action_status :: GroupActionStatus :: ActionActive , dpp_group_group_action_status_GroupActionStatus :: ActionClosed => dpp :: group :: group_action_status :: GroupActionStatus :: ActionClosed } } } impl ferment :: FFIConversionTo < dpp :: group :: group_action_status :: GroupActionStatus > for dpp_group_group_action_status_GroupActionStatus { unsafe fn ffi_to_const (obj : dpp :: group :: group_action_status :: GroupActionStatus) -> * const dpp_group_group_action_status_GroupActionStatus { ferment :: boxed (match obj { dpp :: group :: group_action_status :: GroupActionStatus :: ActionActive => dpp_group_group_action_status_GroupActionStatus :: ActionActive , dpp :: group :: group_action_status :: GroupActionStatus :: ActionClosed => dpp_group_group_action_status_GroupActionStatus :: ActionClosed , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_group_group_action_status_GroupActionStatus { fn drop (& mut self) { unsafe { match self { dpp_group_group_action_status_GroupActionStatus :: ActionActive => { } , dpp_group_group_action_status_GroupActionStatus :: ActionClosed => { } , _ => unreachable ! ("This is unreachable") } ; } } } } # [doc = "FFI-representation of the [`GroupStateTransitionInfo`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_group_GroupStateTransitionInfo { pub group_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , pub action_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub action_is_proposer : bool } impl ferment :: FFIConversionFrom < dpp :: group :: GroupStateTransitionInfo > for dpp_group_GroupStateTransitionInfo { unsafe fn ffi_from_const (ffi : * const dpp_group_GroupStateTransitionInfo) -> dpp :: group :: GroupStateTransitionInfo { let ffi_ref = & * ffi ; dpp :: group :: GroupStateTransitionInfo { group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (ffi_ref . group_contract_position) , action_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . action_id) , action_is_proposer : ffi_ref . action_is_proposer } } } impl ferment :: FFIConversionTo < dpp :: group :: GroupStateTransitionInfo > for dpp_group_GroupStateTransitionInfo { unsafe fn ffi_to_const (obj : dpp :: group :: GroupStateTransitionInfo) -> * const dpp_group_GroupStateTransitionInfo { ferment :: boxed (dpp_group_GroupStateTransitionInfo { group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (obj . group_contract_position) , action_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . action_id) , action_is_proposer : obj . action_is_proposer }) } } impl Drop for dpp_group_GroupStateTransitionInfo { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . group_contract_position) ; ferment :: unbox_any (ffi_ref . action_id) ; ; } } } } pub mod withdrawal { use crate as example_platform ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`Pooling`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_withdrawal_Pooling { Never = 0 , IfAvailable = 1 , Standard = 2 } impl ferment :: FFIConversionFrom < dpp :: withdrawal :: Pooling > for dpp_withdrawal_Pooling { unsafe fn ffi_from_const (ffi : * const dpp_withdrawal_Pooling) -> dpp :: withdrawal :: Pooling { let ffi_ref = & * ffi ; match ffi_ref { dpp_withdrawal_Pooling :: Never => dpp :: withdrawal :: Pooling :: Never , dpp_withdrawal_Pooling :: IfAvailable => dpp :: withdrawal :: Pooling :: IfAvailable , dpp_withdrawal_Pooling :: Standard => dpp :: withdrawal :: Pooling :: Standard } } } impl ferment :: FFIConversionTo < dpp :: withdrawal :: Pooling > for dpp_withdrawal_Pooling { unsafe fn ffi_to_const (obj : dpp :: withdrawal :: Pooling) -> * const dpp_withdrawal_Pooling { ferment :: boxed (match obj { dpp :: withdrawal :: Pooling :: Never => dpp_withdrawal_Pooling :: Never , dpp :: withdrawal :: Pooling :: IfAvailable => dpp_withdrawal_Pooling :: IfAvailable , dpp :: withdrawal :: Pooling :: Standard => dpp_withdrawal_Pooling :: Standard , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_withdrawal_Pooling { fn drop (& mut self) { unsafe { match self { dpp_withdrawal_Pooling :: Never => { } , dpp_withdrawal_Pooling :: IfAvailable => { } , dpp_withdrawal_Pooling :: Standard => { } , _ => unreachable ! ("This is unreachable") } ; } } } } pub mod prelude { use crate as example_platform ; # [doc = "FFI-representation of the [`EpochInterval`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_EpochInterval (u16) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: EpochInterval > for dpp_prelude_EpochInterval { unsafe fn ffi_from_const (ffi : * const dpp_prelude_EpochInterval) -> dpp :: prelude :: EpochInterval { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: EpochInterval > for dpp_prelude_EpochInterval { unsafe fn ffi_to_const (obj : dpp :: prelude :: EpochInterval) -> * const dpp_prelude_EpochInterval { ferment :: boxed (dpp_prelude_EpochInterval (obj)) } } # [doc = "FFI-representation of the [`BlockHeight`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_BlockHeight (u64) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: BlockHeight > for dpp_prelude_BlockHeight { unsafe fn ffi_from_const (ffi : * const dpp_prelude_BlockHeight) -> dpp :: prelude :: BlockHeight { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: BlockHeight > for dpp_prelude_BlockHeight { unsafe fn ffi_to_const (obj : dpp :: prelude :: BlockHeight) -> * const dpp_prelude_BlockHeight { ferment :: boxed (dpp_prelude_BlockHeight (obj)) } } # [doc = "FFI-representation of the [`FeeMultiplier`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_FeeMultiplier (u64) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: FeeMultiplier > for dpp_prelude_FeeMultiplier { unsafe fn ffi_from_const (ffi : * const dpp_prelude_FeeMultiplier) -> dpp :: prelude :: FeeMultiplier { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: FeeMultiplier > for dpp_prelude_FeeMultiplier { unsafe fn ffi_to_const (obj : dpp :: prelude :: FeeMultiplier) -> * const dpp_prelude_FeeMultiplier { ferment :: boxed (dpp_prelude_FeeMultiplier (obj)) } } # [doc = "FFI-representation of the [`CoreBlockHeight`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_CoreBlockHeight (u32) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: CoreBlockHeight > for dpp_prelude_CoreBlockHeight { unsafe fn ffi_from_const (ffi : * const dpp_prelude_CoreBlockHeight) -> dpp :: prelude :: CoreBlockHeight { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: CoreBlockHeight > for dpp_prelude_CoreBlockHeight { unsafe fn ffi_to_const (obj : dpp :: prelude :: CoreBlockHeight) -> * const dpp_prelude_CoreBlockHeight { ferment :: boxed (dpp_prelude_CoreBlockHeight (obj)) } } # [doc = "FFI-representation of the [`TimestampMillis`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_TimestampMillis (u64) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: TimestampMillis > for dpp_prelude_TimestampMillis { unsafe fn ffi_from_const (ffi : * const dpp_prelude_TimestampMillis) -> dpp :: prelude :: TimestampMillis { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: TimestampMillis > for dpp_prelude_TimestampMillis { unsafe fn ffi_to_const (obj : dpp :: prelude :: TimestampMillis) -> * const dpp_prelude_TimestampMillis { ferment :: boxed (dpp_prelude_TimestampMillis (obj)) } } # [doc = "FFI-representation of the [`TimestampMillisInterval`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_TimestampMillisInterval (u64) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: TimestampMillisInterval > for dpp_prelude_TimestampMillisInterval { unsafe fn ffi_from_const (ffi : * const dpp_prelude_TimestampMillisInterval) -> dpp :: prelude :: TimestampMillisInterval { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: TimestampMillisInterval > for dpp_prelude_TimestampMillisInterval { unsafe fn ffi_to_const (obj : dpp :: prelude :: TimestampMillisInterval) -> * const dpp_prelude_TimestampMillisInterval { ferment :: boxed (dpp_prelude_TimestampMillisInterval (obj)) } } # [doc = "FFI-representation of the [`StartAtIncluded`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_StartAtIncluded (bool) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: StartAtIncluded > for dpp_prelude_StartAtIncluded { unsafe fn ffi_from_const (ffi : * const dpp_prelude_StartAtIncluded) -> dpp :: prelude :: StartAtIncluded { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: StartAtIncluded > for dpp_prelude_StartAtIncluded { unsafe fn ffi_to_const (obj : dpp :: prelude :: StartAtIncluded) -> * const dpp_prelude_StartAtIncluded { ferment :: boxed (dpp_prelude_StartAtIncluded (obj)) } } # [doc = "FFI-representation of the [`TimestampIncluded`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_TimestampIncluded (bool) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: TimestampIncluded > for dpp_prelude_TimestampIncluded { unsafe fn ffi_from_const (ffi : * const dpp_prelude_TimestampIncluded) -> dpp :: prelude :: TimestampIncluded { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: TimestampIncluded > for dpp_prelude_TimestampIncluded { unsafe fn ffi_to_const (obj : dpp :: prelude :: TimestampIncluded) -> * const dpp_prelude_TimestampIncluded { ferment :: boxed (dpp_prelude_TimestampIncluded (obj)) } } # [doc = "FFI-representation of the [`Revision`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_Revision (u64) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: Revision > for dpp_prelude_Revision { unsafe fn ffi_from_const (ffi : * const dpp_prelude_Revision) -> dpp :: prelude :: Revision { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: Revision > for dpp_prelude_Revision { unsafe fn ffi_to_const (obj : dpp :: prelude :: Revision) -> * const dpp_prelude_Revision { ferment :: boxed (dpp_prelude_Revision (obj)) } } # [doc = "FFI-representation of the [`IdentityNonce`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_IdentityNonce (u64) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce > for dpp_prelude_IdentityNonce { unsafe fn ffi_from_const (ffi : * const dpp_prelude_IdentityNonce) -> dpp :: prelude :: IdentityNonce { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce > for dpp_prelude_IdentityNonce { unsafe fn ffi_to_const (obj : dpp :: prelude :: IdentityNonce) -> * const dpp_prelude_IdentityNonce { ferment :: boxed (dpp_prelude_IdentityNonce (obj)) } } # [doc = "FFI-representation of the [`SenderKeyIndex`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_SenderKeyIndex (u32) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: SenderKeyIndex > for dpp_prelude_SenderKeyIndex { unsafe fn ffi_from_const (ffi : * const dpp_prelude_SenderKeyIndex) -> dpp :: prelude :: SenderKeyIndex { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: SenderKeyIndex > for dpp_prelude_SenderKeyIndex { unsafe fn ffi_to_const (obj : dpp :: prelude :: SenderKeyIndex) -> * const dpp_prelude_SenderKeyIndex { ferment :: boxed (dpp_prelude_SenderKeyIndex (obj)) } } # [doc = "FFI-representation of the [`RecipientKeyIndex`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_RecipientKeyIndex (u32) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: RecipientKeyIndex > for dpp_prelude_RecipientKeyIndex { unsafe fn ffi_from_const (ffi : * const dpp_prelude_RecipientKeyIndex) -> dpp :: prelude :: RecipientKeyIndex { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: RecipientKeyIndex > for dpp_prelude_RecipientKeyIndex { unsafe fn ffi_to_const (obj : dpp :: prelude :: RecipientKeyIndex) -> * const dpp_prelude_RecipientKeyIndex { ferment :: boxed (dpp_prelude_RecipientKeyIndex (obj)) } } # [doc = "FFI-representation of the [`RootEncryptionKeyIndex`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_RootEncryptionKeyIndex (u32) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: RootEncryptionKeyIndex > for dpp_prelude_RootEncryptionKeyIndex { unsafe fn ffi_from_const (ffi : * const dpp_prelude_RootEncryptionKeyIndex) -> dpp :: prelude :: RootEncryptionKeyIndex { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: RootEncryptionKeyIndex > for dpp_prelude_RootEncryptionKeyIndex { unsafe fn ffi_to_const (obj : dpp :: prelude :: RootEncryptionKeyIndex) -> * const dpp_prelude_RootEncryptionKeyIndex { ferment :: boxed (dpp_prelude_RootEncryptionKeyIndex (obj)) } } # [doc = "FFI-representation of the [`DerivationEncryptionKeyIndex`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_DerivationEncryptionKeyIndex (u32) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: DerivationEncryptionKeyIndex > for dpp_prelude_DerivationEncryptionKeyIndex { unsafe fn ffi_from_const (ffi : * const dpp_prelude_DerivationEncryptionKeyIndex) -> dpp :: prelude :: DerivationEncryptionKeyIndex { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: DerivationEncryptionKeyIndex > for dpp_prelude_DerivationEncryptionKeyIndex { unsafe fn ffi_to_const (obj : dpp :: prelude :: DerivationEncryptionKeyIndex) -> * const dpp_prelude_DerivationEncryptionKeyIndex { ferment :: boxed (dpp_prelude_DerivationEncryptionKeyIndex (obj)) } } # [doc = "FFI-representation of the [`UserFeeIncrease`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_UserFeeIncrease (u16) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease > for dpp_prelude_UserFeeIncrease { unsafe fn ffi_from_const (ffi : * const dpp_prelude_UserFeeIncrease) -> dpp :: prelude :: UserFeeIncrease { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease > for dpp_prelude_UserFeeIncrease { unsafe fn ffi_to_const (obj : dpp :: prelude :: UserFeeIncrease) -> * const dpp_prelude_UserFeeIncrease { ferment :: boxed (dpp_prelude_UserFeeIncrease (obj)) } } } } pub mod example_platform { use crate as example_platform ; # [doc = "FFI-representation of the [`SPV`]"] # [repr (C)] # [derive (Clone)] pub struct example_platform_SPV { pub version : u32 } impl ferment :: FFIConversionFrom < example_platform :: SPV > for example_platform_SPV { unsafe fn ffi_from_const (ffi : * const example_platform_SPV) -> example_platform :: SPV { let ffi_ref = & * ffi ; example_platform :: SPV { version : ffi_ref . version } } } impl ferment :: FFIConversionTo < example_platform :: SPV > for example_platform_SPV { unsafe fn ffi_to_const (obj : example_platform :: SPV) -> * const example_platform_SPV { ferment :: boxed (example_platform_SPV { version : obj . version }) } } pub mod spv { use crate as example_platform ; # [doc = "FFI-representation of the [`example_platform::spv::fetch_identity`]"] # [no_mangle] pub unsafe extern "C" fn example_platform_spv_fetch_identity (identifier : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut crate :: fermented :: generics :: Result_ok_dpp_identity_identity_Identity_err_dpp_errors_protocol_error_ProtocolError { let obj = example_platform :: spv :: fetch_identity (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (identifier)) ; < crate :: fermented :: generics :: Result_ok_dpp_identity_identity_Identity_err_dpp_errors_protocol_error_ProtocolError as ferment :: FFIConversionTo < Result < dpp :: identity :: identity :: Identity , dpp :: errors :: protocol_error :: ProtocolError > >> :: ffi_to (obj) } } pub mod dash { use crate as example_platform ; # [doc = "FFI-representation of the [`example_platform::dash::setup_dashcore`]"] # [no_mangle] pub unsafe extern "C" fn example_platform_dash_setup_dashcore (transaction : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: dashcore_blockdata_transaction_Transaction) { let obj = example_platform :: dash :: setup_dashcore (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: dashcore_blockdata_transaction_Transaction as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: Transaction >> :: ffi_from (transaction)) ; ; } } } } # [allow (clippy :: let_and_return , clippy :: suspicious_else_formatting , clippy :: redundant_field_names , dead_code , non_camel_case_types , non_snake_case , non_upper_case_globals , redundant_semicolons , unreachable_patterns , unused_braces , unused_imports , unused_parens , unused_qualifications , unused_unsafe , unused_variables)] pub mod generics { use crate as example_platform ; # [repr (C)] # [derive (Clone)] pub struct Arr_u8_20 { pub count : usize , pub values : * mut u8 } impl ferment :: FFIConversionFrom < [u8 ; 20] > for Arr_u8_20 { unsafe fn ffi_from_const (ffi : * const Arr_u8_20) -> [u8 ; 20] { let ffi_ref = & * ffi ; TryFrom :: < Vec < u8 >> :: try_from (ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | * o)) . unwrap () } } impl ferment :: FFIConversionTo < [u8 ; 20] > for Arr_u8_20 { unsafe fn ffi_to_const (obj : [u8 ; 20]) -> * const Arr_u8_20 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | o) }) } } impl Drop for Arr_u8_20 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: black_hole (o)) ; } } } # [repr (C)] # [derive (Clone)] pub struct Vec_bool { pub count : usize , pub values : * mut bool } impl ferment :: FFIConversionFrom < Vec < bool > > for Vec_bool { unsafe fn ffi_from_const (ffi : * const Vec_bool) -> Vec < bool > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | * o) } } impl ferment :: FFIConversionTo < Vec < bool > > for Vec_bool { unsafe fn ffi_to_const (obj : Vec < bool >) -> * const Vec_bool { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | o) }) } } impl Drop for Vec_bool { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: black_hole (o)) ; ; } } } # [cfg (any (any (feature = "std")))] # [repr (C)] # [derive (Clone)] # [cfg (any (any (feature = "std")))] pub struct Vec_i32 { pub count : usize , pub values : * mut i32 } # [cfg (any (any (feature = "std")))] # [cfg (any (any (feature = "std")))] impl ferment :: FFIConversionFrom < Vec < i32 > > for Vec_i32 { unsafe fn ffi_from_const (ffi : * const Vec_i32) -> Vec < i32 > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | * o) } } # [cfg (any (any (feature = "std")))] # [cfg (any (any (feature = "std")))] impl ferment :: FFIConversionTo < Vec < i32 > > for Vec_i32 { unsafe fn ffi_to_const (obj : Vec < i32 >) -> * const Vec_i32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | o) }) } } # [cfg (any (any (feature = "std")))] # [cfg (any (any (feature = "std")))] impl Drop for Vec_i32 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: black_hole (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , pub values : * mut * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_IdentityPublicKey } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: identity :: identity_public_key :: KeyID , dpp :: identity :: identity_public_key :: IdentityPublicKey > > for std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey) -> std :: collections :: BTreeMap < dpp :: identity :: identity_public_key :: KeyID , dpp :: identity :: identity_public_key :: IdentityPublicKey > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_IdentityPublicKey as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: IdentityPublicKey >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: identity :: identity_public_key :: KeyID , dpp :: identity :: identity_public_key :: IdentityPublicKey > > for std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < dpp :: identity :: identity_public_key :: KeyID , dpp :: identity :: identity_public_key :: IdentityPublicKey >) -> * const std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey { let (count , keys , values) = ferment :: to_map (obj , | o | < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (o) , | o | < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_IdentityPublicKey as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: IdentityPublicKey >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_any (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_BTreeSet_dpp_identity_identity_public_key_KeyID { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < std :: collections :: BTreeSet < dpp :: identity :: identity_public_key :: KeyID > > for std_collections_BTreeSet_dpp_identity_identity_public_key_KeyID { unsafe fn ffi_from_const (ffi : * const std_collections_BTreeSet_dpp_identity_identity_public_key_KeyID) -> std :: collections :: BTreeSet < dpp :: identity :: identity_public_key :: KeyID > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeSet < dpp :: identity :: identity_public_key :: KeyID > > for std_collections_BTreeSet_dpp_identity_identity_public_key_KeyID { unsafe fn ffi_to_const (obj : std :: collections :: BTreeSet < dpp :: identity :: identity_public_key :: KeyID >) -> * const std_collections_BTreeSet_dpp_identity_identity_public_key_KeyID { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (o)) }) } } impl Drop for std_collections_BTreeSet_dpp_identity_identity_public_key_KeyID { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct Result_ok_dpp_identity_identity_Identity_err_dpp_errors_protocol_error_ProtocolError { pub ok : * mut crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_Identity , pub error : * mut crate :: fermented :: types :: dpp :: errors :: protocol_error :: dpp_errors_protocol_error_ProtocolError } impl ferment :: FFIConversionFrom < Result < dpp :: identity :: identity :: Identity , dpp :: errors :: protocol_error :: ProtocolError > > for Result_ok_dpp_identity_identity_Identity_err_dpp_errors_protocol_error_ProtocolError { unsafe fn ffi_from_const (ffi : * const Result_ok_dpp_identity_identity_Identity_err_dpp_errors_protocol_error_ProtocolError) -> Result < dpp :: identity :: identity :: Identity , dpp :: errors :: protocol_error :: ProtocolError > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | < crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_Identity as ferment :: FFIConversionFrom < dpp :: identity :: identity :: Identity >> :: ffi_from (o) , ffi_ref . error , | o | < crate :: fermented :: types :: dpp :: errors :: protocol_error :: dpp_errors_protocol_error_ProtocolError as ferment :: FFIConversionFrom < dpp :: errors :: protocol_error :: ProtocolError >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < Result < dpp :: identity :: identity :: Identity , dpp :: errors :: protocol_error :: ProtocolError > > for Result_ok_dpp_identity_identity_Identity_err_dpp_errors_protocol_error_ProtocolError { unsafe fn ffi_to_const (obj : Result < dpp :: identity :: identity :: Identity , dpp :: errors :: protocol_error :: ProtocolError >) -> * const Result_ok_dpp_identity_identity_Identity_err_dpp_errors_protocol_error_ProtocolError { let (ok , error) = ferment :: to_result (obj , | o | < crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_Identity as ferment :: FFIConversionTo < dpp :: identity :: identity :: Identity >> :: ffi_to (o) , | o | < crate :: fermented :: types :: dpp :: errors :: protocol_error :: dpp_errors_protocol_error_ProtocolError as ferment :: FFIConversionTo < dpp :: errors :: protocol_error :: ProtocolError >> :: ffi_to (o)) ; ferment :: boxed (Self { ok , error }) } } impl Drop for Result_ok_dpp_identity_identity_Identity_err_dpp_errors_protocol_error_ProtocolError { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . ok) ; ferment :: unbox_any (self . error) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_String_values_platform_value_Value { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut crate :: fermented :: types :: platform_value :: platform_value_Value } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , platform_value :: Value > > for std_collections_Map_keys_String_values_platform_value_Value { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_String_values_platform_value_Value) -> std :: collections :: BTreeMap < String , platform_value :: Value > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , platform_value :: Value > > for std_collections_Map_keys_String_values_platform_value_Value { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < String , platform_value :: Value >) -> * const std_collections_Map_keys_String_values_platform_value_Value { let (count , keys , values) = ferment :: to_map (obj , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o) , | o | < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_String_values_platform_value_Value { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_string (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dpp :: voting :: contender_structs :: dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo } impl ferment :: FFIConversionFrom < Vec < dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo > > for Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { unsafe fn ffi_from_const (ffi : * const Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo) -> Vec < dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: voting :: contender_structs :: dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo as ferment :: FFIConversionFrom < dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo > > for Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { unsafe fn ffi_to_const (obj : Vec < dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo >) -> * const Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: dpp :: voting :: contender_structs :: dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo as ferment :: FFIConversionTo < dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo >> :: ffi_to (o)) }) } } impl Drop for Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct Vec_dpp_identity_identity_public_key_KeyID { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < Vec < dpp :: identity :: identity_public_key :: KeyID > > for Vec_dpp_identity_identity_public_key_KeyID { unsafe fn ffi_from_const (ffi : * const Vec_dpp_identity_identity_public_key_KeyID) -> Vec < dpp :: identity :: identity_public_key :: KeyID > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < dpp :: identity :: identity_public_key :: KeyID > > for Vec_dpp_identity_identity_public_key_KeyID { unsafe fn ffi_to_const (obj : Vec < dpp :: identity :: identity_public_key :: KeyID >) -> * const Vec_dpp_identity_identity_public_key_KeyID { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (o)) }) } } impl Drop for Vec_dpp_identity_identity_public_key_KeyID { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_Index } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: Index > > for std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index) -> std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: Index > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_Index as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index :: Index >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: Index > > for std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: Index >) -> * const std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index { let (count , keys , values) = ferment :: to_map (obj , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_Index as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index :: Index >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_string (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_DocumentProperty } impl ferment :: FFIConversionFrom < indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > > for indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty { unsafe fn ffi_from_const (ffi : * const indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty) -> indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_DocumentProperty as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: property :: DocumentProperty >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > > for indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty { unsafe fn ffi_to_const (obj : indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty >) -> * const indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty { let (count , keys , values) = ferment :: to_map (obj , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_DocumentProperty as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: property :: DocumentProperty >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_string (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_BTreeSet_String { pub count : usize , pub values : * mut * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < std :: collections :: BTreeSet < String > > for std_collections_BTreeSet_String { unsafe fn ffi_from_const (ffi : * const std_collections_BTreeSet_String) -> std :: collections :: BTreeSet < String > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeSet < String > > for std_collections_BTreeSet_String { unsafe fn ffi_to_const (obj : std :: collections :: BTreeSet < String >) -> * const std_collections_BTreeSet_String { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o)) }) } } impl Drop for std_collections_BTreeSet_String { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_string (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct Vec_u8 { pub count : usize , pub values : * mut u8 } impl ferment :: FFIConversionFrom < Vec < u8 > > for Vec_u8 { unsafe fn ffi_from_const (ffi : * const Vec_u8) -> Vec < u8 > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | * o) } } impl ferment :: FFIConversionTo < Vec < u8 > > for Vec_u8 { unsafe fn ffi_to_const (obj : Vec < u8 >) -> * const Vec_u8 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | o) }) } } impl Drop for Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: black_hole (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct Arr_u8_32 { pub count : usize , pub values : * mut u8 } impl ferment :: FFIConversionFrom < [u8 ; 32] > for Arr_u8_32 { unsafe fn ffi_from_const (ffi : * const Arr_u8_32) -> [u8 ; 32] { let ffi_ref = & * ffi ; TryFrom :: < Vec < u8 >> :: try_from (ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | * o)) . unwrap () } } impl ferment :: FFIConversionTo < [u8 ; 32] > for Arr_u8_32 { unsafe fn ffi_to_const (obj : [u8 ; 32]) -> * const Arr_u8_32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | o) }) } } impl Drop for Arr_u8_32 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: black_hole (o)) ; } } } # [repr (C)] # [derive (Clone)] pub struct Vec_platform_value_Value { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: platform_value :: platform_value_Value } impl ferment :: FFIConversionFrom < Vec < platform_value :: Value > > for Vec_platform_value_Value { unsafe fn ffi_from_const (ffi : * const Vec_platform_value_Value) -> Vec < platform_value :: Value > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < platform_value :: Value > > for Vec_platform_value_Value { unsafe fn ffi_to_const (obj : Vec < platform_value :: Value >) -> * const Vec_platform_value_Value { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (o)) }) } } impl Drop for Vec_platform_value_Value { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct Vec_String { pub count : usize , pub values : * mut * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < Vec < String > > for Vec_String { unsafe fn ffi_from_const (ffi : * const Vec_String) -> Vec < String > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < String > > for Vec_String { unsafe fn ffi_to_const (obj : Vec < String >) -> * const Vec_String { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o)) }) } } impl Drop for Vec_String { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_string (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct Arr_dashcore_bls_sig_utils_BLSSignature_4 { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature } impl ferment :: FFIConversionFrom < [dashcore :: bls_sig_utils :: BLSSignature ; 4] > for Arr_dashcore_bls_sig_utils_BLSSignature_4 { unsafe fn ffi_from_const (ffi : * const Arr_dashcore_bls_sig_utils_BLSSignature_4) -> [dashcore :: bls_sig_utils :: BLSSignature ; 4] { let ffi_ref = & * ffi ; TryFrom :: < Vec < dashcore :: bls_sig_utils :: BLSSignature >> :: try_from (ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_from (* o))) . unwrap () } } impl ferment :: FFIConversionTo < [dashcore :: bls_sig_utils :: BLSSignature ; 4] > for Arr_dashcore_bls_sig_utils_BLSSignature_4 { unsafe fn ffi_to_const (obj : [dashcore :: bls_sig_utils :: BLSSignature ; 4]) -> * const Arr_dashcore_bls_sig_utils_BLSSignature_4 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_to (o)) }) } } impl Drop for Arr_dashcore_bls_sig_utils_BLSSignature_4 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; } } } # [repr (C)] # [derive (Clone)] pub struct Arr_u8_2 { pub count : usize , pub values : * mut u8 } impl ferment :: FFIConversionFrom < [u8 ; 2] > for Arr_u8_2 { unsafe fn ffi_from_const (ffi : * const Arr_u8_2) -> [u8 ; 2] { let ffi_ref = & * ffi ; TryFrom :: < Vec < u8 >> :: try_from (ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | * o)) . unwrap () } } impl ferment :: FFIConversionTo < [u8 ; 2] > for Arr_u8_2 { unsafe fn ffi_to_const (obj : [u8 ; 2]) -> * const Arr_u8_2 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | o) }) } } impl Drop for Arr_u8_2 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: black_hole (o)) ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DocumentName , pub values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: dpp_data_contract_document_type_DocumentType } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , dpp :: data_contract :: document_type :: DocumentType > > for std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType) -> std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , dpp :: data_contract :: document_type :: DocumentType > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DocumentName as ferment :: FFIConversionFrom < dpp :: data_contract :: DocumentName >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: dpp_data_contract_document_type_DocumentType as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: DocumentType >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , dpp :: data_contract :: document_type :: DocumentType > > for std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , dpp :: data_contract :: document_type :: DocumentType >) -> * const std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType { let (count , keys , values) = ferment :: to_map (obj , | o | < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DocumentName as ferment :: FFIConversionTo < dpp :: data_contract :: DocumentName >> :: ffi_to (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: dpp_data_contract_document_type_DocumentType as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: DocumentType >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_any (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DefinitionName , pub values : * mut * mut crate :: fermented :: types :: platform_value :: platform_value_Value } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > > for std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value) -> std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DefinitionName as ferment :: FFIConversionFrom < dpp :: data_contract :: DefinitionName >> :: ffi_from (o) , | o | < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > > for std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value >) -> * const std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value { let (count , keys , values) = ferment :: to_map (obj , | o | < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DefinitionName as ferment :: FFIConversionTo < dpp :: data_contract :: DefinitionName >> :: ffi_to (o) , | o | < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_any (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , pub values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_Group } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: GroupContractPosition , dpp :: data_contract :: group :: Group > > for std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group) -> std :: collections :: BTreeMap < dpp :: data_contract :: GroupContractPosition , dpp :: data_contract :: group :: Group > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_Group as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: Group >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: GroupContractPosition , dpp :: data_contract :: group :: Group > > for std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < dpp :: data_contract :: GroupContractPosition , dpp :: data_contract :: group :: Group >) -> * const std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group { let (count , keys , values) = ferment :: to_map (obj , | o | < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_Group as ferment :: FFIConversionTo < dpp :: data_contract :: group :: Group >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_any (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , pub values : * mut * mut dpp :: data_contract :: associated_token :: token_configuration :: TokenConfiguration } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: TokenContractPosition , dpp :: data_contract :: associated_token :: token_configuration :: TokenConfiguration > > for std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration) -> std :: collections :: BTreeMap < dpp :: data_contract :: TokenContractPosition , dpp :: data_contract :: associated_token :: token_configuration :: TokenConfiguration > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from (o) , | o | std :: ptr :: read (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: TokenContractPosition , dpp :: data_contract :: associated_token :: token_configuration :: TokenConfiguration > > for std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < dpp :: data_contract :: TokenContractPosition , dpp :: data_contract :: associated_token :: token_configuration :: TokenConfiguration >) -> * const std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration { let (count , keys , values) = ferment :: to_map (obj , | o | < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition >> :: ffi_to (o) , | o | ferment :: boxed (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_any (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct Vec_dpp_version_FeatureVersion { pub count : usize , pub values : * mut * mut dpp :: version :: FeatureVersion } impl ferment :: FFIConversionFrom < Vec < dpp :: version :: FeatureVersion > > for Vec_dpp_version_FeatureVersion { unsafe fn ffi_from_const (ffi : * const Vec_dpp_version_FeatureVersion) -> Vec < dpp :: version :: FeatureVersion > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | std :: ptr :: read (* o)) } } impl ferment :: FFIConversionTo < Vec < dpp :: version :: FeatureVersion > > for Vec_dpp_version_FeatureVersion { unsafe fn ffi_to_const (obj : Vec < dpp :: version :: FeatureVersion >) -> * const Vec_dpp_version_FeatureVersion { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | ferment :: boxed (o)) }) } } impl Drop for Vec_dpp_version_FeatureVersion { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct Vec_dpp_data_contract_document_type_index_IndexProperty { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_IndexProperty } impl ferment :: FFIConversionFrom < Vec < dpp :: data_contract :: document_type :: index :: IndexProperty > > for Vec_dpp_data_contract_document_type_index_IndexProperty { unsafe fn ffi_from_const (ffi : * const Vec_dpp_data_contract_document_type_index_IndexProperty) -> Vec < dpp :: data_contract :: document_type :: index :: IndexProperty > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_IndexProperty as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index :: IndexProperty >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < dpp :: data_contract :: document_type :: index :: IndexProperty > > for Vec_dpp_data_contract_document_type_index_IndexProperty { unsafe fn ffi_to_const (obj : Vec < dpp :: data_contract :: document_type :: index :: IndexProperty >) -> * const Vec_dpp_data_contract_document_type_index_IndexProperty { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_IndexProperty as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index :: IndexProperty >> :: ffi_to (o)) }) } } impl Drop for Vec_dpp_data_contract_document_type_index_IndexProperty { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount { pub count : usize , pub keys : * mut u64 , pub values : * mut * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u64 , dpp :: balances :: credits :: TokenAmount > > for std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount) -> std :: collections :: BTreeMap < u64 , dpp :: balances :: credits :: TokenAmount > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | o , | o | < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < u64 , dpp :: balances :: credits :: TokenAmount > > for std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < u64 , dpp :: balances :: credits :: TokenAmount >) -> * const std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount { let (count , keys , values) = ferment :: to_map (obj , | o | o , | o | < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: black_hole (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct Tuple_String_Arr_u8_32 { pub o_0 : * mut std :: os :: raw :: c_char , pub o_1 : * mut crate :: fermented :: generics :: Arr_u8_32 } impl ferment :: FFIConversionFrom < (String , [u8 ; 32]) > for Tuple_String_Arr_u8_32 { unsafe fn ffi_from_const (ffi : * const Tuple_String_Arr_u8_32) -> (String , [u8 ; 32]) { let ffi_ref = & * ffi ; (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . o_0) , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (ffi_ref . o_1)) } } impl ferment :: FFIConversionTo < (String , [u8 ; 32]) > for Tuple_String_Arr_u8_32 { unsafe fn ffi_to_const (obj : (String , [u8 ; 32])) -> * const Tuple_String_Arr_u8_32 { ferment :: boxed (Self { o_0 : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . 0) , o_1 : < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (obj . 1) }) } } impl Drop for Tuple_String_Arr_u8_32 { fn drop (& mut self) { unsafe { ferment :: unbox_string (self . o_0) ; ferment :: unbox_any (self . o_1) ; } } } # [repr (C)] # [derive (Clone)] pub struct Vec_Tuple_String_Arr_u8_32 { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Tuple_String_Arr_u8_32 } impl ferment :: FFIConversionFrom < Vec < (String , [u8 ; 32]) > > for Vec_Tuple_String_Arr_u8_32 { unsafe fn ffi_from_const (ffi : * const Vec_Tuple_String_Arr_u8_32) -> Vec < (String , [u8 ; 32]) > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: generics :: Tuple_String_Arr_u8_32 as ferment :: FFIConversionFrom < (String , [u8 ; 32]) >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < (String , [u8 ; 32]) > > for Vec_Tuple_String_Arr_u8_32 { unsafe fn ffi_to_const (obj : Vec < (String , [u8 ; 32]) >) -> * const Vec_Tuple_String_Arr_u8_32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: generics :: Tuple_String_Arr_u8_32 as ferment :: FFIConversionTo < (String , [u8 ; 32]) >> :: ffi_to (o)) }) } } impl Drop for Vec_Tuple_String_Arr_u8_32 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct Vec_dashcore_sml_llmq_type_DKGWindow { pub count : usize , pub values : * mut * mut dashcore :: sml :: llmq_type :: DKGWindow } impl ferment :: FFIConversionFrom < Vec < dashcore :: sml :: llmq_type :: DKGWindow > > for Vec_dashcore_sml_llmq_type_DKGWindow { unsafe fn ffi_from_const (ffi : * const Vec_dashcore_sml_llmq_type_DKGWindow) -> Vec < dashcore :: sml :: llmq_type :: DKGWindow > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | std :: ptr :: read (* o)) } } impl ferment :: FFIConversionTo < Vec < dashcore :: sml :: llmq_type :: DKGWindow > > for Vec_dashcore_sml_llmq_type_DKGWindow { unsafe fn ffi_to_const (obj : Vec < dashcore :: sml :: llmq_type :: DKGWindow >) -> * const Vec_dashcore_sml_llmq_type_DKGWindow { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | ferment :: boxed (o)) }) } } impl Drop for Vec_dashcore_sml_llmq_type_DKGWindow { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct Vec_dpp_identity_identity_public_key_security_level_SecurityLevel { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel } impl ferment :: FFIConversionFrom < Vec < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel > > for Vec_dpp_identity_identity_public_key_security_level_SecurityLevel { unsafe fn ffi_from_const (ffi : * const Vec_dpp_identity_identity_public_key_security_level_SecurityLevel) -> Vec < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel > > for Vec_dpp_identity_identity_public_key_security_level_SecurityLevel { unsafe fn ffi_to_const (obj : Vec < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >) -> * const Vec_dpp_identity_identity_public_key_security_level_SecurityLevel { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_to (o)) }) } } impl Drop for Vec_dpp_identity_identity_public_key_security_level_SecurityLevel { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DocumentName , pub values : * mut * mut crate :: fermented :: types :: platform_value :: platform_value_Value } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , platform_value :: Value > > for std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value) -> std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , platform_value :: Value > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DocumentName as ferment :: FFIConversionFrom < dpp :: data_contract :: DocumentName >> :: ffi_from (o) , | o | < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , platform_value :: Value > > for std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , platform_value :: Value >) -> * const std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value { let (count , keys , values) = ferment :: to_map (obj , | o | < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DocumentName as ferment :: FFIConversionTo < dpp :: data_contract :: DocumentName >> :: ffi_to (o) , | o | < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_any (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct Vec_dpp_errors_consensus_consensus_error_ConsensusError { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dpp :: errors :: consensus :: consensus_error :: dpp_errors_consensus_consensus_error_ConsensusError } impl ferment :: FFIConversionFrom < Vec < dpp :: errors :: consensus :: consensus_error :: ConsensusError > > for Vec_dpp_errors_consensus_consensus_error_ConsensusError { unsafe fn ffi_from_const (ffi : * const Vec_dpp_errors_consensus_consensus_error_ConsensusError) -> Vec < dpp :: errors :: consensus :: consensus_error :: ConsensusError > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: errors :: consensus :: consensus_error :: dpp_errors_consensus_consensus_error_ConsensusError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: consensus_error :: ConsensusError >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < dpp :: errors :: consensus :: consensus_error :: ConsensusError > > for Vec_dpp_errors_consensus_consensus_error_ConsensusError { unsafe fn ffi_to_const (obj : Vec < dpp :: errors :: consensus :: consensus_error :: ConsensusError >) -> * const Vec_dpp_errors_consensus_consensus_error_ConsensusError { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: dpp :: errors :: consensus :: consensus_error :: dpp_errors_consensus_consensus_error_ConsensusError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: consensus_error :: ConsensusError >> :: ffi_to (o)) }) } } impl Drop for Vec_dpp_errors_consensus_consensus_error_ConsensusError { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct Arr_u8_36 { pub count : usize , pub values : * mut u8 } impl ferment :: FFIConversionFrom < [u8 ; 36] > for Arr_u8_36 { unsafe fn ffi_from_const (ffi : * const Arr_u8_36) -> [u8 ; 36] { let ffi_ref = & * ffi ; TryFrom :: < Vec < u8 >> :: try_from (ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | * o)) . unwrap () } } impl ferment :: FFIConversionTo < [u8 ; 36] > for Arr_u8_36 { unsafe fn ffi_to_const (obj : [u8 ; 36]) -> * const Arr_u8_36 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | o) }) } } impl Drop for Arr_u8_36 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: black_hole (o)) ; } } } # [repr (C)] # [derive (Clone)] pub struct Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8 { pub o_0 : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_SenderKeyIndex , pub o_1 : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_RecipientKeyIndex , pub o_2 : * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < (dpp :: prelude :: SenderKeyIndex , dpp :: prelude :: RecipientKeyIndex , Vec < u8 >) > for Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8 { unsafe fn ffi_from_const (ffi : * const Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8) -> (dpp :: prelude :: SenderKeyIndex , dpp :: prelude :: RecipientKeyIndex , Vec < u8 >) { let ffi_ref = & * ffi ; (< crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_SenderKeyIndex as ferment :: FFIConversionFrom < dpp :: prelude :: SenderKeyIndex >> :: ffi_from (ffi_ref . o_0) , < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_RecipientKeyIndex as ferment :: FFIConversionFrom < dpp :: prelude :: RecipientKeyIndex >> :: ffi_from (ffi_ref . o_1) , < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . o_2)) } } impl ferment :: FFIConversionTo < (dpp :: prelude :: SenderKeyIndex , dpp :: prelude :: RecipientKeyIndex , Vec < u8 >) > for Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8 { unsafe fn ffi_to_const (obj : (dpp :: prelude :: SenderKeyIndex , dpp :: prelude :: RecipientKeyIndex , Vec < u8 >)) -> * const Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8 { ferment :: boxed (Self { o_0 : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_SenderKeyIndex as ferment :: FFIConversionTo < dpp :: prelude :: SenderKeyIndex >> :: ffi_to (obj . 0) , o_1 : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_RecipientKeyIndex as ferment :: FFIConversionTo < dpp :: prelude :: RecipientKeyIndex >> :: ffi_to (obj . 1) , o_2 : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . 2) }) } } impl Drop for Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . o_0) ; ferment :: unbox_any (self . o_1) ; ferment :: unbox_any (self . o_2) ; } } } # [cfg (any (any (feature = "state-transitions")))] # [repr (C)] # [derive (Clone)] # [cfg (any (any (feature = "state-transitions")))] pub struct Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl ferment :: FFIConversionFrom < Vec < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition > > for Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { unsafe fn ffi_from_const (ffi : * const Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition) -> Vec < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition >> :: ffi_from (* o)) } } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl ferment :: FFIConversionTo < Vec < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition > > for Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { unsafe fn ffi_to_const (obj : Vec < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition >) -> * const Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition >> :: ffi_to (o)) }) } } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl Drop for Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct Vec_dashcore_blockdata_transaction_txin_TxIn { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: txin :: dashcore_blockdata_transaction_txin_TxIn } impl ferment :: FFIConversionFrom < Vec < dashcore :: blockdata :: transaction :: txin :: TxIn > > for Vec_dashcore_blockdata_transaction_txin_TxIn { unsafe fn ffi_from_const (ffi : * const Vec_dashcore_blockdata_transaction_txin_TxIn) -> Vec < dashcore :: blockdata :: transaction :: txin :: TxIn > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: txin :: dashcore_blockdata_transaction_txin_TxIn as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: txin :: TxIn >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < dashcore :: blockdata :: transaction :: txin :: TxIn > > for Vec_dashcore_blockdata_transaction_txin_TxIn { unsafe fn ffi_to_const (obj : Vec < dashcore :: blockdata :: transaction :: txin :: TxIn >) -> * const Vec_dashcore_blockdata_transaction_txin_TxIn { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: txin :: dashcore_blockdata_transaction_txin_TxIn as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: txin :: TxIn >> :: ffi_to (o)) }) } } impl Drop for Vec_dashcore_blockdata_transaction_txin_TxIn { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct Vec_dashcore_blockdata_transaction_txout_TxOut { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: txout :: dashcore_blockdata_transaction_txout_TxOut } impl ferment :: FFIConversionFrom < Vec < dashcore :: blockdata :: transaction :: txout :: TxOut > > for Vec_dashcore_blockdata_transaction_txout_TxOut { unsafe fn ffi_from_const (ffi : * const Vec_dashcore_blockdata_transaction_txout_TxOut) -> Vec < dashcore :: blockdata :: transaction :: txout :: TxOut > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: txout :: dashcore_blockdata_transaction_txout_TxOut as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: txout :: TxOut >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < dashcore :: blockdata :: transaction :: txout :: TxOut > > for Vec_dashcore_blockdata_transaction_txout_TxOut { unsafe fn ffi_to_const (obj : Vec < dashcore :: blockdata :: transaction :: txout :: TxOut >) -> * const Vec_dashcore_blockdata_transaction_txout_TxOut { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: txout :: dashcore_blockdata_transaction_txout_TxOut as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: txout :: TxOut >> :: ffi_to (o)) }) } } impl Drop for Vec_dashcore_blockdata_transaction_txout_TxOut { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [cfg (any (any (feature = "state-transitions")))] # [repr (C)] # [derive (Clone)] # [cfg (any (any (feature = "state-transitions")))] pub struct Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl ferment :: FFIConversionFrom < Vec < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation > > for Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { unsafe fn ffi_from_const (ffi : * const Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation) -> Vec < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation >> :: ffi_from (* o)) } } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl ferment :: FFIConversionTo < Vec < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation > > for Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { unsafe fn ffi_to_const (obj : Vec < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation >) -> * const Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation >> :: ffi_to (o)) }) } } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl Drop for Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index_level :: IndexLevel > > for std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel) -> std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index_level :: IndexLevel > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index_level :: IndexLevel >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index_level :: IndexLevel > > for std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index_level :: IndexLevel >) -> * const std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel { let (count , keys , values) = ferment :: to_map (obj , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index_level :: IndexLevel >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_string (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct Vec_Tuple_platform_value_Value_platform_value_Value { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Tuple_platform_value_Value_platform_value_Value } impl ferment :: FFIConversionFrom < Vec < (platform_value :: Value , platform_value :: Value) > > for Vec_Tuple_platform_value_Value_platform_value_Value { unsafe fn ffi_from_const (ffi : * const Vec_Tuple_platform_value_Value_platform_value_Value) -> Vec < (platform_value :: Value , platform_value :: Value) > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: generics :: Tuple_platform_value_Value_platform_value_Value as ferment :: FFIConversionFrom < (platform_value :: Value , platform_value :: Value) >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < (platform_value :: Value , platform_value :: Value) > > for Vec_Tuple_platform_value_Value_platform_value_Value { unsafe fn ffi_to_const (obj : Vec < (platform_value :: Value , platform_value :: Value) >) -> * const Vec_Tuple_platform_value_Value_platform_value_Value { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: generics :: Tuple_platform_value_Value_platform_value_Value as ferment :: FFIConversionTo < (platform_value :: Value , platform_value :: Value) >> :: ffi_to (o)) }) } } impl Drop for Vec_Tuple_platform_value_Value_platform_value_Value { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct Tuple_platform_value_Value_platform_value_Value { pub o_0 : * mut crate :: fermented :: types :: platform_value :: platform_value_Value , pub o_1 : * mut crate :: fermented :: types :: platform_value :: platform_value_Value } impl ferment :: FFIConversionFrom < (platform_value :: Value , platform_value :: Value) > for Tuple_platform_value_Value_platform_value_Value { unsafe fn ffi_from_const (ffi : * const Tuple_platform_value_Value_platform_value_Value) -> (platform_value :: Value , platform_value :: Value) { let ffi_ref = & * ffi ; (< crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (ffi_ref . o_0) , < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (ffi_ref . o_1)) } } impl ferment :: FFIConversionTo < (platform_value :: Value , platform_value :: Value) > for Tuple_platform_value_Value_platform_value_Value { unsafe fn ffi_to_const (obj : (platform_value :: Value , platform_value :: Value)) -> * const Tuple_platform_value_Value_platform_value_Value { ferment :: boxed (Self { o_0 : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (obj . 0) , o_1 : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (obj . 1) }) } } impl Drop for Tuple_platform_value_Value_platform_value_Value { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . o_0) ; ferment :: unbox_any (self . o_1) ; } } } # [repr (C)] # [derive (Clone)] pub struct Vec_dpp_data_contract_document_type_property_array_ArrayItemType { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: array :: dpp_data_contract_document_type_property_array_ArrayItemType } impl ferment :: FFIConversionFrom < Vec < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType > > for Vec_dpp_data_contract_document_type_property_array_ArrayItemType { unsafe fn ffi_from_const (ffi : * const Vec_dpp_data_contract_document_type_property_array_ArrayItemType) -> Vec < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: array :: dpp_data_contract_document_type_property_array_ArrayItemType as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType > > for Vec_dpp_data_contract_document_type_property_array_ArrayItemType { unsafe fn ffi_to_const (obj : Vec < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType >) -> * const Vec_dpp_data_contract_document_type_property_array_ArrayItemType { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: array :: dpp_data_contract_document_type_property_array_ArrayItemType as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType >> :: ffi_to (o)) }) } } impl Drop for Vec_dpp_data_contract_document_type_property_array_ArrayItemType { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct Arr_u8_48 { pub count : usize , pub values : * mut u8 } impl ferment :: FFIConversionFrom < [u8 ; 48] > for Arr_u8_48 { unsafe fn ffi_from_const (ffi : * const Arr_u8_48) -> [u8 ; 48] { let ffi_ref = & * ffi ; TryFrom :: < Vec < u8 >> :: try_from (ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | * o)) . unwrap () } } impl ferment :: FFIConversionTo < [u8 ; 48] > for Arr_u8_48 { unsafe fn ffi_to_const (obj : [u8 ; 48]) -> * const Arr_u8_48 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | o) }) } } impl Drop for Arr_u8_48 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: black_hole (o)) ; } } } # [repr (C)] # [derive (Clone)] pub struct Arr_u8_96 { pub count : usize , pub values : * mut u8 } impl ferment :: FFIConversionFrom < [u8 ; 96] > for Arr_u8_96 { unsafe fn ffi_from_const (ffi : * const Arr_u8_96) -> [u8 ; 96] { let ffi_ref = & * ffi ; TryFrom :: < Vec < u8 >> :: try_from (ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | * o)) . unwrap () } } impl ferment :: FFIConversionTo < [u8 ; 96] > for Arr_u8_96 { unsafe fn ffi_to_const (obj : [u8 ; 96]) -> * const Arr_u8_96 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | o) }) } } impl Drop for Arr_u8_96 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: black_hole (o)) ; } } } # [cfg (any (any (feature = "state-transitions")))] # [repr (C)] # [derive (Clone)] # [cfg (any (any (feature = "state-transitions")))] pub struct std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub values : * mut * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , dpp :: balances :: credits :: TokenAmount > > for std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount) -> std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , dpp :: balances :: credits :: TokenAmount > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (o)) } } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , dpp :: balances :: credits :: TokenAmount > > for std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , dpp :: balances :: credits :: TokenAmount >) -> * const std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount { let (count , keys , values) = ferment :: to_map (obj , | o | < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (o) , | o | < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl Drop for std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_any (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [cfg (any (any (feature = "state-transitions")))] # [repr (C)] # [derive (Clone)] # [cfg (any (any (feature = "state-transitions")))] pub struct std_collections_Map_keys_platform_value_types_identifier_Identifier_values_Option_dpp_document_Document { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub values : * mut * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , Option < dpp :: document :: Document > > > for std_collections_Map_keys_platform_value_types_identifier_Identifier_values_Option_dpp_document_Document { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_platform_value_types_identifier_Identifier_values_Option_dpp_document_Document) -> std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , Option < dpp :: document :: Document > > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionFrom < dpp :: document :: Document >> :: ffi_from_opt (o)) } } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , Option < dpp :: document :: Document > > > for std_collections_Map_keys_platform_value_types_identifier_Identifier_values_Option_dpp_document_Document { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , Option < dpp :: document :: Document > >) -> * const std_collections_Map_keys_platform_value_types_identifier_Identifier_values_Option_dpp_document_Document { let (count , keys , values) = ferment :: to_map (obj , | o | < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (o) , | o | < crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionTo < dpp :: document :: Document >> :: ffi_to_opt (o)) ; ferment :: boxed (Self { count , keys , values }) } } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl Drop for std_collections_Map_keys_platform_value_types_identifier_Identifier_values_Option_dpp_document_Document { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_any (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any_opt (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8 { pub o_0 : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_RootEncryptionKeyIndex , pub o_1 : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_DerivationEncryptionKeyIndex , pub o_2 : * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < (dpp :: prelude :: RootEncryptionKeyIndex , dpp :: prelude :: DerivationEncryptionKeyIndex , Vec < u8 > ,) > for Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8 { unsafe fn ffi_from_const (ffi : * const Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8) -> (dpp :: prelude :: RootEncryptionKeyIndex , dpp :: prelude :: DerivationEncryptionKeyIndex , Vec < u8 > ,) { let ffi_ref = & * ffi ; (< crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_RootEncryptionKeyIndex as ferment :: FFIConversionFrom < dpp :: prelude :: RootEncryptionKeyIndex >> :: ffi_from (ffi_ref . o_0) , < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_DerivationEncryptionKeyIndex as ferment :: FFIConversionFrom < dpp :: prelude :: DerivationEncryptionKeyIndex >> :: ffi_from (ffi_ref . o_1) , < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . o_2)) } } impl ferment :: FFIConversionTo < (dpp :: prelude :: RootEncryptionKeyIndex , dpp :: prelude :: DerivationEncryptionKeyIndex , Vec < u8 > ,) > for Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8 { unsafe fn ffi_to_const (obj : (dpp :: prelude :: RootEncryptionKeyIndex , dpp :: prelude :: DerivationEncryptionKeyIndex , Vec < u8 > ,)) -> * const Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8 { ferment :: boxed (Self { o_0 : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_RootEncryptionKeyIndex as ferment :: FFIConversionTo < dpp :: prelude :: RootEncryptionKeyIndex >> :: ffi_to (obj . 0) , o_1 : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_DerivationEncryptionKeyIndex as ferment :: FFIConversionTo < dpp :: prelude :: DerivationEncryptionKeyIndex >> :: ffi_to (obj . 1) , o_2 : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . 2) }) } } impl Drop for Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . o_0) ; ferment :: unbox_any (self . o_1) ; ferment :: unbox_any (self . o_2) ; } } } # [cfg (any (any (feature = "state-transitions")))] # [repr (C)] # [derive (Clone)] # [cfg (any (any (feature = "state-transitions")))] pub struct Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl ferment :: FFIConversionFrom < Vec < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition > > for Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { unsafe fn ffi_from_const (ffi : * const Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition) -> Vec < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition >> :: ffi_from (* o)) } } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl ferment :: FFIConversionTo < Vec < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition > > for Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { unsafe fn ffi_to_const (obj : Vec < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition >) -> * const Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition >> :: ffi_to (o)) }) } } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl Drop for Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct Tuple_platform_value_types_identifier_Identifier_u8 { pub o_0 : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub o_1 : u8 } impl ferment :: FFIConversionFrom < (platform_value :: types :: identifier :: Identifier , u8) > for Tuple_platform_value_types_identifier_Identifier_u8 { unsafe fn ffi_from_const (ffi : * const Tuple_platform_value_types_identifier_Identifier_u8) -> (platform_value :: types :: identifier :: Identifier , u8) { let ffi_ref = & * ffi ; (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . o_0) , ffi_ref . o_1) } } impl ferment :: FFIConversionTo < (platform_value :: types :: identifier :: Identifier , u8) > for Tuple_platform_value_types_identifier_Identifier_u8 { unsafe fn ffi_to_const (obj : (platform_value :: types :: identifier :: Identifier , u8)) -> * const Tuple_platform_value_types_identifier_Identifier_u8 { ferment :: boxed (Self { o_0 : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . 0) , o_1 : obj . 1 }) } } impl Drop for Tuple_platform_value_types_identifier_Identifier_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . o_0) ; } } } # [repr (C)] # [derive (Clone)] pub struct Vec_Tuple_platform_value_types_identifier_Identifier_u8 { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Tuple_platform_value_types_identifier_Identifier_u8 } impl ferment :: FFIConversionFrom < Vec < (platform_value :: types :: identifier :: Identifier , u8) > > for Vec_Tuple_platform_value_types_identifier_Identifier_u8 { unsafe fn ffi_from_const (ffi : * const Vec_Tuple_platform_value_types_identifier_Identifier_u8) -> Vec < (platform_value :: types :: identifier :: Identifier , u8) > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: generics :: Tuple_platform_value_types_identifier_Identifier_u8 as ferment :: FFIConversionFrom < (platform_value :: types :: identifier :: Identifier , u8) >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < (platform_value :: types :: identifier :: Identifier , u8) > > for Vec_Tuple_platform_value_types_identifier_Identifier_u8 { unsafe fn ffi_to_const (obj : Vec < (platform_value :: types :: identifier :: Identifier , u8) >) -> * const Vec_Tuple_platform_value_types_identifier_Identifier_u8 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: generics :: Tuple_platform_value_types_identifier_Identifier_u8 as ferment :: FFIConversionTo < (platform_value :: types :: identifier :: Identifier , u8) >> :: ffi_to (o)) }) } } impl Drop for Vec_Tuple_platform_value_types_identifier_Identifier_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct std_vec_Vec_dashcore_blockdata_transaction_outpoint_OutPoint { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint } impl ferment :: FFIConversionFrom < std :: vec :: Vec < dashcore :: blockdata :: transaction :: outpoint :: OutPoint > > for std_vec_Vec_dashcore_blockdata_transaction_outpoint_OutPoint { unsafe fn ffi_from_const (ffi : * const std_vec_Vec_dashcore_blockdata_transaction_outpoint_OutPoint) -> std :: vec :: Vec < dashcore :: blockdata :: transaction :: outpoint :: OutPoint > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: outpoint :: OutPoint >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < std :: vec :: Vec < dashcore :: blockdata :: transaction :: outpoint :: OutPoint > > for std_vec_Vec_dashcore_blockdata_transaction_outpoint_OutPoint { unsafe fn ffi_to_const (obj : std :: vec :: Vec < dashcore :: blockdata :: transaction :: outpoint :: OutPoint >) -> * const std_vec_Vec_dashcore_blockdata_transaction_outpoint_OutPoint { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: outpoint :: OutPoint >> :: ffi_to (o)) }) } } impl Drop for std_vec_Vec_dashcore_blockdata_transaction_outpoint_OutPoint { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , dpp :: data_contract :: group :: GroupMemberPower > > for std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower) -> std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , dpp :: data_contract :: group :: GroupMemberPower > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , dpp :: data_contract :: group :: GroupMemberPower > > for std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , dpp :: data_contract :: group :: GroupMemberPower >) -> * const std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower { let (count , keys , values) = ferment :: to_map (obj , | o | < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_any (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 } impl ferment :: FFIConversionFrom < Vec < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 > > for Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { unsafe fn ffi_from_const (ffi : * const Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0) -> Vec < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 as ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 > > for Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { unsafe fn ffi_to_const (obj : Vec < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 >) -> * const Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 as ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 >> :: ffi_to (o)) }) } } impl Drop for Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [cfg (any (all (feature = "state-transitions" feature = "validation") feature = "state-transition-validation" any (feature = "state-transitions")))] # [repr (C)] # [derive (Clone)] # [cfg (any (all (feature = "state-transitions" feature = "validation") feature = "state-transition-validation" any (feature = "state-transitions")))] pub struct std_ops_RangeInclusive_dpp_util_deserializer_ProtocolVersion { pub obj : * mut crate :: fermented :: types :: dpp :: util :: deserializer :: dpp_util_deserializer_ProtocolVersion } # [cfg (any (all (feature = "state-transitions" feature = "validation") feature = "state-transition-validation" any (feature = "state-transitions")))] # [cfg (any (all (feature = "state-transitions" feature = "validation") feature = "state-transition-validation" any (feature = "state-transitions")))] impl ferment :: FFIConversionFrom < std :: ops :: RangeInclusive < dpp :: util :: deserializer :: ProtocolVersion > > for std_ops_RangeInclusive_dpp_util_deserializer_ProtocolVersion { unsafe fn ffi_from_const (ffi : * const std_ops_RangeInclusive_dpp_util_deserializer_ProtocolVersion) -> std :: ops :: RangeInclusive < dpp :: util :: deserializer :: ProtocolVersion > { let ffi_ref = & * ffi ; std :: ops :: RangeInclusive :: new (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . obj)) } } # [cfg (any (all (feature = "state-transitions" feature = "validation") feature = "state-transition-validation" any (feature = "state-transitions")))] # [cfg (any (all (feature = "state-transitions" feature = "validation") feature = "state-transition-validation" any (feature = "state-transitions")))] impl ferment :: FFIConversionTo < std :: ops :: RangeInclusive < dpp :: util :: deserializer :: ProtocolVersion > > for std_ops_RangeInclusive_dpp_util_deserializer_ProtocolVersion { unsafe fn ffi_to_const (obj : std :: ops :: RangeInclusive < dpp :: util :: deserializer :: ProtocolVersion >) -> * const std_ops_RangeInclusive_dpp_util_deserializer_ProtocolVersion { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to ((* obj) . clone ()) }) } } # [cfg (any (all (feature = "state-transitions" feature = "validation") feature = "state-transition-validation" any (feature = "state-transitions")))] # [cfg (any (all (feature = "state-transitions" feature = "validation") feature = "state-transition-validation" any (feature = "state-transitions")))] impl Drop for std_ops_RangeInclusive_dpp_util_deserializer_ProtocolVersion { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexFieldMatch } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch > > for std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch) -> std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexFieldMatch as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch > > for std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch >) -> * const std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch { let (count , keys , values) = ferment :: to_map (obj , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexFieldMatch as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_string (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_dpp_balances_credits_TokenAmount_values_dpp_balances_credits_Credits { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , pub values : * mut * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: balances :: credits :: TokenAmount , dpp :: balances :: credits :: Credits > > for std_collections_Map_keys_dpp_balances_credits_TokenAmount_values_dpp_balances_credits_Credits { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_dpp_balances_credits_TokenAmount_values_dpp_balances_credits_Credits) -> std :: collections :: BTreeMap < dpp :: balances :: credits :: TokenAmount , dpp :: balances :: credits :: Credits > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: balances :: credits :: TokenAmount , dpp :: balances :: credits :: Credits > > for std_collections_Map_keys_dpp_balances_credits_TokenAmount_values_dpp_balances_credits_Credits { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < dpp :: balances :: credits :: TokenAmount , dpp :: balances :: credits :: Credits >) -> * const std_collections_Map_keys_dpp_balances_credits_TokenAmount_values_dpp_balances_credits_Credits { let (count , keys , values) = ferment :: to_map (obj , | o | < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (o) , | o | < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_dpp_balances_credits_TokenAmount_values_dpp_balances_credits_Credits { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_any (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [cfg (any (any (feature = "state-transitions")))] # [repr (C)] # [derive (Clone)] # [cfg (any (any (feature = "state-transitions")))] pub struct Tuple_String_dpp_balances_credits_Credits { pub o_0 : * mut std :: os :: raw :: c_char , pub o_1 : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl ferment :: FFIConversionFrom < (String , dpp :: balances :: credits :: Credits) > for Tuple_String_dpp_balances_credits_Credits { unsafe fn ffi_from_const (ffi : * const Tuple_String_dpp_balances_credits_Credits) -> (String , dpp :: balances :: credits :: Credits) { let ffi_ref = & * ffi ; (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . o_0) , < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . o_1)) } } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl ferment :: FFIConversionTo < (String , dpp :: balances :: credits :: Credits) > for Tuple_String_dpp_balances_credits_Credits { unsafe fn ffi_to_const (obj : (String , dpp :: balances :: credits :: Credits)) -> * const Tuple_String_dpp_balances_credits_Credits { ferment :: boxed (Self { o_0 : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . 0) , o_1 : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . 1) }) } } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl Drop for Tuple_String_dpp_balances_credits_Credits { fn drop (& mut self) { unsafe { ferment :: unbox_string (self . o_0) ; ferment :: unbox_any (self . o_1) ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_localization :: dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization > > for std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization) -> std :: collections :: BTreeMap < String , dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_localization :: dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization as ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization > > for std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < String , dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization >) -> * const std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { let (count , keys , values) = ferment :: to_map (obj , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_localization :: dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization as ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_string (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct Vec_dpp_identity_identity_public_key_purpose_Purpose { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose } impl ferment :: FFIConversionFrom < Vec < dpp :: identity :: identity_public_key :: purpose :: Purpose > > for Vec_dpp_identity_identity_public_key_purpose_Purpose { unsafe fn ffi_from_const (ffi : * const Vec_dpp_identity_identity_public_key_purpose_Purpose) -> Vec < dpp :: identity :: identity_public_key :: purpose :: Purpose > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: purpose :: Purpose >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < dpp :: identity :: identity_public_key :: purpose :: Purpose > > for Vec_dpp_identity_identity_public_key_purpose_Purpose { unsafe fn ffi_to_const (obj : Vec < dpp :: identity :: identity_public_key :: purpose :: Purpose >) -> * const Vec_dpp_identity_identity_public_key_purpose_Purpose { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: purpose :: Purpose >> :: ffi_to (o)) }) } } impl Drop for Vec_dpp_identity_identity_public_key_purpose_Purpose { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct Vec_dpp_document_Document { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document } impl ferment :: FFIConversionFrom < Vec < dpp :: document :: Document > > for Vec_dpp_document_Document { unsafe fn ffi_from_const (ffi : * const Vec_dpp_document_Document) -> Vec < dpp :: document :: Document > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionFrom < dpp :: document :: Document >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < dpp :: document :: Document > > for Vec_dpp_document_Document { unsafe fn ffi_to_const (obj : Vec < dpp :: document :: Document >) -> * const Vec_dpp_document_Document { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionTo < dpp :: document :: Document >> :: ffi_to (o)) }) } } impl Drop for Vec_dpp_document_Document { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { pub count : usize , pub keys : * mut * mut dashcore :: hash_types :: ProTxHash , pub values : * mut * mut crate :: fermented :: types :: dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dashcore :: hash_types :: ProTxHash , dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry > > for std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry) -> std :: collections :: BTreeMap < dashcore :: hash_types :: ProTxHash , dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | std :: ptr :: read (o) , | o | < crate :: fermented :: types :: dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry as ferment :: FFIConversionFrom < dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < dashcore :: hash_types :: ProTxHash , dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry > > for std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < dashcore :: hash_types :: ProTxHash , dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry >) -> * const std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { let (count , keys , values) = ferment :: to_map (obj , | o | ferment :: boxed (o) , | o | < crate :: fermented :: types :: dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry as ferment :: FFIConversionTo < dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_any (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { pub count : usize , pub keys : * mut * mut dashcore :: hash_types :: QuorumHash , pub values : * mut * mut crate :: fermented :: types :: dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > > for std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) -> std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | std :: ptr :: read (o) , | o | < crate :: fermented :: types :: dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry as ferment :: FFIConversionFrom < dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > > for std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry >) -> * const std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { let (count , keys , values) = ferment :: to_map (obj , | o | ferment :: boxed (o) , | o | < crate :: fermented :: types :: dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry as ferment :: FFIConversionTo < dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_any (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType , pub values : * mut * mut crate :: fermented :: generics :: std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dashcore :: sml :: llmq_type :: LLMQType , std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > > > for std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) -> std :: collections :: BTreeMap < dashcore :: sml :: llmq_type :: LLMQType , std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionFrom < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_from (o) , | o | < crate :: fermented :: generics :: std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < dashcore :: sml :: llmq_type :: LLMQType , std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > > > for std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < dashcore :: sml :: llmq_type :: LLMQType , std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > >) -> * const std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { let (count , keys , values) = ferment :: to_map (obj , | o | < crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionTo < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_to (o) , | o | < crate :: fermented :: generics :: std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_any (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } }