# [allow (clippy :: let_and_return , clippy :: suspicious_else_formatting , clippy :: redundant_field_names , dead_code , non_camel_case_types , non_snake_case , non_upper_case_globals , redundant_semicolons , unreachable_patterns , unused_braces , unused_imports , unused_parens , unused_qualifications , unused_unsafe , unused_variables)] pub mod types { pub mod example_entry_point { use crate as example_entry_point ; pub mod entry { use crate as example_entry_point ; pub mod processor { use crate as example_entry_point ; } pub mod core { use crate as example_entry_point ; # [doc = "FFI-representation of the [`example_entry_point::entry::core::DashSharedCore::with_pointers`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_entry_core_DashSharedCore_with_pointers (block_hash_by_height : example_entry_point :: entry :: BlockHashByHeight , model_by_height : example_entry_point :: entry :: ModelByHeight , context : * const std :: os :: raw :: c_void) -> * mut example_entry_point :: entry :: core :: DashSharedCore { let obj = example_entry_point :: entry :: core :: DashSharedCore :: with_pointers (block_hash_by_height , model_by_height , context) ; ferment :: boxed (obj) } # [doc = "FFI-representation of the [`example_entry_point::entry::core::DashSharedCore::with_lambdas`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_entry_core_DashSharedCore_with_lambdas (block_hash_by_height : crate :: fermented :: generics :: Fn_ARGS_u32_RTRN_Arr_u8_32 , model_by_height : crate :: fermented :: generics :: Fn_ARGS_u32_RTRN_example_entry_point_entry_SomeModel , context : * const std :: os :: raw :: c_void) -> * mut example_entry_point :: entry :: core :: DashSharedCore { let obj = example_entry_point :: entry :: core :: DashSharedCore :: with_lambdas (move | o_0 | unsafe { block_hash_by_height . call (o_0) } , move | o_0 | unsafe { model_by_height . call (o_0) } , context) ; ferment :: boxed (obj) } # [doc = "FFI-representation of the [`example_entry_point::entry::core::DashSharedCore::sign_and_publish_state_transition`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_entry_core_DashSharedCore_sign_and_publish_state_transition (runtime : * const std :: os :: raw :: c_void , self_ : * mut example_entry_point :: entry :: core :: DashSharedCore , private_key : * mut crate :: fermented :: generics :: Slice_u8) -> u32 { let rt = & * (runtime as * const tokio :: runtime :: Runtime) ; let obj = rt . block_on (async { example_entry_point :: entry :: core :: DashSharedCore :: sign_and_publish_state_transition (& * self_ , Box :: leak (Box :: new (< crate :: fermented :: generics :: Slice_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (private_key)))) . await }) ; obj } } pub mod provider { use crate as example_entry_point ; } pub mod rnt { use crate as example_entry_point ; # [doc = "FFI-representation of the [`example_entry_point::entry::rnt::DashSharedCoreWithRuntime::with_pointers`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_entry_rnt_DashSharedCoreWithRuntime_with_pointers (block_hash_by_height : example_entry_point :: entry :: BlockHashByHeight , model_by_height : example_entry_point :: entry :: ModelByHeight , runtime : * mut tokio :: runtime :: Runtime , context : * const std :: os :: raw :: c_void) -> * mut example_entry_point :: entry :: rnt :: DashSharedCoreWithRuntime { let obj = example_entry_point :: entry :: rnt :: DashSharedCoreWithRuntime :: with_pointers (block_hash_by_height , model_by_height , runtime , context) ; ferment :: boxed (obj) } # [doc = "FFI-representation of the [`example_entry_point::entry::rnt::DashSharedCoreWithRuntime::with_lambdas`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_entry_rnt_DashSharedCoreWithRuntime_with_lambdas (block_hash_by_height : crate :: fermented :: generics :: Fn_ARGS_u32_RTRN_Arr_u8_32 , model_by_height : crate :: fermented :: generics :: Fn_ARGS_u32_RTRN_example_entry_point_entry_SomeModel , runtime : * mut tokio :: runtime :: Runtime , context : * const std :: os :: raw :: c_void) -> * mut example_entry_point :: entry :: rnt :: DashSharedCoreWithRuntime { let obj = example_entry_point :: entry :: rnt :: DashSharedCoreWithRuntime :: with_lambdas (move | o_0 | unsafe { block_hash_by_height . call (o_0) } , move | o_0 | unsafe { model_by_height . call (o_0) } , runtime , context) ; ferment :: boxed (obj) } } # [doc = "FFI-representation of the [`example_entry_point::entry::PlatformProvider::new`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_entry_PlatformProvider_new (get_quorum_public_key : crate :: fermented :: generics :: Fn_ARGS_example_entry_point_entry_FFIContext_u32_Arr_u8_32_u32_RTRN_Result_ok_u8_arr_48_err_String , get_data_contract : crate :: fermented :: generics :: Fn_ARGS_example_entry_point_entry_FFIContext_String_RTRN_Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String , context : * mut crate :: fermented :: generics :: std_sync_Arc_example_entry_point_entry_FFIContext) -> * mut example_entry_point :: entry :: PlatformProvider { let obj = example_entry_point :: entry :: PlatformProvider :: new (move | o_0 , o_1 , o_2 , o_3 | unsafe { get_quorum_public_key . call (o_0 , o_1 , o_2 , o_3) } , move | o_0 , o_1 | unsafe { get_data_contract . call (o_0 , o_1) } , < crate :: fermented :: generics :: std_sync_Arc_example_entry_point_entry_FFIContext as ferment :: FFIConversionFrom < std :: sync :: Arc < example_entry_point :: entry :: FFIContext > >> :: ffi_from (context)) ; ferment :: boxed (obj) } # [doc = "FFI-representation of the [`example_entry_point::entry::PlatformProvider::maybe_context`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_entry_PlatformProvider_maybe_context (self_ : * mut example_entry_point :: entry :: PlatformProvider) -> * mut example_entry_point :: entry :: FFIContext { let obj = example_entry_point :: entry :: PlatformProvider :: maybe_context (& * self_) ; ferment :: to_opt_primitive (obj) } # [doc = "FFI-representation of the [`example_entry_point::entry::PlatformProvider::maybe_contexts`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_entry_PlatformProvider_maybe_contexts (self_ : * mut example_entry_point :: entry :: PlatformProvider) -> * mut crate :: fermented :: generics :: Vec_example_entry_point_entry_FFIContext { let obj = example_entry_point :: entry :: PlatformProvider :: maybe_contexts (& * self_) ; < crate :: fermented :: generics :: Vec_example_entry_point_entry_FFIContext as ferment :: FFIConversionTo < Vec < example_entry_point :: entry :: FFIContext > >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`SomeModel`]"] # [repr (C)] # [derive (Clone)] pub struct example_entry_point_entry_SomeModel { pub hash : * mut crate :: fermented :: generics :: Arr_u8_32 , pub desc : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < example_entry_point :: entry :: SomeModel > for example_entry_point_entry_SomeModel { unsafe fn ffi_from_const (ffi : * const example_entry_point_entry_SomeModel) -> example_entry_point :: entry :: SomeModel { let ffi_ref = & * ffi ; example_entry_point :: entry :: SomeModel { hash : < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (ffi_ref . hash) , desc : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . desc) } } } impl ferment :: FFIConversionTo < example_entry_point :: entry :: SomeModel > for example_entry_point_entry_SomeModel { unsafe fn ffi_to_const (obj : example_entry_point :: entry :: SomeModel) -> * const example_entry_point_entry_SomeModel { ferment :: boxed (example_entry_point_entry_SomeModel { hash : < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (obj . hash) , desc : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . desc) }) } } impl Drop for example_entry_point_entry_SomeModel { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . hash) ; ferment :: unbox_string (ffi_ref . desc) ; } } } # [no_mangle] pub unsafe extern "C" fn example_entry_point_entry_SomeModel_ctor < > (hash : * mut crate :: fermented :: generics :: Arr_u8_32 , desc : * mut std :: os :: raw :: c_char) -> * mut example_entry_point_entry_SomeModel { ferment :: boxed (example_entry_point_entry_SomeModel { hash , desc }) } # [no_mangle] pub unsafe extern "C" fn example_entry_point_entry_SomeModel_destroy < > (ffi : * mut example_entry_point_entry_SomeModel) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_entry_point_entry_SomeModel_get_hash < > (obj : * const example_entry_point_entry_SomeModel) -> * mut crate :: fermented :: generics :: Arr_u8_32 { (* obj) . hash } # [no_mangle] pub unsafe extern "C" fn example_entry_point_entry_SomeModel_get_desc < > (obj : * const example_entry_point_entry_SomeModel) -> * mut std :: os :: raw :: c_char { (* obj) . desc } # [no_mangle] pub unsafe extern "C" fn example_entry_point_entry_SomeModel_set_hash < > (obj : * const example_entry_point_entry_SomeModel) -> * mut crate :: fermented :: generics :: Arr_u8_32 { (* obj) . hash } # [no_mangle] pub unsafe extern "C" fn example_entry_point_entry_SomeModel_set_desc < > (obj : * const example_entry_point_entry_SomeModel) -> * mut std :: os :: raw :: c_char { (* obj) . desc } } pub mod wallet_provider { use crate as example_entry_point ; # [doc = "FFI-representation of the [`TestWalletProvider`]"] # [repr (C)] # [derive (Clone)] pub struct example_entry_point_wallet_provider_TestWalletProvider { } impl ferment :: FFIConversionFrom < example_entry_point :: wallet_provider :: TestWalletProvider > for example_entry_point_wallet_provider_TestWalletProvider { unsafe fn ffi_from_const (ffi : * const example_entry_point_wallet_provider_TestWalletProvider) -> example_entry_point :: wallet_provider :: TestWalletProvider { let ffi_ref = & * ffi ; example_entry_point :: wallet_provider :: TestWalletProvider { } } } impl ferment :: FFIConversionTo < example_entry_point :: wallet_provider :: TestWalletProvider > for example_entry_point_wallet_provider_TestWalletProvider { unsafe fn ffi_to_const (obj : example_entry_point :: wallet_provider :: TestWalletProvider) -> * const example_entry_point_wallet_provider_TestWalletProvider { ferment :: boxed (example_entry_point_wallet_provider_TestWalletProvider { }) } } impl Drop for example_entry_point_wallet_provider_TestWalletProvider { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn example_entry_point_wallet_provider_TestWalletProvider_ctor < > () -> * mut example_entry_point_wallet_provider_TestWalletProvider { ferment :: boxed (example_entry_point_wallet_provider_TestWalletProvider { }) } # [no_mangle] pub unsafe extern "C" fn example_entry_point_wallet_provider_TestWalletProvider_destroy < > (ffi : * mut example_entry_point_wallet_provider_TestWalletProvider) { ferment :: unbox_any (ffi) ; } } pub mod keychain { use crate as example_entry_point ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`KeyChainError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_entry_point_keychain_KeyChainError { OsStatusCode (i32) } impl ferment :: FFIConversionFrom < example_entry_point :: keychain :: KeyChainError > for example_entry_point_keychain_KeyChainError { unsafe fn ffi_from_const (ffi : * const example_entry_point_keychain_KeyChainError) -> example_entry_point :: keychain :: KeyChainError { let ffi_ref = & * ffi ; match ffi_ref { example_entry_point_keychain_KeyChainError :: OsStatusCode (o_0) => example_entry_point :: keychain :: KeyChainError :: OsStatusCode (* o_0) } } } impl ferment :: FFIConversionTo < example_entry_point :: keychain :: KeyChainError > for example_entry_point_keychain_KeyChainError { unsafe fn ffi_to_const (obj : example_entry_point :: keychain :: KeyChainError) -> * const example_entry_point_keychain_KeyChainError { ferment :: boxed (match obj { example_entry_point :: keychain :: KeyChainError :: OsStatusCode (o_0) => example_entry_point_keychain_KeyChainError :: OsStatusCode (o_0) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_entry_point_keychain_KeyChainError { fn drop (& mut self) { unsafe { match self { example_entry_point_keychain_KeyChainError :: OsStatusCode (o_0) => { ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeyChainError_OsStatusCode_ctor (o_o_0 : i32) -> * mut example_entry_point_keychain_KeyChainError { ferment :: boxed (example_entry_point_keychain_KeyChainError :: OsStatusCode (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeyChainError_destroy < > (ffi : * mut example_entry_point_keychain_KeyChainError) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`KeyChainValue`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_entry_point_keychain_KeyChainValue { Bytes (* mut crate :: fermented :: generics :: Vec_u8) , Int64 (i64) , String (* mut std :: os :: raw :: c_char) } impl ferment :: FFIConversionFrom < example_entry_point :: keychain :: KeyChainValue > for example_entry_point_keychain_KeyChainValue { unsafe fn ffi_from_const (ffi : * const example_entry_point_keychain_KeyChainValue) -> example_entry_point :: keychain :: KeyChainValue { let ffi_ref = & * ffi ; match ffi_ref { example_entry_point_keychain_KeyChainValue :: Bytes (o_0) => example_entry_point :: keychain :: KeyChainValue :: Bytes (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (* o_0)) , example_entry_point_keychain_KeyChainValue :: Int64 (o_0) => example_entry_point :: keychain :: KeyChainValue :: Int64 (* o_0) , example_entry_point_keychain_KeyChainValue :: String (o_0) => example_entry_point :: keychain :: KeyChainValue :: String (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < example_entry_point :: keychain :: KeyChainValue > for example_entry_point_keychain_KeyChainValue { unsafe fn ffi_to_const (obj : example_entry_point :: keychain :: KeyChainValue) -> * const example_entry_point_keychain_KeyChainValue { ferment :: boxed (match obj { example_entry_point :: keychain :: KeyChainValue :: Bytes (o_0) => example_entry_point_keychain_KeyChainValue :: Bytes (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (o_0)) , example_entry_point :: keychain :: KeyChainValue :: Int64 (o_0) => example_entry_point_keychain_KeyChainValue :: Int64 (o_0) , example_entry_point :: keychain :: KeyChainValue :: String (o_0) => example_entry_point_keychain_KeyChainValue :: String (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_entry_point_keychain_KeyChainValue { fn drop (& mut self) { unsafe { match self { example_entry_point_keychain_KeyChainValue :: Bytes (o_0) => { ferment :: unbox_any (* o_0) ; } , example_entry_point_keychain_KeyChainValue :: Int64 (o_0) => { ; } , example_entry_point_keychain_KeyChainValue :: String (o_0) => { ferment :: unbox_string (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeyChainValue_Bytes_ctor (o_o_0 : * mut crate :: fermented :: generics :: Vec_u8) -> * mut example_entry_point_keychain_KeyChainValue { ferment :: boxed (example_entry_point_keychain_KeyChainValue :: Bytes (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeyChainValue_Int64_ctor (o_o_0 : i64) -> * mut example_entry_point_keychain_KeyChainValue { ferment :: boxed (example_entry_point_keychain_KeyChainValue :: Int64 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeyChainValue_String_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut example_entry_point_keychain_KeyChainValue { ferment :: boxed (example_entry_point_keychain_KeyChainValue :: String (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeyChainValue_destroy < > (ffi : * mut example_entry_point_keychain_KeyChainValue) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`example_entry_point::keychain::KeychainController::new`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeychainController_new (get : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError , set : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_example_entry_point_keychain_KeyChainValue_bool_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError , has : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError , delete : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError) -> * mut example_entry_point :: keychain :: KeychainController { let obj = example_entry_point :: keychain :: KeychainController :: new (move | o_0 , o_1 | unsafe { get . call (o_0 , o_1) } , move | o_0 , o_1 , o_2 , o_3 | unsafe { set . call (o_0 , o_1 , o_2 , o_3) } , move | o_0 , o_1 | unsafe { has . call (o_0 , o_1) } , move | o_0 , o_1 | unsafe { delete . call (o_0 , o_1) }) ; ferment :: boxed (obj) } # [doc = "FFI-representation of the [`example_entry_point::keychain::KeychainController::get`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeychainController_get (self_ : * mut example_entry_point :: keychain :: KeychainController , key : * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey) -> * mut crate :: fermented :: generics :: Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError { let obj = example_entry_point :: keychain :: KeychainController :: get (& * self_ , < crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey as ferment :: FFIConversionFrom < example_entry_point :: keychain :: KeyChainKey >> :: ffi_from (key)) ; < crate :: fermented :: generics :: Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError as ferment :: FFIConversionTo < Result < example_entry_point :: keychain :: KeyChainValue , example_entry_point :: keychain :: KeyChainError > >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_entry_point::keychain::KeychainController::set`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeychainController_set (self_ : * mut example_entry_point :: keychain :: KeychainController , key : * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey , value : * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainValue , authenticated : bool) -> * mut crate :: fermented :: generics :: Result_ok_bool_err_example_entry_point_keychain_KeyChainError { let obj = example_entry_point :: keychain :: KeychainController :: set (& * self_ , < crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey as ferment :: FFIConversionFrom < example_entry_point :: keychain :: KeyChainKey >> :: ffi_from (key) , < crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainValue as ferment :: FFIConversionFrom < example_entry_point :: keychain :: KeyChainValue >> :: ffi_from (value) , authenticated) ; < crate :: fermented :: generics :: Result_ok_bool_err_example_entry_point_keychain_KeyChainError as ferment :: FFIConversionTo < Result < bool , example_entry_point :: keychain :: KeyChainError > >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_entry_point::keychain::KeychainController::has`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeychainController_has (self_ : * mut example_entry_point :: keychain :: KeychainController , key : * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey) -> * mut crate :: fermented :: generics :: Result_ok_bool_err_example_entry_point_keychain_KeyChainError { let obj = example_entry_point :: keychain :: KeychainController :: has (& * self_ , < crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey as ferment :: FFIConversionFrom < example_entry_point :: keychain :: KeyChainKey >> :: ffi_from (key)) ; < crate :: fermented :: generics :: Result_ok_bool_err_example_entry_point_keychain_KeyChainError as ferment :: FFIConversionTo < Result < bool , example_entry_point :: keychain :: KeyChainError > >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_entry_point::keychain::KeychainController::delete`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeychainController_delete (self_ : * mut example_entry_point :: keychain :: KeychainController , key : * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey) -> * mut crate :: fermented :: generics :: Result_ok_bool_err_example_entry_point_keychain_KeyChainError { let obj = example_entry_point :: keychain :: KeychainController :: delete (& * self_ , < crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey as ferment :: FFIConversionFrom < example_entry_point :: keychain :: KeyChainKey >> :: ffi_from (key)) ; < crate :: fermented :: generics :: Result_ok_bool_err_example_entry_point_keychain_KeyChainError as ferment :: FFIConversionTo < Result < bool , example_entry_point :: keychain :: KeyChainError > >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_entry_point::keychain::KeychainController::mark_already_joined_queue_as_tried`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeychainController_mark_already_joined_queue_as_tried (self_ : * mut example_entry_point :: keychain :: KeychainController , _dsq : * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey) -> bool { let obj = example_entry_point :: keychain :: KeychainController :: mark_already_joined_queue_as_tried (& mut * self_ , Box :: leak (Box :: new (< crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey as ferment :: FFIConversionFrom < example_entry_point :: keychain :: KeyChainKey >> :: ffi_from (_dsq)))) ; obj } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`KeyChainKey`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_entry_point_keychain_KeyChainKey { StandaloneInfoDictionaryLocationString { extended_public_key_identifier : * mut std :: os :: raw :: c_char } , StandaloneExtendedPublicKeyLocationString { extended_public_key_identifier : * mut std :: os :: raw :: c_char } , HasKnownBalanceUniqueIDString { reference : u32 , unique_id : * mut std :: os :: raw :: c_char } , WalletBasedExtendedPrivateKeyLocationString { unique_id : * mut std :: os :: raw :: c_char } , WalletBasedExtendedPublicKeyLocationString { unique_id : * mut std :: os :: raw :: c_char } } impl ferment :: FFIConversionFrom < example_entry_point :: keychain :: KeyChainKey > for example_entry_point_keychain_KeyChainKey { unsafe fn ffi_from_const (ffi : * const example_entry_point_keychain_KeyChainKey) -> example_entry_point :: keychain :: KeyChainKey { let ffi_ref = & * ffi ; match ffi_ref { example_entry_point_keychain_KeyChainKey :: StandaloneInfoDictionaryLocationString { extended_public_key_identifier } => example_entry_point :: keychain :: KeyChainKey :: StandaloneInfoDictionaryLocationString { extended_public_key_identifier : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* extended_public_key_identifier) } , example_entry_point_keychain_KeyChainKey :: StandaloneExtendedPublicKeyLocationString { extended_public_key_identifier } => example_entry_point :: keychain :: KeyChainKey :: StandaloneExtendedPublicKeyLocationString { extended_public_key_identifier : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* extended_public_key_identifier) } , example_entry_point_keychain_KeyChainKey :: HasKnownBalanceUniqueIDString { reference , unique_id } => example_entry_point :: keychain :: KeyChainKey :: HasKnownBalanceUniqueIDString { reference : * reference , unique_id : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* unique_id) } , example_entry_point_keychain_KeyChainKey :: WalletBasedExtendedPrivateKeyLocationString { unique_id } => example_entry_point :: keychain :: KeyChainKey :: WalletBasedExtendedPrivateKeyLocationString { unique_id : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* unique_id) } , example_entry_point_keychain_KeyChainKey :: WalletBasedExtendedPublicKeyLocationString { unique_id } => example_entry_point :: keychain :: KeyChainKey :: WalletBasedExtendedPublicKeyLocationString { unique_id : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* unique_id) } } } } impl ferment :: FFIConversionTo < example_entry_point :: keychain :: KeyChainKey > for example_entry_point_keychain_KeyChainKey { unsafe fn ffi_to_const (obj : example_entry_point :: keychain :: KeyChainKey) -> * const example_entry_point_keychain_KeyChainKey { ferment :: boxed (match obj { example_entry_point :: keychain :: KeyChainKey :: StandaloneInfoDictionaryLocationString { extended_public_key_identifier } => example_entry_point_keychain_KeyChainKey :: StandaloneInfoDictionaryLocationString { extended_public_key_identifier : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (extended_public_key_identifier) } , example_entry_point :: keychain :: KeyChainKey :: StandaloneExtendedPublicKeyLocationString { extended_public_key_identifier } => example_entry_point_keychain_KeyChainKey :: StandaloneExtendedPublicKeyLocationString { extended_public_key_identifier : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (extended_public_key_identifier) } , example_entry_point :: keychain :: KeyChainKey :: HasKnownBalanceUniqueIDString { reference , unique_id } => example_entry_point_keychain_KeyChainKey :: HasKnownBalanceUniqueIDString { reference : reference , unique_id : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (unique_id) } , example_entry_point :: keychain :: KeyChainKey :: WalletBasedExtendedPrivateKeyLocationString { unique_id } => example_entry_point_keychain_KeyChainKey :: WalletBasedExtendedPrivateKeyLocationString { unique_id : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (unique_id) } , example_entry_point :: keychain :: KeyChainKey :: WalletBasedExtendedPublicKeyLocationString { unique_id } => example_entry_point_keychain_KeyChainKey :: WalletBasedExtendedPublicKeyLocationString { unique_id : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (unique_id) } , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_entry_point_keychain_KeyChainKey { fn drop (& mut self) { unsafe { match self { example_entry_point_keychain_KeyChainKey :: StandaloneInfoDictionaryLocationString { extended_public_key_identifier } => { ferment :: unbox_string (* extended_public_key_identifier) ; } , example_entry_point_keychain_KeyChainKey :: StandaloneExtendedPublicKeyLocationString { extended_public_key_identifier } => { ferment :: unbox_string (* extended_public_key_identifier) ; } , example_entry_point_keychain_KeyChainKey :: HasKnownBalanceUniqueIDString { reference , unique_id } => { ; ; ferment :: unbox_string (* unique_id) ; } , example_entry_point_keychain_KeyChainKey :: WalletBasedExtendedPrivateKeyLocationString { unique_id } => { ferment :: unbox_string (* unique_id) ; } , example_entry_point_keychain_KeyChainKey :: WalletBasedExtendedPublicKeyLocationString { unique_id } => { ferment :: unbox_string (* unique_id) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeyChainKey_StandaloneInfoDictionaryLocationString_ctor (extended_public_key_identifier : * mut std :: os :: raw :: c_char) -> * mut example_entry_point_keychain_KeyChainKey { ferment :: boxed (example_entry_point_keychain_KeyChainKey :: StandaloneInfoDictionaryLocationString { extended_public_key_identifier }) } # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeyChainKey_StandaloneExtendedPublicKeyLocationString_ctor (extended_public_key_identifier : * mut std :: os :: raw :: c_char) -> * mut example_entry_point_keychain_KeyChainKey { ferment :: boxed (example_entry_point_keychain_KeyChainKey :: StandaloneExtendedPublicKeyLocationString { extended_public_key_identifier }) } # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeyChainKey_HasKnownBalanceUniqueIDString_ctor (reference : u32 , unique_id : * mut std :: os :: raw :: c_char) -> * mut example_entry_point_keychain_KeyChainKey { ferment :: boxed (example_entry_point_keychain_KeyChainKey :: HasKnownBalanceUniqueIDString { reference , unique_id }) } # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeyChainKey_WalletBasedExtendedPrivateKeyLocationString_ctor (unique_id : * mut std :: os :: raw :: c_char) -> * mut example_entry_point_keychain_KeyChainKey { ferment :: boxed (example_entry_point_keychain_KeyChainKey :: WalletBasedExtendedPrivateKeyLocationString { unique_id }) } # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeyChainKey_WalletBasedExtendedPublicKeyLocationString_ctor (unique_id : * mut std :: os :: raw :: c_char) -> * mut example_entry_point_keychain_KeyChainKey { ferment :: boxed (example_entry_point_keychain_KeyChainKey :: WalletBasedExtendedPublicKeyLocationString { unique_id }) } # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeyChainKey_destroy < > (ffi : * mut example_entry_point_keychain_KeyChainKey) { ferment :: unbox_any (ffi) ; } } pub mod custom { use crate as example_entry_point ; } pub mod provider { use crate as example_entry_point ; pub mod wallet_ex { use crate as example_entry_point ; # [doc = "FFI-representation of the [`example_entry_point::provider::wallet_ex::WalletEx2::new`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_provider_wallet_ex_WalletEx2_new (context : * const std :: os :: raw :: c_void , options : * mut crate :: fermented :: generics :: std_rc_Rc_std_cell_RefCell_u8_32 , sign_transaction : crate :: fermented :: generics :: Fn_ARGS_example_entry_point_provider_wallet_ex_WalletEx2_Arr_u8_32_bool_RTRN_Option_u8_32 , is_mine_input : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool , available_coins : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_provider_wallet_ex_WalletEx2_RTRN_Vec_u8_32) -> * mut example_entry_point :: provider :: wallet_ex :: WalletEx2 { let obj = example_entry_point :: provider :: wallet_ex :: WalletEx2 :: new (context , < crate :: fermented :: generics :: std_rc_Rc_std_cell_RefCell_u8_32 as ferment :: FFIConversionFrom < std :: rc :: Rc < std :: cell :: RefCell < [u8 ; 32] > > >> :: ffi_from (options) , move | o_0 , o_1 , o_2 | unsafe { sign_transaction . call (o_0 , o_1 , o_2) } , move | o_0 , o_1 | unsafe { is_mine_input . call (o_0 , o_1) } , move | o_0 , o_1 , o_2 , o_3 | unsafe { available_coins . call (o_0 , o_1 , o_2 , o_3) }) ; ferment :: boxed (obj) } # [doc = "FFI-representation of the [`example_entry_point::provider::wallet_ex::WalletEx2::lock_coin`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_provider_wallet_ex_WalletEx2_lock_coin (self_ : * mut example_entry_point :: provider :: wallet_ex :: WalletEx2 , outpoint : * mut crate :: fermented :: generics :: Arr_u8_32) { let obj = example_entry_point :: provider :: wallet_ex :: WalletEx2 :: lock_coin (& mut * self_ , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (outpoint)) ; ; } # [doc = "FFI-representation of the [`example_entry_point::provider::wallet_ex::WalletEx2::unlock_coin`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_provider_wallet_ex_WalletEx2_unlock_coin (self_ : * mut example_entry_point :: provider :: wallet_ex :: WalletEx2 , outpoint : * mut crate :: fermented :: generics :: Arr_u8_32) { let obj = example_entry_point :: provider :: wallet_ex :: WalletEx2 :: unlock_coin (& mut * self_ , Box :: leak (Box :: new (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (outpoint)))) ; ; } # [doc = "FFI-representation of the [`example_entry_point::provider::wallet_ex::WalletEx2::is_locked_coin`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_provider_wallet_ex_WalletEx2_is_locked_coin (self_ : * mut example_entry_point :: provider :: wallet_ex :: WalletEx2 , outpoint : * mut crate :: fermented :: generics :: Arr_u8_32) -> bool { let obj = example_entry_point :: provider :: wallet_ex :: WalletEx2 :: is_locked_coin (& * self_ , Box :: leak (Box :: new (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (outpoint)))) ; obj } # [doc = "FFI-representation of the [`example_entry_point::provider::wallet_ex::WalletEx2::is_fully_mixed`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_provider_wallet_ex_WalletEx2_is_fully_mixed (self_ : * mut example_entry_point :: provider :: wallet_ex :: WalletEx2 , outpoint : * mut crate :: fermented :: generics :: Arr_u8_32) -> bool { let obj = example_entry_point :: provider :: wallet_ex :: WalletEx2 :: is_fully_mixed (& mut * self_ , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (outpoint)) ; obj } # [doc = "FFI-representation of the [`example_entry_point::provider::wallet_ex::WalletEx2::get_real_outpoint_coinjoin_rounds`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_provider_wallet_ex_WalletEx2_get_real_outpoint_coinjoin_rounds (self_ : * mut example_entry_point :: provider :: wallet_ex :: WalletEx2 , outpoint : * mut crate :: fermented :: generics :: Arr_u8_32 , rounds : i32) -> i32 { let obj = example_entry_point :: provider :: wallet_ex :: WalletEx2 :: get_real_outpoint_coinjoin_rounds (& mut * self_ , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (outpoint) , rounds) ; obj } # [doc = "FFI-representation of the [`example_entry_point::provider::wallet_ex::WalletEx2::ssssocke`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_provider_wallet_ex_WalletEx2_ssssocke (self_ : * mut example_entry_point :: provider :: wallet_ex :: WalletEx2 , addr : * mut example_entry_point :: custom :: std :: SocketAddr) -> i32 { let obj = example_entry_point :: provider :: wallet_ex :: WalletEx2 :: ssssocke (& mut * self_ , < example_entry_point :: custom :: std :: SocketAddr as ferment :: FFIConversionFrom < std :: net :: SocketAddr >> :: ffi_from (addr)) ; obj } # [doc = "FFI-representation of the [`example_entry_point::provider::wallet_ex::WalletEx2::has_collateral_inputs`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_provider_wallet_ex_WalletEx2_has_collateral_inputs (self_ : * mut example_entry_point :: provider :: wallet_ex :: WalletEx2 , only_confirmed : bool) -> bool { let obj = example_entry_point :: provider :: wallet_ex :: WalletEx2 :: has_collateral_inputs (& * self_ , only_confirmed) ; obj } # [doc = "FFI-representation of the [`example_entry_point::provider::wallet_ex::WalletEx2::select_coins_grouped_by_addresses`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_provider_wallet_ex_WalletEx2_select_coins_grouped_by_addresses (self_ : * mut example_entry_point :: provider :: wallet_ex :: WalletEx2 , skip_denominated : bool , anonymizable : bool , skip_unconfirmed : bool , max_outpoints_per_address : i32) -> * mut crate :: fermented :: generics :: Vec_u8_32 { let obj = example_entry_point :: provider :: wallet_ex :: WalletEx2 :: select_coins_grouped_by_addresses (& mut * self_ , skip_denominated , anonymizable , skip_unconfirmed , max_outpoints_per_address) ; < crate :: fermented :: generics :: Vec_u8_32 as ferment :: FFIConversionTo < Vec < [u8 ; 32] > >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_entry_point::provider::wallet_ex::WalletEx2::get_anonymizable_balance`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_provider_wallet_ex_WalletEx2_get_anonymizable_balance (self_ : * mut example_entry_point :: provider :: wallet_ex :: WalletEx2 , skip_denominated : bool , skip_unconfirmed : bool) -> u64 { let obj = example_entry_point :: provider :: wallet_ex :: WalletEx2 :: get_anonymizable_balance (& mut * self_ , skip_denominated , skip_unconfirmed) ; obj } # [doc = "FFI-representation of the [`example_entry_point::provider::wallet_ex::WalletEx2::get_unused_key`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_provider_wallet_ex_WalletEx2_get_unused_key (self_ : * mut example_entry_point :: provider :: wallet_ex :: WalletEx2 , internal : bool) -> * mut crate :: fermented :: generics :: Arr_u8_32 { let obj = example_entry_point :: provider :: wallet_ex :: WalletEx2 :: get_unused_key (& mut * self_ , internal) ; < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to_opt (obj) } # [doc = "FFI-representation of the [`example_entry_point::provider::wallet_ex::WalletEx2::add_unused_key`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_provider_wallet_ex_WalletEx2_add_unused_key (self_ : * mut example_entry_point :: provider :: wallet_ex :: WalletEx2 , destination : * mut crate :: fermented :: generics :: Vec_u8) { let obj = example_entry_point :: provider :: wallet_ex :: WalletEx2 :: add_unused_key (& mut * self_ , < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (destination)) ; ; } # [doc = "FFI-representation of the [`example_entry_point::provider::wallet_ex::WalletEx2::remove_unused_key`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_provider_wallet_ex_WalletEx2_remove_unused_key (self_ : * mut example_entry_point :: provider :: wallet_ex :: WalletEx2 , destination : * mut crate :: fermented :: generics :: Arr_u8_32) { let obj = example_entry_point :: provider :: wallet_ex :: WalletEx2 :: remove_unused_key (& mut * self_ , Box :: leak (Box :: new (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (destination)))) ; ; } # [doc = "FFI-representation of the [`example_entry_point::provider::wallet_ex::WalletEx2::refresh_unused_keys`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_provider_wallet_ex_WalletEx2_refresh_unused_keys (self_ : * mut example_entry_point :: provider :: wallet_ex :: WalletEx2) { let obj = example_entry_point :: provider :: wallet_ex :: WalletEx2 :: refresh_unused_keys (& mut * self_) ; ; } # [doc = "FFI-representation of the [`example_entry_point::provider::wallet_ex::WalletEx2::process_used_scripts`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_provider_wallet_ex_WalletEx2_process_used_scripts (self_ : * mut example_entry_point :: provider :: wallet_ex :: WalletEx2 , scripts : * mut crate :: fermented :: generics :: Vec_Vec_u8) { let obj = example_entry_point :: provider :: wallet_ex :: WalletEx2 :: process_used_scripts (& mut * self_ , Box :: leak (Box :: new (< crate :: fermented :: generics :: Vec_Vec_u8 as ferment :: FFIConversionFrom < Vec < Vec < u8 > > >> :: ffi_from (scripts)))) ; ; } # [doc = "FFI-representation of the [`example_entry_point::provider::wallet_ex::WalletEx2::sign_transaction`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_provider_wallet_ex_WalletEx2_sign_transaction (self_ : * mut example_entry_point :: provider :: wallet_ex :: WalletEx2 , tx : * mut crate :: fermented :: generics :: Arr_u8_32 , anyone_can_pay : bool) -> * mut crate :: fermented :: generics :: Arr_u8_32 { let obj = example_entry_point :: provider :: wallet_ex :: WalletEx2 :: sign_transaction (& * self_ , Box :: leak (Box :: new (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (tx))) , anyone_can_pay) ; < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to_opt (obj) } # [doc = "FFI-representation of the [`example_entry_point::provider::wallet_ex::WalletEx2::select_tx_dsins_by_denomination`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_provider_wallet_ex_WalletEx2_select_tx_dsins_by_denomination (self_ : * mut example_entry_point :: provider :: wallet_ex :: WalletEx2 , denom : u32 , value_max : u64 , vec_tx_dsin_ret : * mut crate :: fermented :: generics :: Vec_u8_32) -> bool { let obj = example_entry_point :: provider :: wallet_ex :: WalletEx2 :: select_tx_dsins_by_denomination (& mut * self_ , denom , value_max , Box :: leak (Box :: new (< crate :: fermented :: generics :: Vec_u8_32 as ferment :: FFIConversionFrom < Vec < [u8 ; 32] > >> :: ffi_from (vec_tx_dsin_ret)))) ; obj } # [doc = "FFI-representation of the [`example_entry_point::provider::wallet_ex::WalletEx2::select_denominated_amounts`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_provider_wallet_ex_WalletEx2_select_denominated_amounts (self_ : * mut example_entry_point :: provider :: wallet_ex :: WalletEx2 , value_max : u64 , set_amounts_ret : * mut crate :: fermented :: generics :: std_collections_HashSet_u64) -> bool { let obj = example_entry_point :: provider :: wallet_ex :: WalletEx2 :: select_denominated_amounts (& * self_ , value_max , Box :: leak (Box :: new (< crate :: fermented :: generics :: std_collections_HashSet_u64 as ferment :: FFIConversionFrom < std :: collections :: HashSet < u64 > >> :: ffi_from (set_amounts_ret)))) ; obj } # [doc = "FFI-representation of the [`example_entry_point::provider::wallet_ex::WalletEx2::clear_anonymizable_caches`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_provider_wallet_ex_WalletEx2_clear_anonymizable_caches (self_ : * mut example_entry_point :: provider :: wallet_ex :: WalletEx2) { let obj = example_entry_point :: provider :: wallet_ex :: WalletEx2 :: clear_anonymizable_caches (& mut * self_) ; ; } # [doc = "FFI-representation of the [`example_entry_point::provider::wallet_ex::WalletEx2::fresh_receive_key`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_provider_wallet_ex_WalletEx2_fresh_receive_key (self_ : * mut example_entry_point :: provider :: wallet_ex :: WalletEx2 , internal : bool) -> * mut crate :: fermented :: generics :: Vec_u8 { let obj = example_entry_point :: provider :: wallet_ex :: WalletEx2 :: fresh_receive_key (& mut * self_ , internal) ; < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj) } } pub mod wallet_provider { use crate as example_entry_point ; # [doc = "FFI-representation of the [`example_entry_point::provider::wallet_provider::WalletProvider2::new`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_provider_wallet_provider_WalletProvider2_new (sign_transaction : crate :: fermented :: generics :: Fn_ARGS_example_entry_point_provider_wallet_ex_WalletEx2_Arr_u8_32_bool_RTRN_Option_u8_32 , is_mine_input : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool , available_coins : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_provider_wallet_ex_WalletEx2_RTRN_Vec_u8_32 , context : * const std :: os :: raw :: c_void) -> * mut example_entry_point :: provider :: wallet_provider :: WalletProvider2 { let obj = example_entry_point :: provider :: wallet_provider :: WalletProvider2 :: new (move | o_0 , o_1 , o_2 | unsafe { sign_transaction . call (o_0 , o_1 , o_2) } , move | o_0 , o_1 | unsafe { is_mine_input . call (o_0 , o_1) } , move | o_0 , o_1 , o_2 , o_3 | unsafe { available_coins . call (o_0 , o_1 , o_2 , o_3) } , context) ; ferment :: boxed (obj) } } pub mod provider { use crate as example_entry_point ; # [doc = "FFI-representation of the [`example_entry_point::provider::provider::CoinJoinProvider::new`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_provider_provider_CoinJoinProvider_new (get_masternode_list : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_RTRN_Arr_u8_32 , update_success_block : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_RTRN_ , is_waiting_for_new_block : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_RTRN_bool , session_lifecycle_listener : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_Option_std_net_SocketAddr_bool_RTRN_ , session_lifecycle_listener2 : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_std_net_SocketAddr_bool_RTRN_ , mixing_lifecycle_listener : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_bool_bool_Vec_u8_32_RTRN_ , context : * const std :: os :: raw :: c_void) -> * mut example_entry_point :: provider :: provider :: CoinJoinProvider { let obj = example_entry_point :: provider :: provider :: CoinJoinProvider :: new (move | o_0 | unsafe { get_masternode_list . call (o_0) } , move | o_0 | unsafe { update_success_block . call (o_0) } , move | o_0 | unsafe { is_waiting_for_new_block . call (o_0) } , move | o_0 , o_1 , o_2 , o_3 , o_4 , o_5 , o_6 , o_7 , o_8 , o_9 | unsafe { session_lifecycle_listener . call (o_0 , o_1 , o_2 , o_3 , o_4 , o_5 , o_6 , o_7 , o_8 , o_9) } , move | o_0 , o_1 , o_2 , o_3 , o_4 , o_5 , o_6 , o_7 , o_8 , o_9 | unsafe { session_lifecycle_listener2 . call (o_0 , o_1 , o_2 , o_3 , o_4 , o_5 , o_6 , o_7 , o_8 , o_9) } , move | o_0 , o_1 , o_2 , o_3 | unsafe { mixing_lifecycle_listener . call (o_0 , o_1 , o_2 , o_3) } , context) ; ferment :: boxed (obj) } # [doc = "FFI-representation of the [`example_entry_point::provider::provider::CoinJoinProvider::load_smth_opaque`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_provider_provider_CoinJoinProvider_load_smth_opaque (runtime : * const std :: os :: raw :: c_void , self_ : * mut example_entry_point :: provider :: provider :: CoinJoinProvider , context : * mut example_entry_point :: entry :: FFIContext) -> * mut crate :: fermented :: generics :: Result_ok_bool_err_String { let rt = & * (runtime as * const tokio :: runtime :: Runtime) ; let obj = rt . block_on (async { example_entry_point :: provider :: provider :: CoinJoinProvider :: load_smth_opaque (& * self_ , & mut * context) . await }) ; < crate :: fermented :: generics :: Result_ok_bool_err_String as ferment :: FFIConversionTo < Result < bool , String > >> :: ffi_to (obj) } } } } } # [allow (clippy :: let_and_return , clippy :: suspicious_else_formatting , clippy :: redundant_field_names , dead_code , non_camel_case_types , non_snake_case , non_upper_case_globals , redundant_semicolons , unreachable_patterns , unused_braces , unused_imports , unused_parens , unused_qualifications , unused_unsafe , unused_variables)] pub mod generics { use crate as example_entry_point ; # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_example_entry_point_entry_FFIContext_u32_Arr_u8_32_u32_RTRN_Result_ok_u8_arr_48_err_String { caller : unsafe extern "C" fn (* const example_entry_point :: entry :: FFIContext , u32 , * mut crate :: fermented :: generics :: Arr_u8_32 , u32) -> * mut crate :: fermented :: generics :: Result_ok_u8_arr_48_err_String , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Result_ok_u8_arr_48_err_String) } impl Fn_ARGS_example_entry_point_entry_FFIContext_u32_Arr_u8_32_u32_RTRN_Result_ok_u8_arr_48_err_String { pub unsafe fn call (& self , o_0 : * const example_entry_point :: entry :: FFIContext , o_1 : u32 , o_2 : [u8 ; 32] , o_3 : u32) -> Result < [u8 ; 48] , String > { let ffi_result = (self . caller) (o_0 , o_1 , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_2) , o_3) ; let result = < crate :: fermented :: generics :: Result_ok_u8_arr_48_err_String as ferment :: FFIConversionFrom < Result < [u8 ; 48] , String > >> :: ffi_from (ffi_result) ; (self . destructor) (ffi_result) ; result } } unsafe impl Send for Fn_ARGS_example_entry_point_entry_FFIContext_u32_Arr_u8_32_u32_RTRN_Result_ok_u8_arr_48_err_String { } unsafe impl Sync for Fn_ARGS_example_entry_point_entry_FFIContext_u32_Arr_u8_32_u32_RTRN_Result_ok_u8_arr_48_err_String { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_example_entry_point_entry_FFIContext_u32_Arr_u8_32_u32_RTRN_Result_ok_u8_arr_48_err_String_ctor (caller : unsafe extern "C" fn (* const example_entry_point :: entry :: FFIContext , u32 , * mut crate :: fermented :: generics :: Arr_u8_32 , u32) -> * mut crate :: fermented :: generics :: Result_ok_u8_arr_48_err_String , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Result_ok_u8_arr_48_err_String)) -> * mut Fn_ARGS_example_entry_point_entry_FFIContext_u32_Arr_u8_32_u32_RTRN_Result_ok_u8_arr_48_err_String { ferment :: boxed (Fn_ARGS_example_entry_point_entry_FFIContext_u32_Arr_u8_32_u32_RTRN_Result_ok_u8_arr_48_err_String { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_example_entry_point_entry_FFIContext_u32_Arr_u8_32_u32_RTRN_Result_ok_u8_arr_48_err_String_destroy (ffi : * mut Fn_ARGS_example_entry_point_entry_FFIContext_u32_Arr_u8_32_u32_RTRN_Result_ok_u8_arr_48_err_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_example_entry_point_entry_FFIContext { pub obj : * mut example_entry_point :: entry :: FFIContext } impl ferment :: FFIConversionFrom < std :: sync :: Arc < example_entry_point :: entry :: FFIContext > > for std_sync_Arc_example_entry_point_entry_FFIContext { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_example_entry_point_entry_FFIContext) -> std :: sync :: Arc < example_entry_point :: entry :: FFIContext > { let ffi_ref = & * ffi ; std :: sync :: Arc :: from_raw (ffi_ref . obj) } } impl ferment :: FFIConversionTo < std :: sync :: Arc < example_entry_point :: entry :: FFIContext > > for std_sync_Arc_example_entry_point_entry_FFIContext { unsafe fn ffi_to_const (obj : std :: sync :: Arc < example_entry_point :: entry :: FFIContext >) -> * const std_sync_Arc_example_entry_point_entry_FFIContext { ferment :: boxed (Self { obj : std :: sync :: Arc :: into_raw (obj) . cast_mut () }) } } impl Drop for std_sync_Arc_example_entry_point_entry_FFIContext { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_example_entry_point_entry_FFIContext_ctor (obj : * mut example_entry_point :: entry :: FFIContext) -> * mut std_sync_Arc_example_entry_point_entry_FFIContext { ferment :: boxed (std_sync_Arc_example_entry_point_entry_FFIContext { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_example_entry_point_entry_FFIContext_destroy (ffi : * mut std_sync_Arc_example_entry_point_entry_FFIContext) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_example_entry_point_entry_SomeModel { pub obj : * mut crate :: fermented :: types :: example_entry_point :: entry :: example_entry_point_entry_SomeModel } impl ferment :: FFIConversionFrom < std :: sync :: Arc < example_entry_point :: entry :: SomeModel > > for std_sync_Arc_example_entry_point_entry_SomeModel { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_example_entry_point_entry_SomeModel) -> std :: sync :: Arc < example_entry_point :: entry :: SomeModel > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: sync :: Arc < example_entry_point :: entry :: SomeModel > > for std_sync_Arc_example_entry_point_entry_SomeModel { unsafe fn ffi_to_const (obj : std :: sync :: Arc < example_entry_point :: entry :: SomeModel >) -> * const std_sync_Arc_example_entry_point_entry_SomeModel { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to ((* obj) . clone ()) }) } } impl Drop for std_sync_Arc_example_entry_point_entry_SomeModel { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_example_entry_point_entry_SomeModel_ctor (obj : * mut crate :: fermented :: types :: example_entry_point :: entry :: example_entry_point_entry_SomeModel) -> * mut std_sync_Arc_example_entry_point_entry_SomeModel { ferment :: boxed (std_sync_Arc_example_entry_point_entry_SomeModel { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_example_entry_point_entry_SomeModel_destroy (ffi : * mut std_sync_Arc_example_entry_point_entry_SomeModel) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_example_entry_point_entry_FFIContext_String_RTRN_Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String { caller : unsafe extern "C" fn (* const example_entry_point :: entry :: FFIContext , * mut std :: os :: raw :: c_char) -> * mut crate :: fermented :: generics :: Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String) } impl Fn_ARGS_example_entry_point_entry_FFIContext_String_RTRN_Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String { pub unsafe fn call (& self , o_0 : * const example_entry_point :: entry :: FFIContext , o_1 : String) -> Result < Option < std :: sync :: Arc < example_entry_point :: entry :: SomeModel > > , String > { let ffi_result = (self . caller) (o_0 , < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_1)) ; let result = < crate :: fermented :: generics :: Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String as ferment :: FFIConversionFrom < Result < Option < std :: sync :: Arc < example_entry_point :: entry :: SomeModel > > , String > >> :: ffi_from (ffi_result) ; (self . destructor) (ffi_result) ; result } } unsafe impl Send for Fn_ARGS_example_entry_point_entry_FFIContext_String_RTRN_Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String { } unsafe impl Sync for Fn_ARGS_example_entry_point_entry_FFIContext_String_RTRN_Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_example_entry_point_entry_FFIContext_String_RTRN_Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String_ctor (caller : unsafe extern "C" fn (* const example_entry_point :: entry :: FFIContext , * mut std :: os :: raw :: c_char) -> * mut crate :: fermented :: generics :: Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String)) -> * mut Fn_ARGS_example_entry_point_entry_FFIContext_String_RTRN_Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String { ferment :: boxed (Fn_ARGS_example_entry_point_entry_FFIContext_String_RTRN_Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_example_entry_point_entry_FFIContext_String_RTRN_Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String_destroy (ffi : * mut Fn_ARGS_example_entry_point_entry_FFIContext_String_RTRN_Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Result_ok_u8_arr_48_err_String { pub ok : * mut crate :: fermented :: generics :: Arr_u8_48 , pub error : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < Result < [u8 ; 48] , String > > for Result_ok_u8_arr_48_err_String { unsafe fn ffi_from_const (ffi : * const Result_ok_u8_arr_48_err_String) -> Result < [u8 ; 48] , String > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | < crate :: fermented :: generics :: Arr_u8_48 as ferment :: FFIConversionFrom < [u8 ; 48] >> :: ffi_from (o) , ffi_ref . error , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < Result < [u8 ; 48] , String > > for Result_ok_u8_arr_48_err_String { unsafe fn ffi_to_const (obj : Result < [u8 ; 48] , String >) -> * const Result_ok_u8_arr_48_err_String { ferment :: boxed ({ let (ok , error) = ferment :: to_result (obj , | o | ferment :: FFIConversionTo :: ffi_to (o) , | o | ferment :: FFIConversionTo :: ffi_to (o)) ; Self { ok , error } }) } } impl Drop for Result_ok_u8_arr_48_err_String { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . ok) ; ferment :: unbox_any_opt (self . error) ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_u8_arr_48_err_String_ctor (ok : * mut crate :: fermented :: generics :: Arr_u8_48 , error : * mut std :: os :: raw :: c_char) -> * mut Result_ok_u8_arr_48_err_String { ferment :: boxed (Result_ok_u8_arr_48_err_String { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_u8_arr_48_err_String_destroy (ffi : * mut Result_ok_u8_arr_48_err_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String { pub ok : * mut crate :: fermented :: generics :: std_sync_Arc_example_entry_point_entry_SomeModel , pub error : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < Result < Option < std :: sync :: Arc < example_entry_point :: entry :: SomeModel > > , String > > for Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String { unsafe fn ffi_from_const (ffi : * const Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String) -> Result < Option < std :: sync :: Arc < example_entry_point :: entry :: SomeModel > > , String > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | < crate :: fermented :: generics :: std_sync_Arc_example_entry_point_entry_SomeModel as ferment :: FFIConversionFrom < std :: sync :: Arc < example_entry_point :: entry :: SomeModel > >> :: ffi_from_opt (o) , ffi_ref . error , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < Result < Option < std :: sync :: Arc < example_entry_point :: entry :: SomeModel > > , String > > for Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String { unsafe fn ffi_to_const (obj : Result < Option < std :: sync :: Arc < example_entry_point :: entry :: SomeModel > > , String >) -> * const Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String { ferment :: boxed ({ let (ok , error) = ferment :: to_result (obj , | o | ferment :: FFIConversionTo :: ffi_to_opt (o) , | o | ferment :: FFIConversionTo :: ffi_to (o)) ; Self { ok , error } }) } } impl Drop for Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . ok) ; ferment :: unbox_any_opt (self . error) ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String_ctor (ok : * mut crate :: fermented :: generics :: std_sync_Arc_example_entry_point_entry_SomeModel , error : * mut std :: os :: raw :: c_char) -> * mut Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String { ferment :: boxed (Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String_destroy (ffi : * mut Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_Option_std_net_SocketAddr_bool_RTRN_ { caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , bool , i32 , * mut crate :: fermented :: generics :: Arr_u8_32 , u32 , * mut crate :: fermented :: generics :: Arr_u8_32 , * mut crate :: fermented :: generics :: Arr_u8_32 , * mut crate :: fermented :: generics :: Arr_u8_32 , * mut example_entry_point :: custom :: std :: SocketAddr , bool) } impl Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_Option_std_net_SocketAddr_bool_RTRN_ { pub unsafe fn call (& self , o_0 : * const std :: os :: raw :: c_void , o_1 : bool , o_2 : i32 , o_3 : [u8 ; 32] , o_4 : u32 , o_5 : [u8 ; 32] , o_6 : [u8 ; 32] , o_7 : [u8 ; 32] , o_8 : Option < std :: net :: SocketAddr > , o_9 : bool) { let ffi_result = (self . caller) (o_0 , o_1 , o_2 , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_3) , o_4 , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_5) , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_6) , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_7) , < example_entry_point :: custom :: std :: SocketAddr as ferment :: FFIConversionTo < std :: net :: SocketAddr >> :: ffi_to_opt (o_8) , o_9) ; ffi_result } } unsafe impl Send for Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_Option_std_net_SocketAddr_bool_RTRN_ { } unsafe impl Sync for Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_Option_std_net_SocketAddr_bool_RTRN_ { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_Option_std_net_SocketAddr_bool_RTRN__ctor (caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , bool , i32 , * mut crate :: fermented :: generics :: Arr_u8_32 , u32 , * mut crate :: fermented :: generics :: Arr_u8_32 , * mut crate :: fermented :: generics :: Arr_u8_32 , * mut crate :: fermented :: generics :: Arr_u8_32 , * mut example_entry_point :: custom :: std :: SocketAddr , bool)) -> * mut Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_Option_std_net_SocketAddr_bool_RTRN_ { ferment :: boxed (Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_Option_std_net_SocketAddr_bool_RTRN_ { caller }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_Option_std_net_SocketAddr_bool_RTRN__destroy (ffi : * mut Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_Option_std_net_SocketAddr_bool_RTRN_) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool { caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , * mut crate :: fermented :: generics :: Arr_u8_32) -> bool , destructor : unsafe extern "C" fn (bool) } impl Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool { pub unsafe fn call (& self , o_0 : * const std :: os :: raw :: c_void , o_1 : [u8 ; 32]) -> bool { let ffi_result = (self . caller) (o_0 , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_1)) ; ffi_result } } unsafe impl Send for Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool { } unsafe impl Sync for Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool_ctor (caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , * mut crate :: fermented :: generics :: Arr_u8_32) -> bool , destructor : unsafe extern "C" fn (bool)) -> * mut Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool { ferment :: boxed (Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool_destroy (ffi : * mut Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError { caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey) -> * mut crate :: fermented :: generics :: Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError) } impl Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError { pub unsafe fn call (& self , o_0 : * const std :: os :: raw :: c_void , o_1 : example_entry_point :: keychain :: KeyChainKey) -> Result < example_entry_point :: keychain :: KeyChainValue , example_entry_point :: keychain :: KeyChainError > { let ffi_result = (self . caller) (o_0 , < crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey as ferment :: FFIConversionTo < example_entry_point :: keychain :: KeyChainKey >> :: ffi_to (o_1)) ; let result = < crate :: fermented :: generics :: Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError as ferment :: FFIConversionFrom < Result < example_entry_point :: keychain :: KeyChainValue , example_entry_point :: keychain :: KeyChainError > >> :: ffi_from (ffi_result) ; (self . destructor) (ffi_result) ; result } } unsafe impl Send for Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError { } unsafe impl Sync for Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError_ctor (caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey) -> * mut crate :: fermented :: generics :: Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError)) -> * mut Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError { ferment :: boxed (Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError_destroy (ffi : * mut Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_std_os_raw_c_void_RTRN_bool { caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void) -> bool , destructor : unsafe extern "C" fn (bool) } impl Fn_ARGS_std_os_raw_c_void_RTRN_bool { pub unsafe fn call (& self , o_0 : * const std :: os :: raw :: c_void) -> bool { let ffi_result = (self . caller) (o_0) ; ffi_result } } unsafe impl Send for Fn_ARGS_std_os_raw_c_void_RTRN_bool { } unsafe impl Sync for Fn_ARGS_std_os_raw_c_void_RTRN_bool { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_RTRN_bool_ctor (caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void) -> bool , destructor : unsafe extern "C" fn (bool)) -> * mut Fn_ARGS_std_os_raw_c_void_RTRN_bool { ferment :: boxed (Fn_ARGS_std_os_raw_c_void_RTRN_bool { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_RTRN_bool_destroy (ffi : * mut Fn_ARGS_std_os_raw_c_void_RTRN_bool) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_u32_RTRN_Arr_u8_32 { caller : unsafe extern "C" fn (u32) -> * mut crate :: fermented :: generics :: Arr_u8_32 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32) } impl Fn_ARGS_u32_RTRN_Arr_u8_32 { pub unsafe fn call (& self , o_0 : u32) -> [u8 ; 32] { let ffi_result = (self . caller) (o_0) ; let result = < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (ffi_result) ; (self . destructor) (ffi_result) ; result } } unsafe impl Send for Fn_ARGS_u32_RTRN_Arr_u8_32 { } unsafe impl Sync for Fn_ARGS_u32_RTRN_Arr_u8_32 { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_RTRN_Arr_u8_32_ctor (caller : unsafe extern "C" fn (u32) -> * mut crate :: fermented :: generics :: Arr_u8_32 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32)) -> * mut Fn_ARGS_u32_RTRN_Arr_u8_32 { ferment :: boxed (Fn_ARGS_u32_RTRN_Arr_u8_32 { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_RTRN_Arr_u8_32_destroy (ffi : * mut Fn_ARGS_u32_RTRN_Arr_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_dyn_trait_Fn_ARGS_example_entry_point_provider_wallet_ex_WalletEx2_Arr_u8_32_bool_RTRN_Option_u8_32 { pub obj : * mut crate :: fermented :: generics :: Fn_ARGS_example_entry_point_provider_wallet_ex_WalletEx2_Arr_u8_32_bool_RTRN_Option_u8_32 } impl ferment :: FFIConversionFrom < std :: sync :: Arc < dyn Fn (* const example_entry_point :: provider :: wallet_ex :: WalletEx2 , & [u8 ; 32] , bool) -> Option < [u8 ; 32] > > > for std_sync_Arc_dyn_trait_Fn_ARGS_example_entry_point_provider_wallet_ex_WalletEx2_Arr_u8_32_bool_RTRN_Option_u8_32 { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_dyn_trait_Fn_ARGS_example_entry_point_provider_wallet_ex_WalletEx2_Arr_u8_32_bool_RTRN_Option_u8_32) -> std :: sync :: Arc < dyn Fn (* const example_entry_point :: provider :: wallet_ex :: WalletEx2 , & [u8 ; 32] , bool) -> Option < [u8 ; 32] > > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (move | o_0 , o_1 , o_2 | unsafe { (& * ffi_ref . obj) . call (o_0 , o_1 , o_2) }) } } impl Drop for std_sync_Arc_dyn_trait_Fn_ARGS_example_entry_point_provider_wallet_ex_WalletEx2_Arr_u8_32_bool_RTRN_Option_u8_32 { fn drop (& mut self) { unsafe { ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_example_entry_point_provider_wallet_ex_WalletEx2_Arr_u8_32_bool_RTRN_Option_u8_32_ctor (obj : * mut crate :: fermented :: generics :: Fn_ARGS_example_entry_point_provider_wallet_ex_WalletEx2_Arr_u8_32_bool_RTRN_Option_u8_32) -> * mut std_sync_Arc_dyn_trait_Fn_ARGS_example_entry_point_provider_wallet_ex_WalletEx2_Arr_u8_32_bool_RTRN_Option_u8_32 { ferment :: boxed (std_sync_Arc_dyn_trait_Fn_ARGS_example_entry_point_provider_wallet_ex_WalletEx2_Arr_u8_32_bool_RTRN_Option_u8_32 { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_example_entry_point_provider_wallet_ex_WalletEx2_Arr_u8_32_bool_RTRN_Option_u8_32_destroy (ffi : * mut std_sync_Arc_dyn_trait_Fn_ARGS_example_entry_point_provider_wallet_ex_WalletEx2_Arr_u8_32_bool_RTRN_Option_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_u8_arr_32_values_bool { pub count : usize , pub keys : * mut * mut crate :: fermented :: generics :: Arr_u8_32 , pub values : * mut bool } impl ferment :: FFIConversionFrom < std :: collections :: HashMap < [u8 ; 32] , bool > > for std_collections_Map_keys_u8_arr_32_values_bool { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u8_arr_32_values_bool) -> std :: collections :: HashMap < [u8 ; 32] , bool > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (o) , | o | o) } } impl ferment :: FFIConversionTo < std :: collections :: HashMap < [u8 ; 32] , bool > > for std_collections_Map_keys_u8_arr_32_values_bool { unsafe fn ffi_to_const (obj : std :: collections :: HashMap < [u8 ; 32] , bool >) -> * const std_collections_Map_keys_u8_arr_32_values_bool { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_primitive_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_u8_arr_32_values_bool { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . keys , self . count) ; ferment :: unbox_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u8_arr_32_values_bool_ctor (count : usize , keys : * mut * mut crate :: fermented :: generics :: Arr_u8_32 , values : * mut bool) -> * mut std_collections_Map_keys_u8_arr_32_values_bool { ferment :: boxed (std_collections_Map_keys_u8_arr_32_values_bool { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u8_arr_32_values_bool_destroy (ffi : * mut std_collections_Map_keys_u8_arr_32_values_bool) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Result_ok_bool_err_String { pub ok : * mut bool , pub error : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < Result < bool , String > > for Result_ok_bool_err_String { unsafe fn ffi_from_const (ffi : * const Result_ok_bool_err_String) -> Result < bool , String > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | * o , ffi_ref . error , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < Result < bool , String > > for Result_ok_bool_err_String { unsafe fn ffi_to_const (obj : Result < bool , String >) -> * const Result_ok_bool_err_String { ferment :: boxed ({ let (ok , error) = ferment :: to_result (obj , | o | ferment :: boxed (o) , | o | ferment :: FFIConversionTo :: ffi_to (o)) ; Self { ok , error } }) } } impl Drop for Result_ok_bool_err_String { fn drop (& mut self) { unsafe { ferment :: destroy_opt_primitive (self . ok) ; ferment :: unbox_any_opt (self . error) ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_bool_err_String_ctor (ok : * mut bool , error : * mut std :: os :: raw :: c_char) -> * mut Result_ok_bool_err_String { ferment :: boxed (Result_ok_bool_err_String { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_bool_err_String_destroy (ffi : * mut Result_ok_bool_err_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_provider_wallet_ex_WalletEx2_RTRN_Vec_u8_32 { caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , bool , * mut crate :: fermented :: generics :: Arr_u8_32 , * mut example_entry_point :: provider :: wallet_ex :: WalletEx2) -> * mut crate :: fermented :: generics :: Vec_u8_32 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Vec_u8_32) } impl Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_provider_wallet_ex_WalletEx2_RTRN_Vec_u8_32 { pub unsafe fn call (& self , o_0 : * const std :: os :: raw :: c_void , o_1 : bool , o_2 : [u8 ; 32] , o_3 : & example_entry_point :: provider :: wallet_ex :: WalletEx2) -> Vec < [u8 ; 32] > { let ffi_result = (self . caller) (o_0 , o_1 , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_2) , ferment :: boxed (o_3 . clone ())) ; let result = < crate :: fermented :: generics :: Vec_u8_32 as ferment :: FFIConversionFrom < Vec < [u8 ; 32] > >> :: ffi_from (ffi_result) ; (self . destructor) (ffi_result) ; result } } unsafe impl Send for Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_provider_wallet_ex_WalletEx2_RTRN_Vec_u8_32 { } unsafe impl Sync for Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_provider_wallet_ex_WalletEx2_RTRN_Vec_u8_32 { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_provider_wallet_ex_WalletEx2_RTRN_Vec_u8_32_ctor (caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , bool , * mut crate :: fermented :: generics :: Arr_u8_32 , * mut example_entry_point :: provider :: wallet_ex :: WalletEx2) -> * mut crate :: fermented :: generics :: Vec_u8_32 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Vec_u8_32)) -> * mut Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_provider_wallet_ex_WalletEx2_RTRN_Vec_u8_32 { ferment :: boxed (Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_provider_wallet_ex_WalletEx2_RTRN_Vec_u8_32 { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_provider_wallet_ex_WalletEx2_RTRN_Vec_u8_32_destroy (ffi : * mut Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_provider_wallet_ex_WalletEx2_RTRN_Vec_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_u32_RTRN_example_entry_point_entry_SomeModel { caller : unsafe extern "C" fn (u32) -> * mut crate :: fermented :: types :: example_entry_point :: entry :: example_entry_point_entry_SomeModel , destructor : unsafe extern "C" fn (* mut crate :: fermented :: types :: example_entry_point :: entry :: example_entry_point_entry_SomeModel) } impl Fn_ARGS_u32_RTRN_example_entry_point_entry_SomeModel { pub unsafe fn call (& self , o_0 : u32) -> example_entry_point :: entry :: SomeModel { let ffi_result = (self . caller) (o_0) ; let result = < crate :: fermented :: types :: example_entry_point :: entry :: example_entry_point_entry_SomeModel as ferment :: FFIConversionFrom < example_entry_point :: entry :: SomeModel >> :: ffi_from (ffi_result) ; (self . destructor) (ffi_result) ; result } } unsafe impl Send for Fn_ARGS_u32_RTRN_example_entry_point_entry_SomeModel { } unsafe impl Sync for Fn_ARGS_u32_RTRN_example_entry_point_entry_SomeModel { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_RTRN_example_entry_point_entry_SomeModel_ctor (caller : unsafe extern "C" fn (u32) -> * mut crate :: fermented :: types :: example_entry_point :: entry :: example_entry_point_entry_SomeModel , destructor : unsafe extern "C" fn (* mut crate :: fermented :: types :: example_entry_point :: entry :: example_entry_point_entry_SomeModel)) -> * mut Fn_ARGS_u32_RTRN_example_entry_point_entry_SomeModel { ferment :: boxed (Fn_ARGS_u32_RTRN_example_entry_point_entry_SomeModel { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_RTRN_example_entry_point_entry_SomeModel_destroy (ffi : * mut Fn_ARGS_u32_RTRN_example_entry_point_entry_SomeModel) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_std_net_SocketAddr_bool_RTRN_ { caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , bool , i32 , * mut crate :: fermented :: generics :: Arr_u8_32 , u32 , * mut crate :: fermented :: generics :: Arr_u8_32 , * mut crate :: fermented :: generics :: Arr_u8_32 , * mut crate :: fermented :: generics :: Arr_u8_32 , * mut example_entry_point :: custom :: std :: SocketAddr , bool) } impl Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_std_net_SocketAddr_bool_RTRN_ { pub unsafe fn call (& self , o_0 : * const std :: os :: raw :: c_void , o_1 : bool , o_2 : i32 , o_3 : [u8 ; 32] , o_4 : u32 , o_5 : [u8 ; 32] , o_6 : [u8 ; 32] , o_7 : [u8 ; 32] , o_8 : std :: net :: SocketAddr , o_9 : bool) { let ffi_result = (self . caller) (o_0 , o_1 , o_2 , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_3) , o_4 , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_5) , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_6) , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_7) , < example_entry_point :: custom :: std :: SocketAddr as ferment :: FFIConversionTo < std :: net :: SocketAddr >> :: ffi_to (o_8) , o_9) ; ffi_result } } unsafe impl Send for Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_std_net_SocketAddr_bool_RTRN_ { } unsafe impl Sync for Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_std_net_SocketAddr_bool_RTRN_ { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_std_net_SocketAddr_bool_RTRN__ctor (caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , bool , i32 , * mut crate :: fermented :: generics :: Arr_u8_32 , u32 , * mut crate :: fermented :: generics :: Arr_u8_32 , * mut crate :: fermented :: generics :: Arr_u8_32 , * mut crate :: fermented :: generics :: Arr_u8_32 , * mut example_entry_point :: custom :: std :: SocketAddr , bool)) -> * mut Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_std_net_SocketAddr_bool_RTRN_ { ferment :: boxed (Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_std_net_SocketAddr_bool_RTRN_ { caller }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_std_net_SocketAddr_bool_RTRN__destroy (ffi : * mut Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_std_net_SocketAddr_bool_RTRN_) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_std_os_raw_c_void_bool_bool_Vec_u8_32_RTRN_ { caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , bool , bool , * mut crate :: fermented :: generics :: Vec_u8_32) } impl Fn_ARGS_std_os_raw_c_void_bool_bool_Vec_u8_32_RTRN_ { pub unsafe fn call (& self , o_0 : * const std :: os :: raw :: c_void , o_1 : bool , o_2 : bool , o_3 : Vec < [u8 ; 32] >) { let ffi_result = (self . caller) (o_0 , o_1 , o_2 , < crate :: fermented :: generics :: Vec_u8_32 as ferment :: FFIConversionTo < Vec < [u8 ; 32] > >> :: ffi_to (o_3)) ; ffi_result } } unsafe impl Send for Fn_ARGS_std_os_raw_c_void_bool_bool_Vec_u8_32_RTRN_ { } unsafe impl Sync for Fn_ARGS_std_os_raw_c_void_bool_bool_Vec_u8_32_RTRN_ { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_bool_bool_Vec_u8_32_RTRN__ctor (caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , bool , bool , * mut crate :: fermented :: generics :: Vec_u8_32)) -> * mut Fn_ARGS_std_os_raw_c_void_bool_bool_Vec_u8_32_RTRN_ { ferment :: boxed (Fn_ARGS_std_os_raw_c_void_bool_bool_Vec_u8_32_RTRN_ { caller }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_bool_bool_Vec_u8_32_RTRN__destroy (ffi : * mut Fn_ARGS_std_os_raw_c_void_bool_bool_Vec_u8_32_RTRN_) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError { caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey) -> * mut crate :: fermented :: generics :: Result_ok_bool_err_example_entry_point_keychain_KeyChainError , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Result_ok_bool_err_example_entry_point_keychain_KeyChainError) } impl Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError { pub unsafe fn call (& self , o_0 : * const std :: os :: raw :: c_void , o_1 : example_entry_point :: keychain :: KeyChainKey) -> Result < bool , example_entry_point :: keychain :: KeyChainError > { let ffi_result = (self . caller) (o_0 , < crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey as ferment :: FFIConversionTo < example_entry_point :: keychain :: KeyChainKey >> :: ffi_to (o_1)) ; let result = < crate :: fermented :: generics :: Result_ok_bool_err_example_entry_point_keychain_KeyChainError as ferment :: FFIConversionFrom < Result < bool , example_entry_point :: keychain :: KeyChainError > >> :: ffi_from (ffi_result) ; (self . destructor) (ffi_result) ; result } } unsafe impl Send for Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError { } unsafe impl Sync for Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError_ctor (caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey) -> * mut crate :: fermented :: generics :: Result_ok_bool_err_example_entry_point_keychain_KeyChainError , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Result_ok_bool_err_example_entry_point_keychain_KeyChainError)) -> * mut Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError { ferment :: boxed (Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError_destroy (ffi : * mut Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_bool_Vec_u8_32_RTRN_ { pub obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_bool_bool_Vec_u8_32_RTRN_ } impl ferment :: FFIConversionFrom < std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , bool , bool , Vec < [u8 ; 32] >) > > for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_bool_Vec_u8_32_RTRN_ { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_bool_Vec_u8_32_RTRN_) -> std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , bool , bool , Vec < [u8 ; 32] >) > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (move | o_0 , o_1 , o_2 , o_3 | unsafe { (& * ffi_ref . obj) . call (o_0 , o_1 , o_2 , o_3) }) } } impl Drop for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_bool_Vec_u8_32_RTRN_ { fn drop (& mut self) { unsafe { ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_bool_Vec_u8_32_RTRN__ctor (obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_bool_bool_Vec_u8_32_RTRN_) -> * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_bool_Vec_u8_32_RTRN_ { ferment :: boxed (std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_bool_Vec_u8_32_RTRN_ { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_bool_Vec_u8_32_RTRN__destroy (ffi : * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_bool_Vec_u8_32_RTRN_) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_std_os_raw_c_void_RTRN_ { caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void) } impl Fn_ARGS_std_os_raw_c_void_RTRN_ { pub unsafe fn call (& self , o_0 : * const std :: os :: raw :: c_void) { let ffi_result = (self . caller) (o_0) ; ffi_result } } unsafe impl Send for Fn_ARGS_std_os_raw_c_void_RTRN_ { } unsafe impl Sync for Fn_ARGS_std_os_raw_c_void_RTRN_ { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_RTRN__ctor (caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void)) -> * mut Fn_ARGS_std_os_raw_c_void_RTRN_ { ferment :: boxed (Fn_ARGS_std_os_raw_c_void_RTRN_ { caller }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_RTRN__destroy (ffi : * mut Fn_ARGS_std_os_raw_c_void_RTRN_) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Arr_u8_48 { pub count : usize , pub values : * mut u8 } impl ferment :: FFIConversionFrom < [u8 ; 48] > for Arr_u8_48 { unsafe fn ffi_from_const (ffi : * const Arr_u8_48) -> [u8 ; 48] { let ffi_ref = & * ffi ; let vec : Vec < u8 > = ferment :: from_primitive_group (ffi_ref . values , ffi_ref . count) ; vec . try_into () . unwrap () } } impl ferment :: FFIConversionTo < [u8 ; 48] > for Arr_u8_48 { unsafe fn ffi_to_const (obj : [u8 ; 48]) -> * const Arr_u8_48 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_primitive_group (obj . into_iter ()) }) } } impl Drop for Arr_u8_48 { fn drop (& mut self) { unsafe { ferment :: unbox_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Arr_u8_48_ctor (count : usize , values : * mut u8) -> * mut Arr_u8_48 { ferment :: boxed (Arr_u8_48 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Arr_u8_48_destroy (ffi : * mut Arr_u8_48) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_provider_wallet_ex_WalletEx2_RTRN_Vec_u8_32 { pub obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_provider_wallet_ex_WalletEx2_RTRN_Vec_u8_32 } impl ferment :: FFIConversionFrom < std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , bool , [u8 ; 32] , & example_entry_point :: provider :: wallet_ex :: WalletEx2) -> Vec < [u8 ; 32] > > > for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_provider_wallet_ex_WalletEx2_RTRN_Vec_u8_32 { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_provider_wallet_ex_WalletEx2_RTRN_Vec_u8_32) -> std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , bool , [u8 ; 32] , & example_entry_point :: provider :: wallet_ex :: WalletEx2) -> Vec < [u8 ; 32] > > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (move | o_0 , o_1 , o_2 , o_3 | unsafe { (& * ffi_ref . obj) . call (o_0 , o_1 , o_2 , o_3) }) } } impl Drop for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_provider_wallet_ex_WalletEx2_RTRN_Vec_u8_32 { fn drop (& mut self) { unsafe { ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_provider_wallet_ex_WalletEx2_RTRN_Vec_u8_32_ctor (obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_provider_wallet_ex_WalletEx2_RTRN_Vec_u8_32) -> * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_provider_wallet_ex_WalletEx2_RTRN_Vec_u8_32 { ferment :: boxed (std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_provider_wallet_ex_WalletEx2_RTRN_Vec_u8_32 { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_provider_wallet_ex_WalletEx2_RTRN_Vec_u8_32_destroy (ffi : * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_provider_wallet_ex_WalletEx2_RTRN_Vec_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_u8_32 { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Arr_u8_32 } impl ferment :: FFIConversionFrom < Vec < [u8 ; 32] > > for Vec_u8_32 { unsafe fn ffi_from_const (ffi : * const Vec_u8_32) -> Vec < [u8 ; 32] > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < [u8 ; 32] > > for Vec_u8_32 { unsafe fn ffi_to_const (obj : Vec < [u8 ; 32] >) -> * const Vec_u8_32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Vec_u8_32 { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_u8_32_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut Vec_u8_32 { ferment :: boxed (Vec_u8_32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_u8_32_destroy (ffi : * mut Vec_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_Arr_u8_32 { pub obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_RTRN_Arr_u8_32 } impl ferment :: FFIConversionFrom < std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void) -> [u8 ; 32] > > for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_Arr_u8_32 { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_Arr_u8_32) -> std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void) -> [u8 ; 32] > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (move | o_0 | unsafe { (& * ffi_ref . obj) . call (o_0) }) } } impl Drop for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_Arr_u8_32 { fn drop (& mut self) { unsafe { ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_Arr_u8_32_ctor (obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_RTRN_Arr_u8_32) -> * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_Arr_u8_32 { ferment :: boxed (std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_Arr_u8_32 { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_Arr_u8_32_destroy (ffi : * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_Arr_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Slice_u8 { pub count : usize , pub values : * mut u8 } impl ferment :: FFIConversionFrom < Vec < u8 > > for Slice_u8 { unsafe fn ffi_from_const (ffi : * const Slice_u8) -> Vec < u8 > { let ffi_ref = & * ffi ; ferment :: from_primitive_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < u8 > > for Slice_u8 { unsafe fn ffi_to_const (obj : Vec < u8 >) -> * const Slice_u8 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_primitive_group (obj . into_iter ()) }) } } impl Drop for Slice_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Slice_u8_ctor (count : usize , values : * mut u8) -> * mut Slice_u8 { ferment :: boxed (Slice_u8 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Slice_u8_destroy (ffi : * mut Slice_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_rc_Rc_std_cell_RefCell_u8_32 { pub obj : * mut crate :: fermented :: generics :: std_cell_RefCell_u8_32 } impl ferment :: FFIConversionFrom < std :: rc :: Rc < std :: cell :: RefCell < [u8 ; 32] > > > for std_rc_Rc_std_cell_RefCell_u8_32 { unsafe fn ffi_from_const (ffi : * const std_rc_Rc_std_cell_RefCell_u8_32) -> std :: rc :: Rc < std :: cell :: RefCell < [u8 ; 32] > > { let ffi_ref = & * ffi ; std :: rc :: Rc :: new (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: rc :: Rc < std :: cell :: RefCell < [u8 ; 32] > > > for std_rc_Rc_std_cell_RefCell_u8_32 { unsafe fn ffi_to_const (obj : std :: rc :: Rc < std :: cell :: RefCell < [u8 ; 32] > >) -> * const std_rc_Rc_std_cell_RefCell_u8_32 { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to ((* obj) . clone ()) }) } } impl Drop for std_rc_Rc_std_cell_RefCell_u8_32 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_rc_Rc_std_cell_RefCell_u8_32_ctor (obj : * mut crate :: fermented :: generics :: std_cell_RefCell_u8_32) -> * mut std_rc_Rc_std_cell_RefCell_u8_32 { ferment :: boxed (std_rc_Rc_std_cell_RefCell_u8_32 { obj }) } # [no_mangle] pub unsafe extern "C" fn std_rc_Rc_std_cell_RefCell_u8_32_destroy (ffi : * mut std_rc_Rc_std_cell_RefCell_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_example_entry_point_provider_wallet_provider_WalletProvider2 { pub obj : * mut example_entry_point :: provider :: wallet_provider :: WalletProvider2 } impl ferment :: FFIConversionFrom < std :: sync :: Arc < example_entry_point :: provider :: wallet_provider :: WalletProvider2 > > for std_sync_Arc_example_entry_point_provider_wallet_provider_WalletProvider2 { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_example_entry_point_provider_wallet_provider_WalletProvider2) -> std :: sync :: Arc < example_entry_point :: provider :: wallet_provider :: WalletProvider2 > { let ffi_ref = & * ffi ; std :: sync :: Arc :: from_raw (ffi_ref . obj) } } impl ferment :: FFIConversionTo < std :: sync :: Arc < example_entry_point :: provider :: wallet_provider :: WalletProvider2 > > for std_sync_Arc_example_entry_point_provider_wallet_provider_WalletProvider2 { unsafe fn ffi_to_const (obj : std :: sync :: Arc < example_entry_point :: provider :: wallet_provider :: WalletProvider2 >) -> * const std_sync_Arc_example_entry_point_provider_wallet_provider_WalletProvider2 { ferment :: boxed (Self { obj : std :: sync :: Arc :: into_raw (obj) . cast_mut () }) } } impl Drop for std_sync_Arc_example_entry_point_provider_wallet_provider_WalletProvider2 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_example_entry_point_provider_wallet_provider_WalletProvider2_ctor (obj : * mut example_entry_point :: provider :: wallet_provider :: WalletProvider2) -> * mut std_sync_Arc_example_entry_point_provider_wallet_provider_WalletProvider2 { ferment :: boxed (std_sync_Arc_example_entry_point_provider_wallet_provider_WalletProvider2 { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_example_entry_point_provider_wallet_provider_WalletProvider2_destroy (ffi : * mut std_sync_Arc_example_entry_point_provider_wallet_provider_WalletProvider2) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool { pub obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool } impl ferment :: FFIConversionFrom < std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , [u8 ; 32]) -> bool > > for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool) -> std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , [u8 ; 32]) -> bool > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (move | o_0 , o_1 | unsafe { (& * ffi_ref . obj) . call (o_0 , o_1) }) } } impl Drop for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool { fn drop (& mut self) { unsafe { ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool_ctor (obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool) -> * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool { ferment :: boxed (std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool_destroy (ffi : * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_HashSet_u64 { pub count : usize , pub values : * mut u64 } impl ferment :: FFIConversionFrom < std :: collections :: HashSet < u64 > > for std_collections_HashSet_u64 { unsafe fn ffi_from_const (ffi : * const std_collections_HashSet_u64) -> std :: collections :: HashSet < u64 > { let ffi_ref = & * ffi ; ferment :: from_primitive_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < std :: collections :: HashSet < u64 > > for std_collections_HashSet_u64 { unsafe fn ffi_to_const (obj : std :: collections :: HashSet < u64 >) -> * const std_collections_HashSet_u64 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_primitive_group (obj . into_iter ()) }) } } impl Drop for std_collections_HashSet_u64 { fn drop (& mut self) { unsafe { ferment :: unbox_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_u64_ctor (count : usize , values : * mut u64) -> * mut std_collections_HashSet_u64 { ferment :: boxed (std_collections_HashSet_u64 { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_u64_destroy (ffi : * mut std_collections_HashSet_u64) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_Vec_u8 { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < Vec < Vec < u8 > > > for Vec_Vec_u8 { unsafe fn ffi_from_const (ffi : * const Vec_Vec_u8) -> Vec < Vec < u8 > > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < Vec < u8 > > > for Vec_Vec_u8 { unsafe fn ffi_to_const (obj : Vec < Vec < u8 > >) -> * const Vec_Vec_u8 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Vec_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_Vec_u8_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Vec_u8) -> * mut Vec_Vec_u8 { ferment :: boxed (Vec_Vec_u8 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_Vec_u8_destroy (ffi : * mut Vec_Vec_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_example_entry_point_keychain_KeyChainValue_bool_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError { caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey , * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainValue , bool) -> * mut crate :: fermented :: generics :: Result_ok_bool_err_example_entry_point_keychain_KeyChainError , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Result_ok_bool_err_example_entry_point_keychain_KeyChainError) } impl Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_example_entry_point_keychain_KeyChainValue_bool_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError { pub unsafe fn call (& self , o_0 : * const std :: os :: raw :: c_void , o_1 : example_entry_point :: keychain :: KeyChainKey , o_2 : example_entry_point :: keychain :: KeyChainValue , o_3 : bool) -> Result < bool , example_entry_point :: keychain :: KeyChainError > { let ffi_result = (self . caller) (o_0 , < crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey as ferment :: FFIConversionTo < example_entry_point :: keychain :: KeyChainKey >> :: ffi_to (o_1) , < crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainValue as ferment :: FFIConversionTo < example_entry_point :: keychain :: KeyChainValue >> :: ffi_to (o_2) , o_3) ; let result = < crate :: fermented :: generics :: Result_ok_bool_err_example_entry_point_keychain_KeyChainError as ferment :: FFIConversionFrom < Result < bool , example_entry_point :: keychain :: KeyChainError > >> :: ffi_from (ffi_result) ; (self . destructor) (ffi_result) ; result } } unsafe impl Send for Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_example_entry_point_keychain_KeyChainValue_bool_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError { } unsafe impl Sync for Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_example_entry_point_keychain_KeyChainValue_bool_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_example_entry_point_keychain_KeyChainValue_bool_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError_ctor (caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey , * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainValue , bool) -> * mut crate :: fermented :: generics :: Result_ok_bool_err_example_entry_point_keychain_KeyChainError , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Result_ok_bool_err_example_entry_point_keychain_KeyChainError)) -> * mut Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_example_entry_point_keychain_KeyChainValue_bool_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError { ferment :: boxed (Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_example_entry_point_keychain_KeyChainValue_bool_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_example_entry_point_keychain_KeyChainValue_bool_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError_destroy (ffi : * mut Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_example_entry_point_keychain_KeyChainValue_bool_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError { pub ok : * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainValue , pub error : * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainError } impl ferment :: FFIConversionFrom < Result < example_entry_point :: keychain :: KeyChainValue , example_entry_point :: keychain :: KeyChainError > > for Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError { unsafe fn ffi_from_const (ffi : * const Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError) -> Result < example_entry_point :: keychain :: KeyChainValue , example_entry_point :: keychain :: KeyChainError > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | < crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainValue as ferment :: FFIConversionFrom < example_entry_point :: keychain :: KeyChainValue >> :: ffi_from (o) , ffi_ref . error , | o | < crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainError as ferment :: FFIConversionFrom < example_entry_point :: keychain :: KeyChainError >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < Result < example_entry_point :: keychain :: KeyChainValue , example_entry_point :: keychain :: KeyChainError > > for Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError { unsafe fn ffi_to_const (obj : Result < example_entry_point :: keychain :: KeyChainValue , example_entry_point :: keychain :: KeyChainError >) -> * const Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError { ferment :: boxed ({ let (ok , error) = ferment :: to_result (obj , | o | ferment :: FFIConversionTo :: ffi_to (o) , | o | ferment :: FFIConversionTo :: ffi_to (o)) ; Self { ok , error } }) } } impl Drop for Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . ok) ; ferment :: unbox_any_opt (self . error) ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError_ctor (ok : * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainValue , error : * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainError) -> * mut Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError { ferment :: boxed (Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError_destroy (ffi : * mut Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_Arr_u8_32_RTRN_u32 { caller : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32) -> u32 , destructor : unsafe extern "C" fn (u32) } impl Fn_ARGS_Arr_u8_32_RTRN_u32 { pub unsafe fn call (& self , o_0 : [u8 ; 32]) -> u32 { let ffi_result = (self . caller) (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_0)) ; ffi_result } } unsafe impl Send for Fn_ARGS_Arr_u8_32_RTRN_u32 { } unsafe impl Sync for Fn_ARGS_Arr_u8_32_RTRN_u32 { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_Arr_u8_32_RTRN_u32_ctor (caller : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32) -> u32 , destructor : unsafe extern "C" fn (u32)) -> * mut Fn_ARGS_Arr_u8_32_RTRN_u32 { ferment :: boxed (Fn_ARGS_Arr_u8_32_RTRN_u32 { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_Arr_u8_32_RTRN_u32_destroy (ffi : * mut Fn_ARGS_Arr_u8_32_RTRN_u32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_u8_arr_32_values_i32 { pub count : usize , pub keys : * mut * mut crate :: fermented :: generics :: Arr_u8_32 , pub values : * mut i32 } impl ferment :: FFIConversionFrom < std :: collections :: HashMap < [u8 ; 32] , i32 > > for std_collections_Map_keys_u8_arr_32_values_i32 { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u8_arr_32_values_i32) -> std :: collections :: HashMap < [u8 ; 32] , i32 > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (o) , | o | o) } } impl ferment :: FFIConversionTo < std :: collections :: HashMap < [u8 ; 32] , i32 > > for std_collections_Map_keys_u8_arr_32_values_i32 { unsafe fn ffi_to_const (obj : std :: collections :: HashMap < [u8 ; 32] , i32 >) -> * const std_collections_Map_keys_u8_arr_32_values_i32 { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_primitive_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_u8_arr_32_values_i32 { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . keys , self . count) ; ferment :: unbox_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u8_arr_32_values_i32_ctor (count : usize , keys : * mut * mut crate :: fermented :: generics :: Arr_u8_32 , values : * mut i32) -> * mut std_collections_Map_keys_u8_arr_32_values_i32 { ferment :: boxed (std_collections_Map_keys_u8_arr_32_values_i32 { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u8_arr_32_values_i32_destroy (ffi : * mut std_collections_Map_keys_u8_arr_32_values_i32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_HashSet_u8_32 { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Arr_u8_32 } impl ferment :: FFIConversionFrom < std :: collections :: HashSet < [u8 ; 32] > > for std_collections_HashSet_u8_32 { unsafe fn ffi_from_const (ffi : * const std_collections_HashSet_u8_32) -> std :: collections :: HashSet < [u8 ; 32] > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < std :: collections :: HashSet < [u8 ; 32] > > for std_collections_HashSet_u8_32 { unsafe fn ffi_to_const (obj : std :: collections :: HashSet < [u8 ; 32] >) -> * const std_collections_HashSet_u8_32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for std_collections_HashSet_u8_32 { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_u8_32_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut std_collections_HashSet_u8_32 { ferment :: boxed (std_collections_HashSet_u8_32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_u8_32_destroy (ffi : * mut std_collections_HashSet_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_String_values_String { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , String > > for std_collections_Map_keys_String_values_String { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_String_values_String) -> std :: collections :: BTreeMap < String , String > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , String > > for std_collections_Map_keys_String_values_String { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < String , String >) -> * const std_collections_Map_keys_String_values_String { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_String_values_String { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr_composer (self . keys , self . count , ferment :: unbox_string) ; ferment :: unbox_any_vec_ptr_composer (self . values , self . count , ferment :: unbox_string) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_String_ctor (count : usize , keys : * mut * mut std :: os :: raw :: c_char , values : * mut * mut std :: os :: raw :: c_char) -> * mut std_collections_Map_keys_String_values_String { ferment :: boxed (std_collections_Map_keys_String_values_String { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_String_destroy (ffi : * mut std_collections_Map_keys_String_values_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_example_entry_point_entry_FFIContext { pub count : usize , pub values : * mut * mut example_entry_point :: entry :: FFIContext } impl ferment :: FFIConversionFrom < Vec < example_entry_point :: entry :: FFIContext > > for Vec_example_entry_point_entry_FFIContext { unsafe fn ffi_from_const (ffi : * const Vec_example_entry_point_entry_FFIContext) -> Vec < example_entry_point :: entry :: FFIContext > { let ffi_ref = & * ffi ; ferment :: from_opaque_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < example_entry_point :: entry :: FFIContext > > for Vec_example_entry_point_entry_FFIContext { unsafe fn ffi_to_const (obj : Vec < example_entry_point :: entry :: FFIContext >) -> * const Vec_example_entry_point_entry_FFIContext { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_opaque_group (obj . into_iter ()) }) } } impl Drop for Vec_example_entry_point_entry_FFIContext { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_example_entry_point_entry_FFIContext_ctor (count : usize , values : * mut * mut example_entry_point :: entry :: FFIContext) -> * mut Vec_example_entry_point_entry_FFIContext { ferment :: boxed (Vec_example_entry_point_entry_FFIContext { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_example_entry_point_entry_FFIContext_destroy (ffi : * mut Vec_example_entry_point_entry_FFIContext) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_bool { pub obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_RTRN_bool } impl ferment :: FFIConversionFrom < std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void) -> bool > > for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_bool { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_bool) -> std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void) -> bool > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (move | o_0 | unsafe { (& * ffi_ref . obj) . call (o_0) }) } } impl Drop for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_bool { fn drop (& mut self) { unsafe { ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_bool_ctor (obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_RTRN_bool) -> * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_bool { ferment :: boxed (std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_bool { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_bool_destroy (ffi : * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_bool) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_Option_std_net_SocketAddr_bool_RTRN_ { pub obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_Option_std_net_SocketAddr_bool_RTRN_ } impl ferment :: FFIConversionFrom < std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , bool , i32 , [u8 ; 32] , u32 , [u8 ; 32] , [u8 ; 32] , [u8 ; 32] , Option < std :: net :: SocketAddr > , bool) > > for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_Option_std_net_SocketAddr_bool_RTRN_ { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_Option_std_net_SocketAddr_bool_RTRN_) -> std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , bool , i32 , [u8 ; 32] , u32 , [u8 ; 32] , [u8 ; 32] , [u8 ; 32] , Option < std :: net :: SocketAddr > , bool) > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (move | o_0 , o_1 , o_2 , o_3 , o_4 , o_5 , o_6 , o_7 , o_8 , o_9 | unsafe { (& * ffi_ref . obj) . call (o_0 , o_1 , o_2 , o_3 , o_4 , o_5 , o_6 , o_7 , o_8 , o_9) }) } } impl Drop for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_Option_std_net_SocketAddr_bool_RTRN_ { fn drop (& mut self) { unsafe { ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_Option_std_net_SocketAddr_bool_RTRN__ctor (obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_Option_std_net_SocketAddr_bool_RTRN_) -> * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_Option_std_net_SocketAddr_bool_RTRN_ { ferment :: boxed (std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_Option_std_net_SocketAddr_bool_RTRN_ { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_Option_std_net_SocketAddr_bool_RTRN__destroy (ffi : * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_Option_std_net_SocketAddr_bool_RTRN_) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Arr_u8_32 { pub count : usize , pub values : * mut u8 } impl ferment :: FFIConversionFrom < [u8 ; 32] > for Arr_u8_32 { unsafe fn ffi_from_const (ffi : * const Arr_u8_32) -> [u8 ; 32] { let ffi_ref = & * ffi ; let vec : Vec < u8 > = ferment :: from_primitive_group (ffi_ref . values , ffi_ref . count) ; vec . try_into () . unwrap () } } impl ferment :: FFIConversionTo < [u8 ; 32] > for Arr_u8_32 { unsafe fn ffi_to_const (obj : [u8 ; 32]) -> * const Arr_u8_32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_primitive_group (obj . into_iter ()) }) } } impl Drop for Arr_u8_32 { fn drop (& mut self) { unsafe { ferment :: unbox_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Arr_u8_32_ctor (count : usize , values : * mut u8) -> * mut Arr_u8_32 { ferment :: boxed (Arr_u8_32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Arr_u8_32_destroy (ffi : * mut Arr_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Result_ok_bool_err_example_entry_point_keychain_KeyChainError { pub ok : * mut bool , pub error : * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainError } impl ferment :: FFIConversionFrom < Result < bool , example_entry_point :: keychain :: KeyChainError > > for Result_ok_bool_err_example_entry_point_keychain_KeyChainError { unsafe fn ffi_from_const (ffi : * const Result_ok_bool_err_example_entry_point_keychain_KeyChainError) -> Result < bool , example_entry_point :: keychain :: KeyChainError > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | * o , ffi_ref . error , | o | < crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainError as ferment :: FFIConversionFrom < example_entry_point :: keychain :: KeyChainError >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < Result < bool , example_entry_point :: keychain :: KeyChainError > > for Result_ok_bool_err_example_entry_point_keychain_KeyChainError { unsafe fn ffi_to_const (obj : Result < bool , example_entry_point :: keychain :: KeyChainError >) -> * const Result_ok_bool_err_example_entry_point_keychain_KeyChainError { ferment :: boxed ({ let (ok , error) = ferment :: to_result (obj , | o | ferment :: boxed (o) , | o | ferment :: FFIConversionTo :: ffi_to (o)) ; Self { ok , error } }) } } impl Drop for Result_ok_bool_err_example_entry_point_keychain_KeyChainError { fn drop (& mut self) { unsafe { ferment :: destroy_opt_primitive (self . ok) ; ferment :: unbox_any_opt (self . error) ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_bool_err_example_entry_point_keychain_KeyChainError_ctor (ok : * mut bool , error : * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainError) -> * mut Result_ok_bool_err_example_entry_point_keychain_KeyChainError { ferment :: boxed (Result_ok_bool_err_example_entry_point_keychain_KeyChainError { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_bool_err_example_entry_point_keychain_KeyChainError_destroy (ffi : * mut Result_ok_bool_err_example_entry_point_keychain_KeyChainError) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_u8_arr_32_values_Vec_u8 { pub count : usize , pub keys : * mut * mut crate :: fermented :: generics :: Arr_u8_32 , pub values : * mut * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < std :: collections :: HashMap < [u8 ; 32] , Vec < u8 > > > for std_collections_Map_keys_u8_arr_32_values_Vec_u8 { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u8_arr_32_values_Vec_u8) -> std :: collections :: HashMap < [u8 ; 32] , Vec < u8 > > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (o) , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: HashMap < [u8 ; 32] , Vec < u8 > > > for std_collections_Map_keys_u8_arr_32_values_Vec_u8 { unsafe fn ffi_to_const (obj : std :: collections :: HashMap < [u8 ; 32] , Vec < u8 > >) -> * const std_collections_Map_keys_u8_arr_32_values_Vec_u8 { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_u8_arr_32_values_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . keys , self . count) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u8_arr_32_values_Vec_u8_ctor (count : usize , keys : * mut * mut crate :: fermented :: generics :: Arr_u8_32 , values : * mut * mut crate :: fermented :: generics :: Vec_u8) -> * mut std_collections_Map_keys_u8_arr_32_values_Vec_u8 { ferment :: boxed (std_collections_Map_keys_u8_arr_32_values_Vec_u8 { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u8_arr_32_values_Vec_u8_destroy (ffi : * mut std_collections_Map_keys_u8_arr_32_values_Vec_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_std_net_SocketAddr_bool_RTRN_ { pub obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_std_net_SocketAddr_bool_RTRN_ } impl ferment :: FFIConversionFrom < std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , bool , i32 , [u8 ; 32] , u32 , [u8 ; 32] , [u8 ; 32] , [u8 ; 32] , std :: net :: SocketAddr , bool) > > for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_std_net_SocketAddr_bool_RTRN_ { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_std_net_SocketAddr_bool_RTRN_) -> std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , bool , i32 , [u8 ; 32] , u32 , [u8 ; 32] , [u8 ; 32] , [u8 ; 32] , std :: net :: SocketAddr , bool) > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (move | o_0 , o_1 , o_2 , o_3 , o_4 , o_5 , o_6 , o_7 , o_8 , o_9 | unsafe { (& * ffi_ref . obj) . call (o_0 , o_1 , o_2 , o_3 , o_4 , o_5 , o_6 , o_7 , o_8 , o_9) }) } } impl Drop for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_std_net_SocketAddr_bool_RTRN_ { fn drop (& mut self) { unsafe { ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_std_net_SocketAddr_bool_RTRN__ctor (obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_std_net_SocketAddr_bool_RTRN_) -> * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_std_net_SocketAddr_bool_RTRN_ { ferment :: boxed (std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_std_net_SocketAddr_bool_RTRN_ { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_std_net_SocketAddr_bool_RTRN__destroy (ffi : * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_i32_Arr_u8_32_u32_Arr_u8_32_Arr_u8_32_Arr_u8_32_std_net_SocketAddr_bool_RTRN_) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_cell_RefCell_u8_32 { pub obj : * mut crate :: fermented :: generics :: Arr_u8_32 } impl ferment :: FFIConversionFrom < std :: cell :: RefCell < [u8 ; 32] > > for std_cell_RefCell_u8_32 { unsafe fn ffi_from_const (ffi : * const std_cell_RefCell_u8_32) -> std :: cell :: RefCell < [u8 ; 32] > { let ffi_ref = & * ffi ; std :: cell :: RefCell :: new (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: cell :: RefCell < [u8 ; 32] > > for std_cell_RefCell_u8_32 { unsafe fn ffi_to_const (obj : std :: cell :: RefCell < [u8 ; 32] >) -> * const std_cell_RefCell_u8_32 { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to (obj . into_inner ()) }) } } impl Drop for std_cell_RefCell_u8_32 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_cell_RefCell_u8_32_ctor (obj : * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut std_cell_RefCell_u8_32 { ferment :: boxed (std_cell_RefCell_u8_32 { obj }) } # [no_mangle] pub unsafe extern "C" fn std_cell_RefCell_u8_32_destroy (ffi : * mut std_cell_RefCell_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_std_os_raw_c_void_RTRN_Arr_u8_32 { caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void) -> * mut crate :: fermented :: generics :: Arr_u8_32 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32) } impl Fn_ARGS_std_os_raw_c_void_RTRN_Arr_u8_32 { pub unsafe fn call (& self , o_0 : * const std :: os :: raw :: c_void) -> [u8 ; 32] { let ffi_result = (self . caller) (o_0) ; let result = < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (ffi_result) ; (self . destructor) (ffi_result) ; result } } unsafe impl Send for Fn_ARGS_std_os_raw_c_void_RTRN_Arr_u8_32 { } unsafe impl Sync for Fn_ARGS_std_os_raw_c_void_RTRN_Arr_u8_32 { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_RTRN_Arr_u8_32_ctor (caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void) -> * mut crate :: fermented :: generics :: Arr_u8_32 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32)) -> * mut Fn_ARGS_std_os_raw_c_void_RTRN_Arr_u8_32 { ferment :: boxed (Fn_ARGS_std_os_raw_c_void_RTRN_Arr_u8_32 { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_RTRN_Arr_u8_32_destroy (ffi : * mut Fn_ARGS_std_os_raw_c_void_RTRN_Arr_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_ { pub obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_RTRN_ } impl ferment :: FFIConversionFrom < std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void) > > for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_ { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_) -> std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void) > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (move | o_0 | unsafe { (& * ffi_ref . obj) . call (o_0) }) } } impl Drop for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_ { fn drop (& mut self) { unsafe { ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN__ctor (obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_RTRN_) -> * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_ { ferment :: boxed (std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_ { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN__destroy (ffi : * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_u32_RTRN_Option_String { caller : unsafe extern "C" fn (u32) -> * mut std :: os :: raw :: c_char , destructor : unsafe extern "C" fn (* mut std :: os :: raw :: c_char) } impl Fn_ARGS_u32_RTRN_Option_String { pub unsafe fn call (& self , o_0 : u32) -> Option < String > { let ffi_result = (self . caller) (o_0) ; if ffi_result . is_null () { None } else { let result = < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_result) ; (self . destructor) (ffi_result) ; result } } } unsafe impl Send for Fn_ARGS_u32_RTRN_Option_String { } unsafe impl Sync for Fn_ARGS_u32_RTRN_Option_String { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_RTRN_Option_String_ctor (caller : unsafe extern "C" fn (u32) -> * mut std :: os :: raw :: c_char , destructor : unsafe extern "C" fn (* mut std :: os :: raw :: c_char)) -> * mut Fn_ARGS_u32_RTRN_Option_String { ferment :: boxed (Fn_ARGS_u32_RTRN_Option_String { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_RTRN_Option_String_destroy (ffi : * mut Fn_ARGS_u32_RTRN_Option_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_example_entry_point_provider_wallet_ex_WalletEx2_Arr_u8_32_bool_RTRN_Option_u8_32 { caller : unsafe extern "C" fn (* const example_entry_point :: provider :: wallet_ex :: WalletEx2 , * mut crate :: fermented :: generics :: Arr_u8_32 , bool) -> * mut crate :: fermented :: generics :: Arr_u8_32 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32) } impl Fn_ARGS_example_entry_point_provider_wallet_ex_WalletEx2_Arr_u8_32_bool_RTRN_Option_u8_32 { pub unsafe fn call (& self , o_0 : * const example_entry_point :: provider :: wallet_ex :: WalletEx2 , o_1 : & [u8 ; 32] , o_2 : bool) -> Option < [u8 ; 32] > { let ffi_result = (self . caller) (o_0 , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_1 . clone ()) , o_2) ; let result = < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from_opt (ffi_result) ; (self . destructor) (ffi_result) ; result } } unsafe impl Send for Fn_ARGS_example_entry_point_provider_wallet_ex_WalletEx2_Arr_u8_32_bool_RTRN_Option_u8_32 { } unsafe impl Sync for Fn_ARGS_example_entry_point_provider_wallet_ex_WalletEx2_Arr_u8_32_bool_RTRN_Option_u8_32 { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_example_entry_point_provider_wallet_ex_WalletEx2_Arr_u8_32_bool_RTRN_Option_u8_32_ctor (caller : unsafe extern "C" fn (* const example_entry_point :: provider :: wallet_ex :: WalletEx2 , * mut crate :: fermented :: generics :: Arr_u8_32 , bool) -> * mut crate :: fermented :: generics :: Arr_u8_32 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32)) -> * mut Fn_ARGS_example_entry_point_provider_wallet_ex_WalletEx2_Arr_u8_32_bool_RTRN_Option_u8_32 { ferment :: boxed (Fn_ARGS_example_entry_point_provider_wallet_ex_WalletEx2_Arr_u8_32_bool_RTRN_Option_u8_32 { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_example_entry_point_provider_wallet_ex_WalletEx2_Arr_u8_32_bool_RTRN_Option_u8_32_destroy (ffi : * mut Fn_ARGS_example_entry_point_provider_wallet_ex_WalletEx2_Arr_u8_32_bool_RTRN_Option_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_u8 { pub count : usize , pub values : * mut u8 } impl ferment :: FFIConversionFrom < Vec < u8 > > for Vec_u8 { unsafe fn ffi_from_const (ffi : * const Vec_u8) -> Vec < u8 > { let ffi_ref = & * ffi ; ferment :: from_primitive_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < u8 > > for Vec_u8 { unsafe fn ffi_to_const (obj : Vec < u8 >) -> * const Vec_u8 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_primitive_group (obj . into_iter ()) }) } } impl Drop for Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_u8_ctor (count : usize , values : * mut u8) -> * mut Vec_u8 { ferment :: boxed (Vec_u8 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_u8_destroy (ffi : * mut Vec_u8) { ferment :: unbox_any (ffi) ; } }